<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="本文将讲解 hooks 的执行过程以及常用的 hooks 的源码。                     hooks 相关数据结构       要理解 hooks 的执行过程，首先想要大家对 hooks 相关的数据结构有所了解，便于后面大家顺畅地阅读代码。                     Hook       每一个 hooks 方法都会生成一个类型为 Hook 的对象，用来存储一些信息">
<meta property="og:type" content="article">
<meta property="og:title" content="React hooks 源码解析">
<meta property="og:url" content="https://niki571.github.io/React%20hooks%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="吴倩颖的网络日志">
<meta property="og:description" content="本文将讲解 hooks 的执行过程以及常用的 hooks 的源码。                     hooks 相关数据结构       要理解 hooks 的执行过程，首先想要大家对 hooks 相关的数据结构有所了解，便于后面大家顺畅地阅读代码。                     Hook       每一个 hooks 方法都会生成一个类型为 Hook 的对象，用来存储一些信息">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/8cbbf443229943d89902355c2dc5d373_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/f6dd618d1c1642a6bbec25ed82c0a408_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/22a64ff368474815b9cbc58fefd755a8_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="article:published_time" content="2021-06-15T11:56:12.000Z">
<meta property="article:modified_time" content="2023-03-20T07:11:23.672Z">
<meta property="article:author" content="WuQianying">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/8cbbf443229943d89902355c2dc5d373_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"><title>React hooks 源码解析 | 吴倩颖的网络日志</title><link ref="canonical" href="https://niki571.github.io/React%20hooks%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":true},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-solid fa-pen-nib"></i></span><span class="header-nav-menu-item__text">文章</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-solid fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/"><span class="header-nav-submenu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-submenu-item__text">分类</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-solid fa-tag"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/me/"><span class="header-nav-menu-item__icon"><i class="fas fa-solid fa-star"></i></span><span class="header-nav-menu-item__text">我</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">吴倩颖的网络日志</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">React hooks 源码解析</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-06-15</span></span></div></header><div class="post-body"><p>本文将讲解 hooks 的执行过程以及常用的 hooks 的源码。</p>

        <h1 id="hooks-相关数据结构"   >
          <a href="#hooks-相关数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#hooks-相关数据结构" class="headerlink" title="hooks 相关数据结构"></a>hooks 相关数据结构</h1>
      <p>要理解 hooks 的执行过程，首先想要大家对 hooks 相关的数据结构有所了解，便于后面大家顺畅地阅读代码。</p>

        <h2 id="Hook"   >
          <a href="#Hook" class="heading-link"><i class="fas fa-link"></i></a><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2>
      <p>每一个 hooks 方法都会生成一个类型为 Hook 的对象，用来存储一些信息，前面提到过函数组件 fiber 中的 memoizedState 会存储 hooks 链表，每个链表结点的结构就是 Hook。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Hook</span> = &#123;|</span><br><span class="line">  <span class="attr">memoizedState</span>: any, <span class="comment">// 上次渲染时所用的 state</span></span><br><span class="line">  <span class="attr">baseState</span>: any, <span class="comment">// 已处理的 update 计算出的 state</span></span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="title class_">Update</span>&lt;any, any&gt; | <span class="literal">null</span>, <span class="comment">// 未处理的 update 队列（一般是上一轮渲染未完成的 update）</span></span><br><span class="line">  <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;any, any&gt; | <span class="literal">null</span>, <span class="comment">// 当前出发的 update 队列</span></span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Hook</span> | <span class="literal">null</span>, <span class="comment">// 指向下一个 hook，形成链表结构</span></span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></div></figure>

<span id="more"></span>

<p>举个例子，我们通过函数组件使用了两个 useState hooks：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&quot;小科比&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> [age, setAge] = <span class="title function_">useState</span>(<span class="number">23</span>);</span><br></pre></td></tr></table></div></figure>

<p>则实际的 Hook 结构如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">next</span>: &#123;</span><br><span class="line">    <span class="attr">memoizedState</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">baseState</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>不同的 hooks 方法，memoizedState 存储的内容不同，常用的 hooks memoizedState 存储的内容如下：</p>
<ul>
<li>useState: state</li>
<li>useEffect: effect 对象</li>
<li>useMemo&#x2F;useCallback: [callback, deps]</li>
<li>useRef: { current: xxx }</li>
</ul>

        <h2 id="Update-amp-UpdateQueue"   >
          <a href="#Update-amp-UpdateQueue" class="heading-link"><i class="fas fa-link"></i></a><a href="#Update-amp-UpdateQueue" class="headerlink" title="Update &amp; UpdateQueue"></a>Update &amp; UpdateQueue</h2>
      <p>Update 和 UpdateQueue 是存储 useState 的 state 及 useReducer 的 reducer 相关内容的数据结构。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line">type <span class="title class_">Update</span>&lt;S, A&gt; = &#123;|</span><br><span class="line">  <span class="attr">lane</span>: <span class="title class_">Lane</span>, <span class="comment">// 优先级</span></span><br><span class="line">  <span class="comment">// reducer 对应要执行的 action</span></span><br><span class="line">  <span class="attr">action</span>: A,</span><br><span class="line">  <span class="comment">// 触发 dispatch 时的 reducer</span></span><br><span class="line">  <span class="attr">eagerReducer</span>: (<span class="function">(<span class="params">S, A</span>) =&gt;</span> S) | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 触发 dispatch 是的 state</span></span><br><span class="line">  <span class="attr">eagerState</span>: S | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 下一个要执行的 Update</span></span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Update</span>&lt;S, A&gt;,</span><br><span class="line">  <span class="comment">// react 的优先级权重</span></span><br><span class="line">  priority?: <span class="title class_">ReactPriorityLevel</span>,</span><br><span class="line">|&#125;;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">UpdateQueue</span>&lt;S, A&gt; = &#123;|</span><br><span class="line">  <span class="comment">// 当前要触发的 update</span></span><br><span class="line">  <span class="attr">pending</span>: <span class="title class_">Update</span>&lt;S, A&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 存放 dispatchAction.bind() 的值</span></span><br><span class="line">  <span class="attr">dispatch</span>: (<span class="function">(<span class="params">A</span>) =&gt;</span> mixed) | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 上一次 render 的 reducer</span></span><br><span class="line">  <span class="attr">lastRenderedReducer</span>: (<span class="function">(<span class="params">S, A</span>) =&gt;</span> S) | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 上一次 render 的 state</span></span><br><span class="line">  <span class="attr">lastRenderedState</span>: S | <span class="literal">null</span>,</span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></div></figure>

<p>每次调用 setState 或者 useReducer 的 dispatch 时，都会生成一个 Update 类型的对象，并将其添加到 UpdateQueue 队列中。<br>例如，在如下的函数组件中:</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&quot;小科比&quot;</span>);</span><br><span class="line"><span class="title function_">setName</span>(<span class="string">&quot;大科比&quot;</span>);</span><br></pre></td></tr></table></div></figure>

<p>当我们点击 input 按钮时，执行了 setName()，此时对应的 hook 结构如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">queue</span>: &#123;</span><br><span class="line">    <span class="attr">pending</span>: &#123;</span><br><span class="line">      <span class="attr">lane</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">action</span>: <span class="string">&#x27;大科比&#x27;</span>,</span><br><span class="line">      <span class="attr">eagerState</span>: <span class="string">&#x27;大科比&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">lastRenderedState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>最后 react 会遍历 UpdateQueue 中的每个 Update 去进行更新。</p>

        <h2 id="Effect"   >
          <a href="#Effect" class="heading-link"><i class="fas fa-link"></i></a><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h2>
      <p>Effect 结构是和 useEffect 等 hooks 相关的，我们看一下它的结构：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Effect</span> = &#123;|</span><br><span class="line">  <span class="attr">tag</span>: <span class="title class_">HookFlags</span>, <span class="comment">// 标记是否有 effect 需要执行</span></span><br><span class="line">  <span class="attr">create</span>: <span class="function">() =&gt;</span> (<span class="function">() =&gt;</span> <span class="keyword">void</span>) | <span class="keyword">void</span>, <span class="comment">// 回调函数</span></span><br><span class="line">  <span class="attr">destroy</span>: (<span class="function">() =&gt;</span> <span class="keyword">void</span>) | <span class="keyword">void</span>, <span class="comment">// 销毁时触发的回调</span></span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span>, <span class="comment">// 依赖的数组</span></span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Effect</span>, <span class="comment">// 下一个要执行的 Effect</span></span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></div></figure>

<p>当我们的函数组件中使用了如下的 useEffect 时：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></div></figure>

<p>对应的 Hook 如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: &#123;</span><br><span class="line">    <span class="attr">create</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>) &#125;,</span><br><span class="line">    <span class="attr">destroy</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bye&#x27;</span>) &#125;,</span><br><span class="line">    <span class="attr">deps</span>: [],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">baseState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="执行过程"   >
          <a href="#执行过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1>
      <p>下面我们探索一下 hooks 在 react 中具体的执行流程。<br>引入 hooks<br>我们以一个简单的 hooks 写法的 react 应用程序为例去寻找 hooks 源码:</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&quot;增加&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          setCount(count + 1);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>根据引入的 useState api，我们找到 react hooks 的入口文件：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react/src/ReactHooks.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveDispatcher</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> useState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = <span class="title function_">resolveDispatcher</span>();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.<span class="title function_">useState</span>(initialState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></div></figure>

<p>根据上面的源码我们可以知道，所有的 hooks api 都是挂载在 resolveDispatcher 中返回的 dispatcher 对象上面的，也就是挂载在 ReactCurrentDispatcher.current 上面，那么我们再继续去看一下 ReactCurrentDispatcher 是什么：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react/src/ReactCurrentDispatcher.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> type &#123; <span class="title class_">Dispatcher</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-reconciler/src/ReactInternalTypes&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReactCurrentDispatcher</span> = &#123;</span><br><span class="line">  <span class="attr">current</span>: (<span class="attr">null</span>: <span class="literal">null</span> | <span class="title class_">Dispatcher</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ReactCurrentDispatcher</span>;</span><br></pre></td></tr></table></div></figure>

<p>到这里我们的线索就断了，ReactCurrentDispatcher 上只有一个 current 用于挂在 hooks，但是 hooks 的详细源码以及 ReactCurrentDispatcher 的具体内容我们并没有找到在哪里，所以我们只能另寻出路，从 react 的执行过程去入手。</p>

        <h2 id="函数组件更新过程"   >
          <a href="#函数组件更新过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数组件更新过程" class="headerlink" title="函数组件更新过程"></a>函数组件更新过程</h2>
      <p>我们的 hooks 都是在函数组件中使用的，所以让我们去看一下 render 过程关于函数组件的更新。render 过程中的调度是从 beginWork 开始的，来到 beginWork 的源码后我们可以发现，针对函数组件的渲染和更新，使用了 updateFunctionComponent 函数：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberBeginWork.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>: &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateFunctionComponent</span>(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        <span class="title class_">Component</span>,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>那我们在继续看一下 updateFunctionComponent 函数的源码，里面调用了 renderWithHooks 函数，这便是函数组件更新和渲染过程执行的入口：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberBeginWork.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateFunctionComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current,</span></span><br><span class="line"><span class="params">  workInProgress,</span></span><br><span class="line"><span class="params">  Component,</span></span><br><span class="line"><span class="params">  nextProps: any,</span></span><br><span class="line"><span class="params">  renderLanes</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  nextChildren = <span class="title function_">renderWithHooks</span>(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    <span class="title class_">Component</span>,</span><br><span class="line">    nextProps,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="renderWithHooks"   >
          <a href="#renderWithHooks" class="heading-link"><i class="fas fa-link"></i></a><a href="#renderWithHooks" class="headerlink" title="renderWithHooks"></a>renderWithHooks</h2>
      <p>费劲千辛万苦，我们终于来到了函数组件更新过程的执行入口 —— renderWithHooks 函数的源码：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberBeginWork.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> renderWithHooks&lt;<span class="title class_">Props</span>, <span class="title class_">SecondArg</span>&gt;(</span><br><span class="line">  <span class="attr">current</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">workInProgress</span>: <span class="title class_">Fiber</span>,</span><br><span class="line">  <span class="title class_">Component</span>: <span class="function">(<span class="params">p: Props, arg: SecondArg</span>) =&gt;</span> any,</span><br><span class="line">  <span class="attr">props</span>: <span class="title class_">Props</span>,</span><br><span class="line">  <span class="attr">secondArg</span>: <span class="title class_">SecondArg</span>,</span><br><span class="line">  <span class="attr">nextRenderLanes</span>: <span class="title class_">Lanes</span>,</span><br><span class="line">): any &#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  <span class="comment">// currentlyRenderingFiber 指向当前所执行的 fiber</span></span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 置空 workInProgress fiber 中的 memoizedState 和 updateQueue</span></span><br><span class="line">  workInProgress.<span class="property">memoizedState</span> = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.<span class="property">updateQueue</span> = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 根据是否首次渲染，分别将 HooksDispatcherOnMount 和 HooksDispatcherOnUpdate 赋值给 ReactCurrentDispatcher.current</span></span><br><span class="line">  <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> =</span><br><span class="line">  current === <span class="literal">null</span> || current.<span class="property">memoizedState</span> === <span class="literal">null</span></span><br><span class="line">  ? <span class="title class_">HooksDispatcherOnMount</span></span><br><span class="line">  : <span class="title class_">HooksDispatcherOnUpdate</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行函数组件的构造函数</span></span><br><span class="line">  <span class="keyword">let</span> children = <span class="title class_">Component</span>(props, secondArg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (didScheduleRenderPhaseUpdateDuringThisPass) &#123;</span><br><span class="line">    <span class="comment">// didScheduleRenderPhaseUpdateDuringThisPass 为 true 说明发生了 re-render，会再次执行 render</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">numberOfReRenders</span>: number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      didScheduleRenderPhaseUpdateDuringThisPass = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = **<span class="variable constant_">DEV</span>**</span><br><span class="line">      ? <span class="title class_">HooksDispatcherOnRerenderInDEV</span></span><br><span class="line">      : <span class="title class_">HooksDispatcherOnRerender</span>;</span><br><span class="line"></span><br><span class="line">      children = <span class="title class_">Component</span>(props, secondArg);</span><br><span class="line">    &#125; <span class="keyword">while</span> (didScheduleRenderPhaseUpdateDuringThisPass);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 函数执行结束后，关闭 hooks 入口</span></span><br><span class="line">  <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">ContextOnlyDispatcher</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...当前 fiber 的任务执行结束，重置全局变量</span></span><br><span class="line"></span><br><span class="line">  renderLanes = <span class="title class_">NoLanes</span>;</span><br><span class="line">  currentlyRenderingFiber = (<span class="attr">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>renderWithHooks</code>函数中首先会将 workInProgress fiber 树的 memoizedState（前面深入理解 fiber 一文中提到过，memoizedState 记录了当前页面的 state，在函数组件中，它以链表的形式记录了 hooks 信息） 和 updateQueue 置为 null，在接下来的函数组件执行过程中，会把新的 hooks 信息挂载到这两个属性上，然后在 commit 阶段，会将根据 current fiber 树构建当前的 workInProgress fiber 树，并保存 hooks 信息，用于替换真实的 DOM 元素节点。<br>然后会通过 current 上是否有 memoizedState，判断组件是否首次渲染，从而分别将 HooksDispatcherOnMount 和 HooksDispatcherOnUpdate 赋值给 <code>ReactCurrentDispatcher.current</code>。<br>接下来执行<code>Component()</code>来调用函数组件的构造函数，组件的 hooks 会被依次执行，并将 hooks 的信息保存到 workInProgress fiber 上（待会儿会细讲执行过程），然后将返回的 jsx 信息保存到 children 上。<br>最后会重置一些变量，并返回函数组件执行后的 jsx。</p>

        <h2 id="不同阶段更新-Hook"   >
          <a href="#不同阶段更新-Hook" class="heading-link"><i class="fas fa-link"></i></a><a href="#不同阶段更新-Hook" class="headerlink" title="不同阶段更新 Hook"></a>不同阶段更新 Hook</h2>
      <p>现在我们终于找到了<code>ReactCurrentDispatcher.current</code>的定义，首次渲染时，会将 <code>HooksDispatcherOnMount</code>赋值给 <code>ReactCurrentDispatcher.current</code>，更新时，会将<code>HooksDispatcherOnUpdate</code> 赋值给 <code>ReactCurrentDispatcher.current</code>， dispatcher 上面挂在了各种 hooks：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  <span class="attr">useCallback</span>: mountCallback,</span><br><span class="line">  <span class="attr">useContext</span>: readContext,</span><br><span class="line">  <span class="attr">useEffect</span>: mountEffect,</span><br><span class="line">  <span class="attr">useImperativeHandle</span>: mountImperativeHandle,</span><br><span class="line">  <span class="attr">useLayoutEffect</span>: mountLayoutEffect,</span><br><span class="line">  <span class="attr">useMemo</span>: mountMemo,</span><br><span class="line">  <span class="attr">useReducer</span>: mountReducer,</span><br><span class="line">  <span class="attr">useRef</span>: mountRef,</span><br><span class="line">  <span class="attr">useState</span>: mountState,</span><br><span class="line">  <span class="attr">useDebugValue</span>: mountDebugValue,</span><br><span class="line">  <span class="attr">useDeferredValue</span>: mountDeferredValue,</span><br><span class="line">  <span class="attr">useTransition</span>: mountTransition,</span><br><span class="line">  <span class="attr">useMutableSource</span>: mountMutableSource,</span><br><span class="line">  <span class="attr">useOpaqueIdentifier</span>: mountOpaqueIdentifier,</span><br><span class="line"></span><br><span class="line">  <span class="attr">unstable_isNewReconciler</span>: enableNewReconciler,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnUpdate</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  <span class="attr">useCallback</span>: updateCallback,</span><br><span class="line">  <span class="attr">useContext</span>: readContext,</span><br><span class="line">  <span class="attr">useEffect</span>: updateEffect,</span><br><span class="line">  <span class="attr">useImperativeHandle</span>: updateImperativeHandle,</span><br><span class="line">  <span class="attr">useLayoutEffect</span>: updateLayoutEffect,</span><br><span class="line">  <span class="attr">useMemo</span>: updateMemo,</span><br><span class="line">  <span class="attr">useReducer</span>: updateReducer,</span><br><span class="line">  <span class="attr">useRef</span>: updateRef,</span><br><span class="line">  <span class="attr">useState</span>: updateState,</span><br><span class="line">  <span class="attr">useDebugValue</span>: updateDebugValue,</span><br><span class="line">  <span class="attr">useDeferredValue</span>: updateDeferredValue,</span><br><span class="line">  <span class="attr">useTransition</span>: updateTransition,</span><br><span class="line">  <span class="attr">useMutableSource</span>: updateMutableSource,</span><br><span class="line">  <span class="attr">useOpaqueIdentifier</span>: updateOpaqueIdentifier,</span><br><span class="line"></span><br><span class="line">  <span class="attr">unstable_isNewReconciler</span>: enableNewReconciler,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>首次渲染时，<code>HooksDispatcherOnMount</code>上挂载的 hook 都是 mountXXX，而更新时 <code>HooksDispatcherOnMount</code>上挂在的 hook 都是 updateXXX。所有 mount 阶段的 hook 中，都会执行 <code>mountWorkInProgressHook</code>这个函数，而所有 update 阶段的 hook 中，都会执行 <code>updateWorkInProgressHook</code>这个函数。下面我们来看下这两个函数分别做了什么。</p>

        <h3 id="mountWorkInProgressHook"   >
          <a href="#mountWorkInProgressHook" class="heading-link"><i class="fas fa-link"></i></a><a href="#mountWorkInProgressHook" class="headerlink" title="mountWorkInProgressHook"></a>mountWorkInProgressHook</h3>
      <p>每个 hooks 方法中，都需要有一个 Hook 结构来存储相关信息。<code>mountWorkInProgressHook</code>中，会初始化创建一个 Hook，然后将其挂载到 workInProgress fiber 的 memoizedState 所指向的 hooks 链表上，以便于下次 update 的时候取出该 Hook：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title class_">Hook</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">hook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">    <span class="attr">memoizedState</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">baseState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若当前 workInProgressHook 为 null，将此 hook 作为 memoizedState 的头结点</span></span><br><span class="line">    currentlyRenderingFiber.<span class="property">memoizedState</span> = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 若不为 null，将 hook 挂载到链表最后</span></span><br><span class="line">    workInProgressHook = workInProgressHook.<span class="property">next</span> = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="updateWorkInProgressHook"   >
          <a href="#updateWorkInProgressHook" class="heading-link"><i class="fas fa-link"></i></a><a href="#updateWorkInProgressHook" class="headerlink" title="updateWorkInProgressHook"></a>updateWorkInProgressHook</h3>
      <p><code>updateWorkInProgressHook</code>的作用主要是取出 current fiber 中的 hooks 链表中对应的 hook 节点，挂载到 workInProgress fiber 上的 hooks 链表：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title class_">Hook</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">nextCurrentHook</span>: <span class="literal">null</span> | <span class="title class_">Hook</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代 current fiber 链表</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若 current 为 null，从 currentlyRenderingFiber.alternate 取 current</span></span><br><span class="line">    <span class="keyword">const</span> current = currentlyRenderingFiber.<span class="property">alternate</span>;</span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextCurrentHook = current.<span class="property">memoizedState</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则从 current fiber 中取下一个 hook</span></span><br><span class="line">    nextCurrentHook = currentHook.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代 workInProgress fiber 链表</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">nextWorkInProgressHook</span>: <span class="literal">null</span> | <span class="title class_">Hook</span>;</span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// workInProgressHook 说明是首次创建</span></span><br><span class="line">    nextWorkInProgressHook 为 <span class="literal">null</span> = currentlyRenderingFiber.<span class="property">memoizedState</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 取下一个 workInProgress Hook</span></span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 只有 re-render 的情况下，nextWorkInProgressHook 不为 null，因为在之前的 render 过程中已经创建过 workInProgress hook 了</span></span><br><span class="line">    <span class="comment">// 此时复用</span></span><br><span class="line">    workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">        currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 正常情况下，currentlyRenderingFiber.memoizedState 为 null，需要到从 current fiber 中克隆一个新的创建</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">invariant</span>(</span><br><span class="line">      nextCurrentHook !== <span class="literal">null</span>,</span><br><span class="line">      <span class="string">&#x27;Rendered more hooks than during the previous render.&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">newHook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">      <span class="attr">memoizedState</span>: currentHook.<span class="property">memoizedState</span>,</span><br><span class="line"></span><br><span class="line">      <span class="attr">baseState</span>: currentHook.<span class="property">baseState</span>,</span><br><span class="line">      <span class="attr">baseQueue</span>: currentHook.<span class="property">baseQueue</span>,</span><br><span class="line">      <span class="attr">queue</span>: currentHook.<span class="property">queue</span>,</span><br><span class="line"></span><br><span class="line">      <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 若 workInProgressHook 为 null，作为首节点赋值给 memoizedState</span></span><br><span class="line">      currentlyRenderingFiber.<span class="property">memoizedState</span> = workInProgressHook = newHook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将 workInProgressHook 添加到链表尾</span></span><br><span class="line">      workInProgressHook = workInProgressHook.<span class="property">next</span> = newHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们详细理解一下上述代码，前面我们提到过 <code>renderWithHooks</code>函数中会执行如下代码：<code>workInProgress.memoizedState = null</code>，所以在执行上述函数时，正常来说 <code>currentlyRenderingFiber.memoizedState</code>为 null，需要从 current fiber 对应的节点中取 clone 对应的 hook，再挂载到 workInProgress fiber 的 memoizedState 链表上；re-render 的情况下，由于已经创建过了 hooks，会复用已有的 workInProgress fiber 的 memoizedState。<br>这里正好提到，为什么 hook 不能用在条件语句中，因为如果前后两次渲染的条件判断不一致时，会导致 current fiber 和 workInProgress fiber 的 hooks 链表结点无法对齐。</p>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>所以我们总结一下<code>renderWithHooks</code>这个函数，它所做的事情如下：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/8cbbf443229943d89902355c2dc5d373_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>

        <h1 id="hooks-源码"   >
          <a href="#hooks-源码" class="heading-link"><i class="fas fa-link"></i></a><a href="#hooks-源码" class="headerlink" title="hooks 源码"></a>hooks 源码</h1>
      <p>前面 hooks 的执行入口我们都找到了，现在我们看一下常用的一些 hooks 源码。</p>

        <h2 id="useState-amp-useReducer"   >
          <a href="#useState-amp-useReducer" class="heading-link"><i class="fas fa-link"></i></a><a href="#useState-amp-useReducer" class="headerlink" title="useState &amp; useReducer"></a>useState &amp; useReducer</h2>
      <p>这里会把 useState 和 useReducer 放在一起来说，因为 useState 相当于一个简化版的 useReducer。</p>

        <h3 id="用法"   >
          <a href="#用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#用法" class="headerlink" title="用法"></a>用法</h3>
      <p>useState 的简单用法如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 改变 count 的值</span></span><br><span class="line"><span class="title function_">setCount</span>(count++);</span><br></pre></td></tr></table></div></figure>

<p>useReducer 简单用法如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, dispatch] = <span class="title function_">useReducer</span>(<span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increment&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 改变 count 的值</span></span><br><span class="line"><span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;increment&quot;</span> &#125;);</span><br></pre></td></tr></table></div></figure>


        <h3 id="mountState-amp-mountReducer"   >
          <a href="#mountState-amp-mountReducer" class="heading-link"><i class="fas fa-link"></i></a><a href="#mountState-amp-mountReducer" class="headerlink" title="mountState &amp; mountReducer"></a>mountState &amp; mountReducer</h3>
      <p>我们先从 useState 开始讲起，mount 阶段，useState 对应的源码是 mountState。这里面后创建初始的 hook 和更新队列 queue，然后创建 dispatch，最终返回 [hook.memoizedState, dispatch]，对应的是我们代码中的 [count, setCount]，供我们使用：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  <span class="comment">// 创建一个 hook，链接到 hooks 链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="comment">// 校验初始的 state 是否是个函数，是的话执行该函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    initialState = <span class="title function_">initialState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前面提到过，对于 useState，memoizedState 保存的是 state</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = hook.<span class="property">baseState</span> = initialState;</span><br><span class="line">  <span class="comment">// 创建更新队列 updateQueue</span></span><br><span class="line">  <span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>, <span class="comment">// 待执行的 hook</span></span><br><span class="line">    <span class="attr">dispatch</span>: <span class="literal">null</span>, <span class="comment">// 更新函数</span></span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: basicStateReducer, <span class="comment">// 上次渲染的 reducer</span></span><br><span class="line">    <span class="attr">lastRenderedState</span>: (<span class="attr">initialState</span>: any), <span class="comment">// 上次渲染的 state</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 创建 dispatch（负责更新的函数）</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt; = (queue.<span class="property">dispatch</span> =</span><br><span class="line">    (dispatchAction.<span class="title function_">bind</span>(<span class="literal">null</span>, currentlyRenderingFiber, queue): any));</span><br><span class="line">  <span class="comment">// 返回 useState 的 state 及 dispatch，供我们使用</span></span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>再来看下 mount 阶段的 useReducer 的源码，也就是 mountReducer，可以看到和 mountState 所做的事情基本时一样的，mountState 可以看做是有一个初始 state 的 mountReducer：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountReducer&lt;S, I, A&gt;(</span><br><span class="line">  <span class="attr">reducer</span>: <span class="function">(<span class="params">S, A</span>) =&gt;</span> S,</span><br><span class="line">  <span class="attr">initialArg</span>: I,</span><br><span class="line">  init?: <span class="function">(<span class="params">I</span>) =&gt;</span> S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;A&gt;] &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">let</span> initialState;</span><br><span class="line">  <span class="keyword">if</span> (init !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    initialState = <span class="title function_">init</span>(initialArg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    initialState = ((<span class="attr">initialArg</span>: any): S);</span><br><span class="line">  &#125;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = hook.<span class="property">baseState</span> = initialState;</span><br><span class="line">  <span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">dispatch</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: reducer,</span><br><span class="line">    <span class="attr">lastRenderedState</span>: (<span class="attr">initialState</span>: any),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;A&gt; = (queue.<span class="property">dispatch</span> = (dispatchAction.<span class="title function_">bind</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    queue</span><br><span class="line">  ): any));</span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="dispatchAction"   >
          <a href="#dispatchAction" class="heading-link"><i class="fas fa-link"></i></a><a href="#dispatchAction" class="headerlink" title="dispatchAction"></a>dispatchAction</h3>
      <p>上面的代码中，其他内容我们前面基本都有讲过，你们应该了解它们的作用，我们着重来看一下 dispatch，它是通过执行 dispatchAction 创建的。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> dispatchAction&lt;S, A&gt;(</span><br><span class="line">  <span class="attr">fiber</span>: <span class="title class_">Fiber</span>,</span><br><span class="line">  <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;S, A&gt;,</span><br><span class="line">  <span class="attr">action</span>: A,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 获取更新触发时间及优先级</span></span><br><span class="line">  <span class="keyword">const</span> eventTime = <span class="title function_">requestEventTime</span>();</span><br><span class="line">  <span class="keyword">const</span> lane = <span class="title function_">requestUpdateLane</span>(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 update</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">update</span>: <span class="title class_">Update</span>&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action,</span><br><span class="line">    <span class="attr">eagerReducer</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">eagerState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 update 链接到更新队列中</span></span><br><span class="line">  <span class="keyword">const</span> pending = queue.<span class="property">pending</span>;</span><br><span class="line">  <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">    update.<span class="property">next</span> = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.<span class="property">next</span> = pending.<span class="property">next</span>;</span><br><span class="line">    pending.<span class="property">next</span> = update;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.<span class="property">pending</span> = update;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> alternate = fiber.<span class="property">alternate</span>;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    fiber === currentlyRenderingFiber ||</span><br><span class="line">    (alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// currentlyRenderingFiber 存在，说明是在 render 过程发生的更新</span></span><br><span class="line">    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">    fiber.<span class="property">lanes</span> === <span class="title class_">NoLanes</span> &amp;&amp;</span><br><span class="line">    (alternate === <span class="literal">null</span> || alternate.<span class="property">lanes</span> === <span class="title class_">NoLanes</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// fiber.lanes === NoLanes 说明是首次更新</span></span><br><span class="line">      <span class="comment">// 如果值不同，则保存在 eagerState，下次 render 时可以直接使用，而无需再计算。</span></span><br><span class="line">      <span class="keyword">const</span> lastRenderedReducer = queue.<span class="property">lastRenderedReducer</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prevDispatcher;</span><br><span class="line">        <span class="keyword">if</span> (**<span class="variable constant_">DEV</span>**) &#123;</span><br><span class="line">          prevDispatcher = <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span>;</span><br><span class="line">          <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">InvalidNestedHooksDispatcherOnUpdateInDEV</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="attr">currentState</span>: S = (queue.<span class="property">lastRenderedState</span>: any);</span><br><span class="line">          <span class="comment">// 我们可以根据当前 state 和 action 来计算新的 state 值</span></span><br><span class="line">          <span class="keyword">const</span> eagerState = <span class="title function_">lastRenderedReducer</span>(currentState, action);</span><br><span class="line">          update.<span class="property">eagerReducer</span> = lastRenderedReducer;</span><br><span class="line">          update.<span class="property">eagerState</span> = eagerState;</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">is</span>(eagerState, currentState)) &#123;</span><br><span class="line">            <span class="comment">// 如果与当前值相同，则跳过更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 如果值不同，新一轮更新时渲染 eagerState</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (**<span class="variable constant_">DEV</span>**) &#123;</span><br><span class="line">            <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = prevDispatcher;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 开启调度，触发新的一轮更新，也就是走 beginWork, completeWork 那一套流程</span></span><br><span class="line">    <span class="title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">    <span class="title function_">markStateUpdateScheduled</span>(fiber, lane);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>首先，会创建一个初始的 update 对象，用来记录相关的 hook 信息，并将它添加到 queue 中，这里的 queue 的添加你可以发现它形成了一个循环链表，这样 pending 作为链表的一个尾结点，而 pending.next 就能够获取链表的头结点。这样做的目的是，在 setCount 时，我们需要将 update 添加到链表的尾部；而在下面的 updateReducer 中，我们需要获取链表的头结点来遍历链表，通过循环链表能够轻松实现我们的需求。<br>之后，会根据当前所处的阶段是否在 render 阶段发生：</p>
<p>如果是 render 阶段发生，那么会触发 re-render 过程，将 didScheduleRenderPhaseUpdateDuringThisPass 置为 true。前面 renderWithHooks 的代码中我们说了，didScheduleRenderPhaseUpdateDuringThisPass 为 true 时会代表 re-render，会重新执行 render 过程，直至其为 false。<br>如果不是在 render 阶段发生，那么会通过当前的 state 和 action 来判断下次渲染的 state 的值，并与当前 state 的值进行比较，如果两个值一致，则不需要更新，跳过更新过程；如果两个值不一致，调用 scheduleUpdateOnFiber 开始调度，触发新一轮更新。</p>

        <h3 id="updateReducer"   >
          <a href="#updateReducer" class="heading-link"><i class="fas fa-link"></i></a><a href="#updateReducer" class="headerlink" title="updateReducer"></a>updateReducer</h3>
      <p>update 时，useState 和 useReducer 就更没什么区别了，updateState 就是直接返回了 updateReducer 函数，所以我们直接看 updateReducer 的源码就可以。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">updateReducer</span>(basicStateReducer, (<span class="attr">initialState</span>: any));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>updateReducer 中，用 pending 来指向本次要触发的 update，然后将本次 hook 要执行的 update 和 current fiber 中之前未完成的 update 全部链接到 baseQueue，也就是代表全局的 update。<br>在 render 阶段，会遍历 update 来计算 state 的值，若某个 update 的优先级低于当前 render 执行的任务的优先级，则跳过此次 update 及未遍历完的 update 的执行，先执行其他的 update。然后再下一次 render 时从跳过的 update 开始继续执行。<br>update 阶段 dispatch 会生成一个新的 update 链接到 hooks 中，并根据之前的 state 和本次 action 去计算新的 state。<br>updateReducer 的源码如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateReducer&lt;S, I, A&gt;(</span><br><span class="line">  <span class="attr">reducer</span>: <span class="function">(<span class="params">S, A</span>) =&gt;</span> S,</span><br><span class="line">  <span class="attr">initialArg</span>: I,</span><br><span class="line">  init?: <span class="function">(<span class="params">I</span>) =&gt;</span> S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;A&gt;] &#123;</span><br><span class="line">  <span class="comment">// 取出 hook 节点</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> queue = hook.<span class="property">queue</span>;</span><br><span class="line">  <span class="title function_">invariant</span>(</span><br><span class="line">    queue !== <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;Should have a queue. This is likely a bug in React. Please file an issue.&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  queue.<span class="property">lastRenderedReducer</span> = reducer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">Hook</span> = (<span class="attr">currentHook</span>: any);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上次未完成的 update</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = current.<span class="property">baseQueue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取本次待执行的 update</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.<span class="property">pending</span>;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果 baseQueue 和 pendingQueue 都存在，将 pendingQueue 链接到 baseQueue 尾部</span></span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.<span class="property">next</span>;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.<span class="property">next</span>;</span><br><span class="line">      baseQueue.<span class="property">next</span> = pendingFirst;</span><br><span class="line">      pendingQueue.<span class="property">next</span> = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// react 的异步模型，可能发生一个更高优先级任务打断当前任务的执行</span></span><br><span class="line">    <span class="comment">// 所以要将 baseQueue 也赋值给 current fiber</span></span><br><span class="line">    current.<span class="property">baseQueue</span> = baseQueue = pendingQueue;</span><br><span class="line">    queue.<span class="property">pending</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> newState = current.<span class="property">baseState</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueLast = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line">    <span class="comment">// 遍历 hooks 链表，计算 state</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> updateLane = update.<span class="property">lane</span>;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isSubsetOfLanes</span>(renderLanes, updateLane)) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的 update 优先级低于 render 优先级，下次 render 时再执行本次的 update</span></span><br><span class="line">        <span class="keyword">const</span> <span class="attr">clone</span>: <span class="title class_">Update</span>&lt;S, A&gt; = &#123;</span><br><span class="line">          <span class="attr">lane</span>: updateLane,</span><br><span class="line">          <span class="attr">action</span>: update.<span class="property">action</span>,</span><br><span class="line">          <span class="attr">eagerReducer</span>: update.<span class="property">eagerReducer</span>,</span><br><span class="line">          <span class="attr">eagerState</span>: update.<span class="property">eagerState</span>,</span><br><span class="line">          <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 把这个 update 添加到 newBaseQueue 中下次 render 执行</span></span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">          newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.<span class="property">next</span> = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 queue 的优先级</span></span><br><span class="line">        currentlyRenderingFiber.<span class="property">lanes</span> = <span class="title function_">mergeLanes</span>(</span><br><span class="line">          currentlyRenderingFiber.<span class="property">lanes</span>,</span><br><span class="line">          updateLane</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 标记本次 update 跳过了</span></span><br><span class="line">        <span class="title function_">markSkippedUpdateLanes</span>(updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// newBaseQueueLast 不为 null，说明此前有跳过的 update</span></span><br><span class="line">          <span class="comment">// update 之间可能存在依赖，将后续 update 都连接到 newBaseQueue 中留到下次 render 执行</span></span><br><span class="line">          <span class="keyword">const</span> <span class="attr">clone</span>: <span class="title class_">Update</span>&lt;S, A&gt; = &#123;</span><br><span class="line">            <span class="attr">lane</span>: <span class="title class_">NoLane</span>,</span><br><span class="line">            <span class="attr">action</span>: update.<span class="property">action</span>,</span><br><span class="line">            <span class="attr">eagerReducer</span>: update.<span class="property">eagerReducer</span>,</span><br><span class="line">            <span class="attr">eagerState</span>: update.<span class="property">eagerState</span>,</span><br><span class="line">            <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">          &#125;;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.<span class="property">next</span> = clone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行本次的 update，计算新的 state</span></span><br><span class="line">        <span class="keyword">if</span> (update.<span class="property">eagerReducer</span> === reducer) &#123;</span><br><span class="line">          <span class="comment">// update.eagerReducer 和 reducer 相等，说明 reducer 已经计算过，直接取结算过的 state</span></span><br><span class="line">          newState = ((update.<span class="property">eagerState</span>: any): S);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 根据 state 和 action 计算新的 state</span></span><br><span class="line">          <span class="keyword">const</span> action = update.<span class="property">action</span>;</span><br><span class="line">          newState = <span class="title function_">reducer</span>(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      update = update.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// newBaseQueueLast 为 null，说明所有 update 处理完了，更新 baseState</span></span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 未处理完留到下次执行</span></span><br><span class="line">      newBaseQueueLast.<span class="property">next</span> = (<span class="attr">newBaseQueueFirst</span>: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的 state 和之前的 state 不相等，标记需要更新</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is</span>(newState, hook.<span class="property">memoizedState</span>)) &#123;</span><br><span class="line">      <span class="title function_">markWorkInProgressReceivedUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的 state 和 baseQueue 保存到 hook 中</span></span><br><span class="line">    hook.<span class="property">memoizedState</span> = newState;</span><br><span class="line">    hook.<span class="property">baseState</span> = newBaseState;</span><br><span class="line">    hook.<span class="property">baseQueue</span> = newBaseQueueLast;</span><br><span class="line"></span><br><span class="line">    queue.<span class="property">lastRenderedState</span> = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;A&gt; = (queue.<span class="property">dispatch</span>: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结-1"   >
          <a href="#总结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3>
      <p>总结一下 useState 和 useReducer 的执行过程如下图：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/f6dd618d1c1642a6bbec25ed82c0a408_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>

        <h2 id="useEffect"   >
          <a href="#useEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2>
      <p>同样，我们也分为 mount 和 update 两种情况来看 useEffect。</p>

        <h3 id="用法-1"   >
          <a href="#用法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3>
      <p>useEffect 的使用大家应该都了解，在这里就不赘述了，我们本次的用例如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;unmount&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></div></figure>


        <h3 id="mountEffect"   >
          <a href="#mountEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#mountEffect" class="headerlink" title="mountEffect"></a>mountEffect</h3>
      <p>mount 阶段 useEffect 实际上是调用了 mountEffect 方法，进一步通过传递参数调用了 mountEffectImpl 这个函数：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  create: () =&gt; (() =&gt; <span class="keyword">void</span>) | <span class="keyword">void</span>, <span class="comment">// 执行的回调函数</span></span></span><br><span class="line"><span class="params">  deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span> <span class="comment">// 依赖项</span></span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountEffectImpl</span>(</span><br><span class="line">    <span class="title class_">UpdateEffect</span> | <span class="title class_">PassiveEffect</span>,</span><br><span class="line">    <span class="title class_">HookPassive</span>,</span><br><span class="line">    create,</span><br><span class="line">    deps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>和 mountState 中所做的事情类似，mountEffectImpl 中首先通过 mountWorkInProgressHook 创建了 hook 链接到 hooks 链表中，前面提到过 useEffect 的 hook 是一个 Effect 类型的对象。然后通过 pushEffect 方法创建一个 effect 添加到 hook 的 memoizedState 属性：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 创建 hook 并链接到 hooks 链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  currentlyRenderingFiber.<span class="property">flags</span> |= fiberFlags;</span><br><span class="line">  <span class="comment">// 创建一个 effect 对象并添加到 hook 的 memoizedState 中</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(</span><br><span class="line">    <span class="title class_">HookHasEffect</span> | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="pushEffect"   >
          <a href="#pushEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#pushEffect" class="headerlink" title="pushEffect"></a>pushEffect</h3>
      <p><code>pushEffect</code>函数中主要做了两件事，创建 effect 对象，然后将其添加到 fiber 的 updateQueue 链表上：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建 effect</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">effect</span>: <span class="title class_">Effect</span> = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">componentUpdateQueue</span>: <span class="literal">null</span> | <span class="title class_">FunctionComponentUpdateQueue</span> =</span><br><span class="line">    (currentlyRenderingFiber.<span class="property">updateQueue</span>: any);</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// componentUpdateQueue 为 null，将 effect 添加到 componentUpdateQueue 头结点</span></span><br><span class="line">    componentUpdateQueue = <span class="title function_">createFunctionComponentUpdateQueue</span>();</span><br><span class="line">    currentlyRenderingFiber.<span class="property">updateQueue</span> = (<span class="attr">componentUpdateQueue</span>: any);</span><br><span class="line">    componentUpdateQueue.<span class="property">lastEffect</span> = effect.<span class="property">next</span> = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 链接到当前 fiber 节点的 updateQueue 的 lastEffect 中</span></span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.<span class="property">lastEffect</span>;</span><br><span class="line">    <span class="comment">// 构成循环链表结构</span></span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.<span class="property">lastEffect</span> = effect.<span class="property">next</span> = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.<span class="property">next</span>;</span><br><span class="line">      lastEffect.<span class="property">next</span> = effect;</span><br><span class="line">      effect.<span class="property">next</span> = firstEffect;</span><br><span class="line">      componentUpdateQueue.<span class="property">lastEffect</span> = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="updateEffect"   >
          <a href="#updateEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#updateEffect" class="headerlink" title="updateEffect"></a>updateEffect</h3>
      <p>update 阶段，<code>useEffect</code>实际上是调用了<code>updateEffect</code>函数，同样是进一步调用了<code>updateEffectImpl</code>函数：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  create: () =&gt; (() =&gt; <span class="keyword">void</span>) | <span class="keyword">void</span>,</span></span><br><span class="line"><span class="params">  deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">updateEffectImpl</span>(</span><br><span class="line">    <span class="title class_">UpdateEffect</span> | <span class="title class_">PassiveEffect</span>,</span><br><span class="line">    <span class="title class_">HookPassive</span>,</span><br><span class="line">    create,</span><br><span class="line">    deps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>所以我们接着往下看<code>updateEffectImpl</code>函数做了什么，它从 <code>updateWorkInProgressHook</code>取出对应的 hook，然后看上一轮 render 中是否有 hook 存在，若存在且上一轮 render 和本轮的依赖项没发生变化，说明副作用不需要执行，创建一个 effect 对象添加到 updateQueue 链表后直接返回；若两次的依赖项发生了变化，向 fiber 添加 flags 副作用标签，待 commit 时更新，然后再创建一个 effect 对象添加到 updateQueue 链表：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 从 hooks 链表中取出对应 hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若上一轮 render 对应 hook 存在</span></span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.<span class="property">memoizedState</span>;</span><br><span class="line">    destroy = prevEffect.<span class="property">destroy</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.<span class="property">deps</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="comment">// 若上一轮和本次的依赖项未发生变化，说明没有副作用</span></span><br><span class="line">        <span class="comment">// 创建一个 effect 对象添加到 updateQueue 链表中，然后返回</span></span><br><span class="line">        <span class="title function_">pushEffect</span>(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行到这里说明上一轮和本轮依赖项发生变化</span></span><br><span class="line">  <span class="comment">// 向 fiber 添加 flags 副作用标签，待 commit 时更新</span></span><br><span class="line">  currentlyRenderingFiber.<span class="property">flags</span> |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 effect 对象添加到 updateQueue 链表中</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(</span><br><span class="line">    <span class="title class_">HookHasEffect</span> | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结-2"   >
          <a href="#总结-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3>
      <p>总结一下 useEffect 的大体流程如下：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/22a64ff368474815b9cbc58fefd755a8_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>

        <h2 id="useRef"   >
          <a href="#useRef" class="heading-link"><i class="fas fa-link"></i></a><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2>
      <p><code>useRef</code>的代码十分的简单了，我们直接将 mount 阶段和 update 阶段的放到一起来看：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountRef&lt;T&gt;(<span class="attr">initialValue</span>: T): &#123;| <span class="attr">current</span>: T |&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> ref = &#123; <span class="attr">current</span>: initialValue &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateRef&lt;T&gt;(<span class="attr">initialValue</span>: T): &#123;| <span class="attr">current</span>: T |&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">return</span> hook.<span class="property">memoizedState</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>mount 阶段，调用<code>mountRef</code>函数，通过 <code>mountWorkInProgressHook</code>创建一个 hook 并添加到 hooks 链表上，<code>hook.memoizedState</code>上存储的是{current: initialValue}这个 ref 对象。<br>update 阶段，调用<code>updateRef</code>函数，通过<code>updateWorkInProgressHook</code>方法直接取出<code>hook.memoizedState</code>。<br>可以看到<code>hook.memoizedState</code>指向的是一个对象的引用，这就解释了我们可以直接通过 <code>ref.current</code>去改变和获取最新的值，不必进行任何依赖注入。</p>

        <h2 id="useCallback-amp-useMemo"   >
          <a href="#useCallback-amp-useMemo" class="heading-link"><i class="fas fa-link"></i></a><a href="#useCallback-amp-useMemo" class="headerlink" title="useCallback &amp; useMemo"></a>useCallback &amp; useMemo</h2>
      <p><code>useCallback</code>和<code>useMemo</code>也是一样，源码结构上十分相似，所以也放在一起来讲。</p>

        <h3 id="用法-2"   >
          <a href="#用法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3>
      <p>基础用法如下：<br>&#x2F;&#x2F; 第一个参数是 “创建” 函数，第二个参数是依赖项数组<br>&#x2F;&#x2F; “创建” 函数会根据依赖项数组返回一个值，并且仅会在某个依赖项改变时才重新计算</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">add</span>(a, b), [a, b]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是回调函数，第二个参数是依赖项数组</span></span><br><span class="line"><span class="comment">// 依赖项改变时回调函数会进行更新</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">add</span>(a, b);</span><br><span class="line">&#125;, [a, b]);</span><br></pre></td></tr></table></div></figure>


        <h3 id="mount-阶段"   >
          <a href="#mount-阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#mount-阶段" class="headerlink" title="mount 阶段"></a>mount 阶段</h3>
      <p>mount 时，分别调用了<code>mountCallback</code>和<code>mountMemo</code>函数，两者都通过 <code>mountWorkInProgressHook</code>方法创建 hook 添加到了 hooks 链表中。不同的是，<code>mountCallback</code>的 memoizedState 是[callback, nextDeps]，并且返回的是其第一个参数；<code>mountMemo</code>的 memoizedState 是 [nextValue, nextDeps]，返回的也是 nextValue 也就是其第一个参数的执行结果。<br>所以看上去<code>useMemo</code>就是比<code>useCallback</code>多了一步第一个参数的执行过程。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="comment">// 创建 hook 添加到链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountMemo&lt;T&gt;(</span><br><span class="line">  <span class="attr">nextCreate</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span><br><span class="line">): T &#123;</span><br><span class="line">  <span class="comment">// 创建 hook 添加到链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>();</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="update-阶段"   >
          <a href="#update-阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#update-阶段" class="headerlink" title="update 阶段"></a>update 阶段</h3>
      <p>update 时，分别调用了<code>updateCallback</code>和<code>updateMemo</code> 函数，它们都通过 <code>updateWorkInProgressHook</code>取出对应的 hook，若依赖项未发生改变，则取上一轮的 callback 或者 value 返回；若依赖项发生改变，则重新赋值 hook.memoizedState 并返回新的 callback 或新计算的 value：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="comment">// 获取对应 hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">prevDeps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 依赖项未发生改变，取上一轮的 callback 并返回</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖项改变了，重新赋值 hook.memoizedState，返回新的 callback</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateMemo&lt;T&gt;(</span><br><span class="line">  <span class="attr">nextCreate</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span><br><span class="line">): T &#123;</span><br><span class="line">  <span class="comment">// 获取对应 hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">prevDeps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 依赖项未发生改变，取上一轮的值并返回</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖项改变了，计算新的值，重新赋值 hook.memoizedState 并返回新的值</span></span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>();</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="结语"   >
          <a href="#结语" class="heading-link"><i class="fas fa-link"></i></a><a href="#结语" class="headerlink" title="结语"></a>结语</h1>
      <p>本章讲解了 react hooks 的源码，理解了 hooks 的设计思想和工作过程。其他 hook 平时用的比较少，就不在这里展开讲了，但通过上面几个 hook 的源码讲解，其他 hook 看源码你应该也能看得懂。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://niki571.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">源码分析</a></span><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://niki571.github.io/tags/React/">React</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/%E5%86%99%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84webpack-plugin/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">写一个自己的webpack plugin</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/%E4%B8%BA%E4%BB%80%E4%B9%88React%E7%9A%84Diff%E7%AE%97%E6%B3%95%E4%B8%8D%E9%87%87%E7%94%A8Vue%E7%9A%84%E5%8F%8C%E7%AB%AF%E5%AF%B9%E6%AF%94%E7%AE%97%E6%B3%95/"><span class="paginator-prev__text">为什么React的Diff算法不采用Vue的双端对比算法</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#hooks-%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">
          hooks 相关数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Hook"><span class="toc-number">1.1.</span> <span class="toc-text">
          Hook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Update-amp-UpdateQueue"><span class="toc-number">1.2.</span> <span class="toc-text">
          Update &amp; UpdateQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Effect"><span class="toc-number">1.3.</span> <span class="toc-text">
          Effect</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">
          执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">
          函数组件更新过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#renderWithHooks"><span class="toc-number">2.2.</span> <span class="toc-text">
          renderWithHooks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E9%98%B6%E6%AE%B5%E6%9B%B4%E6%96%B0-Hook"><span class="toc-number">2.3.</span> <span class="toc-text">
          不同阶段更新 Hook</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mountWorkInProgressHook"><span class="toc-number">2.3.1.</span> <span class="toc-text">
          mountWorkInProgressHook</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updateWorkInProgressHook"><span class="toc-number">2.3.2.</span> <span class="toc-text">
          updateWorkInProgressHook</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">
          总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#hooks-%E6%BA%90%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">
          hooks 源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#useState-amp-useReducer"><span class="toc-number">4.1.</span> <span class="toc-text">
          useState &amp; useReducer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95"><span class="toc-number">4.1.1.</span> <span class="toc-text">
          用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mountState-amp-mountReducer"><span class="toc-number">4.1.2.</span> <span class="toc-text">
          mountState &amp; mountReducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dispatchAction"><span class="toc-number">4.1.3.</span> <span class="toc-text">
          dispatchAction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updateReducer"><span class="toc-number">4.1.4.</span> <span class="toc-text">
          updateReducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.1.5.</span> <span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useEffect"><span class="toc-number">4.2.</span> <span class="toc-text">
          useEffect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">
          用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mountEffect"><span class="toc-number">4.2.2.</span> <span class="toc-text">
          mountEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pushEffect"><span class="toc-number">4.2.3.</span> <span class="toc-text">
          pushEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updateEffect"><span class="toc-number">4.2.4.</span> <span class="toc-text">
          updateEffect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.2.5.</span> <span class="toc-text">
          总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useRef"><span class="toc-number">4.3.</span> <span class="toc-text">
          useRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useCallback-amp-useMemo"><span class="toc-number">4.4.</span> <span class="toc-text">
          useCallback &amp; useMemo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%B3%95-2"><span class="toc-number">4.4.1.</span> <span class="toc-text">
          用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mount-%E9%98%B6%E6%AE%B5"><span class="toc-number">4.4.2.</span> <span class="toc-text">
          mount 阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#update-%E9%98%B6%E6%AE%B5"><span class="toc-number">4.4.3.</span> <span class="toc-text">
          update 阶段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">5.</span> <span class="toc-text">
          结语</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/avatar.JPEG" alt="avatar"></div><p class="sidebar-ov-author__text">Keep Studying, Keep Creating</p></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>WuQianying</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-banner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script></body></html>