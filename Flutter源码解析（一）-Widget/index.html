<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="Everything’s a widget.  在开发 Flutter 应用过程中，接触最多的无疑就是Widget，是『描述』 Flutter UI 的基本单元，通过Widget可以做到：  描述 UI 的层级结构 (通过Widget嵌套)； 定制 UI 的具体样式 (如：font、color等)； 指导 UI 的布局过程 (如：padding、center等)； …  Google 在设计Wi">
<meta property="og:type" content="article">
<meta property="og:title" content="Flutter源码解析（一）Widget">
<meta property="og:url" content="https://niki571.github.io/Flutter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-Widget/index.html">
<meta property="og:site_name" content="吴倩颖的网络日志">
<meta property="og:description" content="Everything’s a widget.  在开发 Flutter 应用过程中，接触最多的无疑就是Widget，是『描述』 Flutter UI 的基本单元，通过Widget可以做到：  描述 UI 的层级结构 (通过Widget嵌套)； 定制 UI 的具体样式 (如：font、color等)； 指导 UI 的布局过程 (如：padding、center等)； …  Google 在设计Wi">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/f38834b248be4280b5bf4671b3a97cef_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/968873ae5e014a1aacf92b5b1e361707_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/a608f3e3ef40475a9f5aa44c462b5aaa_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/063fd9df872444758d43454ca2257808_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/e3e9b2c48047448181a6254ce4f7bc54_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/fddeb1525cce44ef96fd32c98430e89f_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/d1f19d4128f8405f80c3a84b908cea3c_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/0041fcdd6a7344e29edcc13c4817c84f_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/1c5760ab4e884dd3827d71628a7078af_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/2a70ad26731c4528a59c758aa1656061_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/9f692b89d69043d69b7d61799147bf07_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/bb0bb8fbef2941d0b8348a04d37aef72_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/e21fa41da458487c82a4b653d0fb45cd_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/89aeac1cc6de483f90fcbf74687daf26_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/095c50c0cc914c0689f381881715a2d4_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp">
<meta property="article:published_time" content="2022-05-13T02:24:05.000Z">
<meta property="article:modified_time" content="2023-02-21T06:53:34.908Z">
<meta property="article:author" content="WuQianying">
<meta property="article:tag" content="原理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/niki571/MyImageHost/main/f38834b248be4280b5bf4671b3a97cef_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"><title>Flutter源码解析（一）Widget | 吴倩颖的网络日志</title><link ref="canonical" href="https://niki571.github.io/Flutter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-Widget/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":true},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":true},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copiar","copySuccess":"Éxito en copia","copyError":"Error en copia"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-solid fa-pen-nib"></i></span><span class="header-nav-menu-item__text">文章</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-solid fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/"><span class="header-nav-submenu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-submenu-item__text">分类</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-solid fa-tag"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/me/"><span class="header-nav-menu-item__icon"><i class="fas fa-solid fa-star"></i></span><span class="header-nav-menu-item__text">我</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">吴倩颖的网络日志</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Flutter源码解析（一）Widget</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Creado</span><span class="post-meta-item__value">2022-05-13</span></span></div></header><div class="post-body"><blockquote>
<p>Everything’s a widget.</p>
</blockquote>
<p>在开发 Flutter 应用过程中，接触最多的无疑就是<code>Widget</code>，是『描述』 Flutter UI 的基本单元，通过<code>Widget</code>可以做到：</p>
<ul>
<li>描述 UI 的层级结构 (通过<code>Widget</code>嵌套)；</li>
<li>定制 UI 的具体样式 (如：<code>font</code>、<code>color</code>等)；</li>
<li>指导 UI 的布局过程 (如：<code>padding</code>、<code>center</code>等)；</li>
<li>…</li>
</ul>
<p>Google 在设计<code>Widget</code>时，还赋予它一些鲜明的特点：</p>
<span id="more"></span>

<p>声明式 UI —— 相对于传统 Native 开发中的命令式 UI，声明式 UI 有不少优势，如：开发效率显著提升、UI 可维护性明显加强等；</p>
<p>不可变性 —— Flutter 中所有<code>Widget</code>都是不可变的(immutable)，即其内部成员都是不可变的(final)，对于变化的部分需要通过「Stateful Widget-State」的方式实现；</p>
<p>组合大于继承 ——<code>Widget</code>设计遵循组合大于继承这一优秀的设计理念，通过将多个功能相对单一的 Widget 组合起来便可得到功能相对复杂的 Widget。</p>
<p>在<code>Widget</code>类定义处有这样一段注释：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/f38834b248be4280b5bf4671b3a97cef_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>这段注释阐明了<code>Widget</code>的本质：<strong>用于配置<code>Element</code>的，<code>Widget</code>本质上是 UI 的配置信息 (附带部分业务逻辑)。</strong></p>
<blockquote>
<p>我们通常会将通过<code>Widget</code>描述的 UI 层级结构称之为「Widget Tree」，但与「Element Tree」、「RenderObject Tree」以及「Layer Tree」相比，实质上并不存在「Widget Tree」。为了描述方便，将 Widget 组合描述的 UI 层级结构称之为「Widget Tree」，也未尝不可。</p>
</blockquote>

        <h1 id="分类"   >
          <a href="#分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类" class="headerlink" title="分类"></a>分类</h1>
      <p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/968873ae5e014a1aacf92b5b1e361707_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>如上图所示，按照功能划分<code>Widget</code>大致可以分为 3 类：</p>
<ul>
<li><p>「Component Widget」 —— 组合类<code>Widget</code>，这类<code>Widget</code>都直接或间接继承于<code>StatelessWidget</code>或<code>StatefulWidget</code>，上一小节提到过在<code>Widget</code>设计上遵循组合大于继承的原则，通过组合功能相对单一的 Widget 可以得到功能更为复杂的 Widget。平常的业务开发主要是在开发这一类型的 Widget；</p>
</li>
<li><p>「Proxy Widget」 —— 代理类<code>Widget</code>，正如其名，「Proxy Widget」本身并不涉及 Widget 内部逻辑，只是为「Child Widget」提供一些附加的中间功能。典型的如：InheritedWidget 用于在「Descendant Widgets」间传递共享信息、ParentDataWidget 用于配置「Descendant Renderer Widget」的布局信息；</p>
</li>
<li><p>「Renderer Widget」 —— 渲染类 Widget，是最核心的 Widget 类型，会直接参与后面的「Layout」、「Paint」流程，无论是「Component Widget」还是「Proxy Widget」最终都会映射到「Renderer Widget」上，否则将无法被绘制到屏幕上。这 3 类 Widget 中，只有「Renderer Widget」有与之一一对应的「Render Object」。</p>
</li>
</ul>

        <h1 id="核心方法源码分析"   >
          <a href="#核心方法源码分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心方法源码分析" class="headerlink" title="核心方法源码分析"></a>核心方法源码分析</h1>
      <p>下面，我们重点介绍各类型 Widget 的核心方法，以便更好地理解 Widget 是如何参与整个 UI 的构建过程。</p>

        <h2 id="Widget"   >
          <a href="#Widget" class="heading-link"><i class="fas fa-link"></i></a><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2>
      <p><code>Widget</code>，所有 Widget 的基类。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/a608f3e3ef40475a9f5aa44c462b5aaa_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>如上图所示，在<code>Widget</code>基类中有 3 个重要的方法 (属性)：</p>
<ul>
<li>Key key —— 在同一父节点下，用作兄弟节点间的唯一标识，主要用于控制当 Widget 更新时，对应的 Element 如何处理 (是更新还是新建)。若某 Widget 是其「Parent Widget」唯一的子节点时，一般不用设置 key；</li>
</ul>
<blockquote>
<p>GlobalKey 是一类较特殊的<code>key</code>，在介绍<code>Element</code>时会附带介绍。</p>
</blockquote>
<ul>
<li><p>Element createElement() —— 每个 Widget 都有一个与之对应的 Element，由该方法负责创建，createElement 可以理解为设计模式中的工厂方法，具体的 Element 类型由对应的 Widget 子类负责创建；</p>
</li>
<li><p>static bool canUpdate(Widget oldWidget, Widget newWidget) —— 是否可以用 new widget 修改前一帧用 old widget 生成的 Element，而不是创建新的 Element，Widget 类的默认实现为：2 个 Widget 的 runtimeType 与 key 都相等时，返回 true，即可以直接更新 (key 为 null 时，认为相等)。</p>
</li>
</ul>
<blockquote>
<p>上述更新流程，同样在介绍 Element 时会重点分析。</p>
</blockquote>

        <h2 id="StatelessWidget"   >
          <a href="#StatelessWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h2>
      <p>无状态-组合型 Widget，由其<code>build</code>方法描述组合 UI 的层级结构。在其生命周期内状态不可变。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/063fd9df872444758d43454ca2257808_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/e3e9b2c48047448181a6254ce4f7bc54_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<blockquote>
<p>ps: 对于有父子关系的类，在子类中只会介绍新增或有变化的方法</p>
</blockquote>
<ul>
<li><p>StatelessElement createElement() ——「Stateless Widget」对应的 Element 为 StatelessElement，一般情况下 StatelessWidget 子类不必重写该方法，即子类对应的 Element 也是 StatelessElement；</p>
</li>
<li><p>Widget build(BuildContext context) —— 算是 Flutter 体系中的核心方法之一，以『声明式 UI』的形式描述了该组合式 Widget 的 UI 层级结构及样式信息，也是开发 Flutter 应用的主要工作『场所』。该方法在 3 种情况下被调用：</p>
<ul>
<li>Widget 第一次被加入到 Widget Tree 中 (更准确地说是其对应的 Element 被加入到 Element Tree 时，即 Element 被挂载『mount』时)；</li>
<li>「Parent Widget」修改了其配置信息；</li>
<li>该 Widget 依赖的「Inherited Widget」发生变化时。</li>
</ul>
</li>
</ul>
<p>当「Parent Widget」或 依赖的「Inherited Widget」频繁变化时，build 方法也会频繁被调用。因此，提升 build 方法的性能就显得十分重要，Flutter 官方给出了几点建议：</p>
<ul>
<li><p>减少不必要的中间节点，即减少 UI 的层级，如：对于「Single Child Widget」，没必要通过组合「Row」、「Column」、「Padding」、「SizedBox」等复杂的 Widget 达到某种布局的目标，或许通过简单的「Align」、「CustomSingleChildLayout」即可实现。又或者，为了实现某种复杂精细的 UI 效果，不一定要通过组合多个「Container」，再附加「Decoration」来实现，通过 「CustomPaint」自定义或许是更好的选择；</p>
</li>
<li><p>尽可能使用 const Widget，为 Widget 提供 const 构造方法；</p>
</li>
<li><p>必要时，可以将「Stateless Widget」重构成「Stateful Widget」，以便可以使用「Stateful Widget」中一些特定的优化手法，如：缓存「sub trees」的公共部分，并在改变树结构时使用 GlobalKey；</p>
</li>
<li><p>尽量减小 rebuilt 范围，如：某个 Widget 因使用了「Inherited Widget」，导致频繁 rebuilt，可以将真正依赖「Inherited Widget」的部分提取出来，封装成更小的独立 Widget，并尽量将该独立 Widget 推向树的叶子节点，以便减小 rebuilt 时受影响的范围。</p>
</li>
</ul>

        <h2 id="StatefulWidget"   >
          <a href="#StatefulWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2>
      <p>有状态-组合型 Widget，但要注意的是<code>StatefulWidget</code>本身还是不可变的，其可变状态存在于<code>State</code>中。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/fddeb1525cce44ef96fd32c98430e89f_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/d1f19d4128f8405f80c3a84b908cea3c_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<ul>
<li><p>StatefulElement createElement() ——「Stateful Widget」对应的 Element 为 StatefulElement，一般情况下 StatefulWidget 子类不用重写该方法，即子类对应的 Element 也是 StatefulElement；</p>
</li>
<li><p>State createState() —— 创建对应的 State，该方法在 StatefulElement 的构造方法中被调用。可以简单地理解为当「Stateful Widget」被添加到 Widget Tree 时会调用该方法。</p>
</li>
</ul>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码已精简处理(本文中其他代码会做同样的简化处理)</span></span><br><span class="line">StatefulElement(StatefulWidget widget)</span><br><span class="line">  : _state = widget.createState(), <span class="keyword">super</span>(widget) &#123;</span><br><span class="line">  _state._element = <span class="keyword">this</span>;</span><br><span class="line">  _state._widget = widget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>实际上是「Stateful Widget」对应的「Stateful Element」被添加到 Element Tree 时，伴随「Stateful Element」的初始化，createState 方法被调用。<br>从后文可知一个 Widget 实例可以对应多个 Element 实例 (也就是同一份配置信息 (Widget) 可以在 Element Tree 上不同位置配置多个 Element 节点)，因此，createState 方法在「Stateful Widget」生命周期内可能会被调用多次。</p>
<p>另外，需要注意的是配有 GlobalKey 的 Widget 对应的 Element 在整个 Element Tree 中只有一个实例。</p>

        <h2 id="State"   >
          <a href="#State" class="heading-link"><i class="fas fa-link"></i></a><a href="#State" class="headerlink" title="State"></a>State</h2>
      <blockquote>
<p>The logic and internal state for a 「Stateful Widget」.</p>
</blockquote>
<p>State 用于处理「Stateful Widget」的业务逻辑以及可变状态。<br>由于其内部状态是可变的，故 State 有较复杂的生命周期：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/0041fcdd6a7344e29edcc13c4817c84f_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>如上图，State 的生命周期大致可以分为 8 个阶段：</p>
<ol>
<li>在对应的「Stateful Element」被挂载 (mount) 到树上时，通过 StatefulElement.constructor –&gt; StatefulWidget.createState 创建 State 实例；</li>
</ol>
<blockquote>
<p>从 StatefulElement.constructor 中的_state._element &#x3D; this;可知，State._emelent 指向了对应的 Element 实例，而我们熟知的 State.context 引用的就是这个_element：BuildContext get context &#x3D;&gt; _element;。State 实例与 Element 实例间的绑定关系一经确定，在整个生命周期内不会再变了 (Element 对应的 Widget 可能会变，但对应的 State 永远不会变)，期间，Element 可以在树上移动，但上述关系不会变 (即「Stateful Element」是带着状态移动的)。</p>
</blockquote>
<ol start="2">
<li><p>StatefulElement 在挂载过程中接着会调用 State.initState，子类可以重写该方法执行相关的初始化操作 (此时可以引用 context、widget 属性)；</p>
</li>
<li><p>同样在挂载过程中会调用 State.didChangeDependencies，该方法在 State 依赖的对象 (如：「Inherited Widget」) 状态发生变化时也会被调用，子类很少需要重写该方法，除非有非常耗时不宜在 build 中进行的操作，因为在依赖有变化时 build 方法也会被调用；</p>
</li>
<li><p>此时，State 初始化已完成，其 build 方法此后可能会被多次调用，在状态变化时 State 可通过 setState 方法来触发其子树的重建；</p>
</li>
<li><p>此时，「element tree」、「renderobject tree」、「layer tree」已构建完成，完整的 UI 应该已呈现出来。此后因为变化，「element tree」中「parent element」可能会对树上该位置的节点用新配置 (Widget) 进行重建，当新老配置 (oldWidget、newWidget)具有相同的「runtimeType」&amp;&amp;「key」时，framework 会用 newWidget 替换 oldWidget，并触发一系列的更新操作 (在子树上递归进行)。同时，State.didUpdateWidget 方法被调用，子类重写该方法去响应 Widget 的变化；</p>
</li>
</ol>
<blockquote>
<p>上述 3 棵树以及更新流程在后续文章中会有详细介绍</p>
</blockquote>
<ol start="6">
<li>在 UI 更新过程中，任何节点都有被移除的可能，State 也会随之移除，(如上一步中「runtimeType」||「key」不相等时)。此时会调用 State.deactivate 方法，由于被移除的节点可能会被重新插入树中某个新的位置上，故子类重写该方法以清理与节点位置相关的信息 (如：该 State 对其他 element 的引用)、同时，不应在该方法中做资源清理；</li>
</ol>
<blockquote>
<p>重新插入操作必须在当前帧动画结束之前</p>
</blockquote>
<ol start="7">
<li><p>当节点被重新插入树中时，State.build 方法被再次调用；</p>
</li>
<li><p>对于在当前帧动画结束时尚未被重新插入的节点，State.dispose 方法被执行，State 生命周期随之结束，此后再调用 State.setState 方法将报错。子类重写该方法以释放任何占用的资源。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/1c5760ab4e884dd3827d71628a7078af_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>至此，State 中的核心方法基本都已在上述过程中介绍了，下面重点看一下 <code>setState</code>方法：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(fn != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.defunct) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.created &amp;&amp; !mounted) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">dynamic</span> result = fn() <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">is</span> Future) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line"></span><br><span class="line">  _element.markNeedsBuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上述源码可以看到，关于<code>setState</code>方法有几点值得关注：</p>
<ul>
<li><p>在<code>State.dispose</code>后不能调用<code>setState</code>；</p>
</li>
<li><p>在<code>State</code>的构造方法中不能调用<code>setState</code>；</p>
</li>
<li><p><code>setState</code>方法的回调函数 (<code>fn</code>) 不能是异步的 (返回值为<code>Future</code>)，原因很简单，因为从流程设计上 framework 需要根据回调函数产生的新状态去刷新 UI；</p>
</li>
<li><p>通过<code>setState</code>方法之所以能更新 UI，是在其内部调用<code>_element.markNeedsBuild()</code>实现的 (具体过程在介绍 Element 时再详细分析)。</p>
</li>
</ul>
<p>关于 State 最后再强调 2 点：</p>
<ol>
<li>若<code>State.build</code>方法依赖了自身状态会变化的对象，如：<code>ChangeNotifier</code>、<code>Stream</code>或其他可以被订阅的对象，需要确保在 <code>initState</code>、<code>didUpdateWidget</code>、<code>dispose</code>等 3 方法间有正确的订阅 (subscribe) 与取消订阅 (unsubscribe) 的操作：</li>
</ol>
<ul>
<li>在<code>initState</code>中执行 subscribe；</li>
<li>如果关联的「Stateful Widget」与订阅有关，在<code>didUpdateWidget</code>中先取消旧的订阅，再执行新的订阅；</li>
<li>在<code>dispose</code>中执行 unsubscribe。</li>
</ul>
<ol start="2">
<li>在<code>State.initState</code>方法中不能调用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>，但<code>State.didChangeDependencies</code>会随之执行，在该方法中可以调用。</li>
</ol>

        <h2 id="ParentDataWidget"   >
          <a href="#ParentDataWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#ParentDataWidget" class="headerlink" title="ParentDataWidget"></a>ParentDataWidget</h2>
      <p><code>ParentDataWidget</code>以及下面要介绍的<code>InheritedElement</code>都继承自 <code>ProxyWidget</code>，由于<code>ProxyWidget</code>作为抽象基类本身没有任何功能，故下面直接介绍<code>ParentDataWidget</code>、<code>InheritedElement</code>。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/2a70ad26731c4528a59c758aa1656061_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p><code>ParentDataWidget</code>作为 Proxy 型 Widget，其功能主要是为其他 Widget 提供<code>ParentData</code>信息。虽然其 child widget 不一定是 RenderObejctWidget 类型，但其提供的<code>ParentData</code>信息最终都会落地到 RenderObejctWidget 类型子孙 Widget 上。</p>
<blockquote>
<p>ParentData 是『parent renderobject』在 layout『child renderobject』时使用的辅助定位信息，详细信息会在介绍 RenderObject 时介绍。</p>
</blockquote>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRenderObject(<span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_ancestorRenderObjectElement == <span class="keyword">null</span>);</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">  _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);</span><br><span class="line">  <span class="keyword">final</span> ParentDataElement&lt;RenderObjectWidget&gt; parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">  <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">  _updateParentData(parentDataElement.widget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ParentDataElement&lt;RenderObjectWidget&gt; _findAncestorParentDataElement() &#123;</span><br><span class="line">  <span class="built_in">Element</span> ancestor = _parent;</span><br><span class="line">  <span class="keyword">while</span> (ancestor != <span class="keyword">null</span> &amp;&amp; ancestor <span class="keyword">is</span>! RenderObjectElement) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ancestor <span class="keyword">is</span> ParentDataElement&lt;RenderObjectWidget&gt;)</span><br><span class="line">      <span class="keyword">return</span> ancestor;</span><br><span class="line">    ancestor = ancestor._parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _updateParentData(ParentDataWidget&lt;RenderObjectWidget&gt; parentData) &#123;</span><br><span class="line">  parentData.applyParentData(renderObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面这段代码来自<code>RenderObjectElement</code>，可以看到在其 <code>attachRenderObject</code>方法第 6 行从祖先节点找<code>ParentDataElement</code>，如果找到就用其 Widget(ParentDataWidget) 中的 parentData 信息去设置 Render Obejct。在查找过程中如查到<code>RenderObjectElement</code>(第 13 行)，说明当前 RenderObject 没有 Parent Data 信息。</p>
<p>最终会调用到<code>ParentDataWidget.applyParentData(RenderObject renderObject)</code>，子类需要重写该方法，以便设置对应<code>RenderObject.parentData</code>。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/9f692b89d69043d69b7d61799147bf07_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>来看个例子，通常配合 Stack 使用的 Positioned(继承自 ParentDataWidget)：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> applyParentData(RenderObject renderObject) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(renderObject.parentData <span class="keyword">is</span> StackParentData);</span><br><span class="line">  <span class="keyword">final</span> StackParentData parentData = renderObject.parentData;</span><br><span class="line">  <span class="built_in">bool</span> needsLayout = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parentData.left != left) &#123;</span><br><span class="line">    parentData.left = left;</span><br><span class="line">    needsLayout = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (parentData.width != width) &#123;</span><br><span class="line">    parentData.width = width;</span><br><span class="line">    needsLayout = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (needsLayout) &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNode targetParent = renderObject.parent;</span><br><span class="line">    <span class="keyword">if</span> (targetParent <span class="keyword">is</span> RenderObject)</span><br><span class="line">      targetParent.markNeedsLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以看到，<code>Positioned</code>在必要时将自己的属性赋值给了对应的<code>RenderObject.parentData</code>(此处是<code>StackParentData</code>)，并对「parent render object」调用<code>markNeedsLayout</code>(第 19 行)，以便重新 layout，毕竟修改了布局相关的信息。</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentDataWidget</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span>&gt; <span class="keyword">extends</span> <span class="title">ProxyWidget</span></span></span><br></pre></td></tr></table></div></figure>

<p>如上所示，<code>ParentDataWidget</code>在定义上使用了泛型<code>&lt;T extends RenderObjectWidget&gt;</code>，其背后的含义是：从当前<code>ParentDataWidget</code>节点向上追溯形成的祖先节点链(『parent widget chain』)上，在 2 个 <code>ParentDataWidget</code>类型的节点形成的链上至少要有一个『RenderObject Widget』类型的节点。因为一个『RenderObject Widget』不能接受来自 2 个及以上『ParentData Widget』的信息。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/bb0bb8fbef2941d0b8348a04d37aef72_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>

        <h2 id="InheritedWidget"   >
          <a href="#InheritedWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h2>
      <p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/e21fa41da458487c82a4b653d0fb45cd_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>InheritedWidget 用于在树上向下传递数据。</p>
<p>通过<code>BuildContext.dependOnInheritedWidgetOfExactType</code>可以获取最近的「Inherited Widget」，需要注意的是通过这种方式获取「Inherited Widget」时，当「Inherited Widget」状态有变化时，会导致该引用方 rebuild。</p>
<blockquote>
<p>具体原理在介绍 Element 时会详细分析。</p>
</blockquote>
<p>通常，为了使用方便会「Inherited Widget」会提供静态方法<code>of</code>，在该方法中调用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>。<code>of</code>方法可以直接返回「Inherited Widget」，也可以是具体的数据。</p>
<p>有时，「Inherited Widget」是作为另一个类的实现细节而存在的，其本身是私有的(外部不可见)，此时<code>of</code>方法就会放到对外公开的类上。最典型的例子就是<code>Theme</code>，其本身是<code>StatelessWidget</code>类型，但其内部创建了一个「Inherited Widget」：<code>_InheritedTheme</code>，<code>of</code>方法就定义在上<code>Theme</code>上：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThemeData of(BuildContext context, &#123; <span class="built_in">bool</span> shadowThemeOnly = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> _InheritedTheme inheritedTheme = context.dependOnInheritedWidgetOfExactType&lt;\_InheritedTheme&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ThemeData.localize(theme, theme.typography.geometryThemeFor(category));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>该<code>of</code>方法返回的是<code>ThemeData</code>类型的具体数据，并在其内部首先调用了 <code>BuildContext.dependOnInheritedWidgetOfExactType</code>。<br>我们经常使用的「Inherited Widget」莫过于<code>MediaQuery</code>，同样提供了<code>of</code>方法：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MediaQueryData of(BuildContext context, &#123; <span class="built_in">bool</span> nullOk = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> MediaQuery query = context.dependOnInheritedWidgetOfExactType&lt;MediaQuery&gt;();</span><br><span class="line">  <span class="keyword">if</span> (query != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> query.data;</span><br><span class="line">  <span class="keyword">if</span> (nullOk)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/89aeac1cc6de483f90fcbf74687daf26_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<ul>
<li><p>InheritedElement createElement() ——「Inherited Widget」对应的 Element 为 InheritedElement，一般情况下 InheritedElement 子类不用重写该方法；</p>
</li>
<li><p>bool updateShouldNotify(covariant InheritedWidget oldWidget) —— 在「Inherited Widget」rebuilt 时判断是否需要 rebuilt 那些依赖它的 Widget；</p>
</li>
</ul>
<p>如下是<code>MediaQuery.updateShouldNotify</code>的实现，在新老<code>Widget.data</code>不相等时才 rebuilt 那依赖的 Widget。</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> updateShouldNotify(MediaQuery oldWidget) =&gt; data != oldWidget.data;</span><br></pre></td></tr></table></div></figure>


        <h2 id="RenderObjectWidget"   >
          <a href="#RenderObjectWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#RenderObjectWidget" class="headerlink" title="RenderObjectWidget"></a>RenderObjectWidget</h2>
      <p>真正与渲染相关的 Widget，属于最核心的类型，一切其他类型的 Widget 要渲染到屏幕上，最终都要回归到该类型的 Widget 上。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/095c50c0cc914c0689f381881715a2d4_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<ul>
<li><p>RenderObjectElement createElement() ——「RenderObject Widget」对应的 Element 为 RenderObjectElement，由于 RenderObjectElement 也是抽象类，故子类需要重写该方法；</p>
</li>
<li><p>RenderObject createRenderObject(BuildContext context) —— 核心方法，创建 Render Widget 对应的 Render Object，同样子类需要重写该方法。该方法在对应的 Element 被挂载到树上时调用(Element.mount)，即在 Element 挂载过程中同步构建了「Render Tree」(详细过程后续文章会详细分析)；</p>
</li>
</ul>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">RenderFlex createRenderObject(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> RenderFlex(</span><br><span class="line">    direction: direction,</span><br><span class="line">    mainAxisAlignment: mainAxisAlignment,</span><br><span class="line">    mainAxisSize: mainAxisSize,</span><br><span class="line">    crossAxisAlignment: crossAxisAlignment,</span><br><span class="line">    textDirection: getEffectiveTextDirection(context),</span><br><span class="line">    verticalDirection: verticalDirection,</span><br><span class="line">    textBaseline: textBaseline,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面是<code>Flex.createRenderObject</code>的源码，真实感受一下 (还是代码更有感觉)。可以看到，用 Flex 的信息(配置)初始化了<code>RenderFlex</code>。</p>
<blockquote>
<p><code>Flex</code>是<code>Row</code>、<code>Column</code>的基类，<code>RenderFlex</code>继承自<code>RenderBox</code>，后者继续自<code>RenderObject</code>。</p>
</blockquote>
<ul>
<li><code>void updateRenderObject(BuildContext context, covariant RenderObject renderObject)</code>—— 核心方法，在 Widget 更新后，修改对应的 Render Object。该方法在首次 build 以及需要更新 Widget 时都会调用；</li>
</ul>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> updateRenderObject(BuildContext context, <span class="keyword">covariant</span> RenderFlex renderObject) &#123;</span><br><span class="line">  renderObject</span><br><span class="line">    ..direction = direction</span><br><span class="line">    ..mainAxisAlignment = mainAxisAlignment</span><br><span class="line">    ..mainAxisSize = mainAxisSize</span><br><span class="line">    ..crossAxisAlignment = crossAxisAlignment</span><br><span class="line">    ..textDirection = getEffectiveTextDirection(context)</span><br><span class="line">    ..verticalDirection = verticalDirection</span><br><span class="line">    ..textBaseline = textBaseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>Flex.updateRenderObject</code>的源码也很简单，与<code>Flex.createRenderObject</code>几乎一一对应，用当前<code>Flex</code>的信息修改<code>renderObject</code>。</p>
<ul>
<li><code>void didUnmountRenderObject(covariant RenderObject renderObject)</code>—— 对应的「Render Object」从「Render Tree」上移除时调用该方法。</li>
</ul>
<blockquote>
<p><code>RenderObjectWidget</code>的几个子类：<code>LeafRenderObjectWidget</code>、<code>SingleChildRenderObjectWidget</code>、<code>MultiChildRenderObjectWidget</code>只是重写了<code>createElement</code>方法以便返回各自对应的具体的 Element 类实例。</p>
</blockquote>

        <h1 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h1>
      <p>至此，重要的基础型 Widget 基本介绍完了，总结一下：</p>
<ul>
<li><p>Widget 本质上是 UI 的配置信息 (附加部分业务逻辑)，并不存在一颗真实的「Widget Tree」(与「Element Tree」、「RenderObject Tree」以及「Layer Tree」相比)；</p>
</li>
<li><p>Widget 从功能上可以分为 3 类：「Component Widget」、「Proxy Widget」以及「Renderer Widget」；</p>
</li>
<li><p>Widget 与 Element 一一对应，Widget 提供创建 Element 的方法 (createElement，本质上是一个工厂方法)；</p>
</li>
<li><p>只有「Renderer Widget」才会参与最终的 UI 生成过程(Layout、Paint)，只有该类型的 Widget 才有与之对应的「Render Object」，同样由其提供创建方法(createRenderObject)。</p>
</li>
</ul>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ FIN ------</div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://niki571.github.io/tags/%E5%8E%9F%E7%90%86/">原理</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/Flutter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89-BuildOwner/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Flutter源码解析（二）-BuildOwner</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/%E5%9F%BA%E4%BA%8Etimestamp%E5%92%8Cnonce%E7%9A%84%E9%98%B2%E6%AD%A2%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%E6%96%B9%E6%A1%88/"><span class="paginator-prev__text">基于 timestamp 和 nonce 的防止重放攻击方案</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">Contenido</span><span class="sidebar-nav-ov">Reseña</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">
          分类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">
          核心方法源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Widget"><span class="toc-number">2.1.</span> <span class="toc-text">
          Widget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StatelessWidget"><span class="toc-number">2.2.</span> <span class="toc-text">
          StatelessWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StatefulWidget"><span class="toc-number">2.3.</span> <span class="toc-text">
          StatefulWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#State"><span class="toc-number">2.4.</span> <span class="toc-text">
          State</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ParentDataWidget"><span class="toc-number">2.5.</span> <span class="toc-text">
          ParentDataWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InheritedWidget"><span class="toc-number">2.6.</span> <span class="toc-text">
          InheritedWidget</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RenderObjectWidget"><span class="toc-number">2.7.</span> <span class="toc-text">
          RenderObjectWidget</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">
          小结</span></a></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">Keep studying, Keep Creating</p></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">Has leído </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>WuQianying</span></div><div><span>Potenciado por <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v6.3.0</span><span class="footer__devider">|</span><span>Tema - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-banner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script></body></html>