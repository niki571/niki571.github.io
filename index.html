<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.8.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="吴倩颖的网络日志">
<meta property="og:url" content="https://niki571.github.io/index.html">
<meta property="og:site_name" content="吴倩颖的网络日志">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="WuQianying">
<meta name="twitter:card" content="summary"><title>吴倩颖的网络日志</title><link ref="canonical" href="https://niki571.github.io/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":true},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":true},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-solid fa-pen-nib"></i></span><span class="header-nav-menu-item__text">文章</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-solid fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/"><span class="header-nav-submenu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-submenu-item__text">分类</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-solid fa-tag"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/me/"><span class="header-nav-menu-item__icon"><i class="fas fa-solid fa-star"></i></span><span class="header-nav-menu-item__text">我</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">吴倩颖的网络日志</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/Flutter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-Widget/">Flutter源码解析（一）Widget</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2022-05-13</span></span></div></header><div class="post-body"><div class="post-excerpt"><blockquote>
<p>Everything’s a widget.</p>
</blockquote>
<p>在开发 Flutter 应用过程中，接触最多的无疑就是<code>Widget</code>，是『描述』 Flutter UI 的基本单元，通过<code>Widget</code>可以做到：</p>
<ul>
<li>描述 UI 的层级结构 (通过<code>Widget</code>嵌套)；</li>
<li>定制 UI 的具体样式 (如：<code>font</code>、<code>color</code>等)；</li>
<li>指导 UI 的布局过程 (如：<code>padding</code>、<code>center</code>等)；</li>
<li>…</li>
</ul>
<p>Google 在设计<code>Widget</code>时，还赋予它一些鲜明的特点：</p>
<p>声明式 UI —— 相对于传统 Native 开发中的命令式 UI，声明式 UI 有不少优势，如：开发效率显著提升、UI 可维护性明显加强等；</p>
<p>不可变性 —— Flutter 中所有<code>Widget</code>都是不可变的(immutable)，即其内部成员都是不可变的(final)，对于变化的部分需要通过「Stateful Widget-State」的方式实现；</p>
<p>组合大于继承 ——<code>Widget</code>设计遵循组合大于继承这一优秀的设计理念，通过将多个功能相对单一的 Widget 组合起来便可得到功能相对复杂的 Widget。</p>
<p>在<code>Widget</code>类定义处有这样一段注释：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/f38834b248be4280b5bf4671b3a97cef_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>这段注释阐明了<code>Widget</code>的本质：<strong>用于配置<code>Element</code>的，<code>Widget</code>本质上是 UI 的配置信息 (附带部分业务逻辑)。</strong></p>
<blockquote>
<p>我们通常会将通过<code>Widget</code>描述的 UI 层级结构称之为「Widget Tree」，但与「Element Tree」、「RenderObject Tree」以及「Layer Tree」相比，实质上并不存在「Widget Tree」。为了描述方便，将 Widget 组合描述的 UI 层级结构称之为「Widget Tree」，也未尝不可。</p>
</blockquote>

        <h1 id="分类"   >
          <a href="#分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类" class="headerlink" title="分类"></a>分类</h1>
      <p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/968873ae5e014a1aacf92b5b1e361707_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>如上图所示，按照功能划分<code>Widget</code>大致可以分为 3 类：</p>
<ul>
<li><p>「Component Widget」 —— 组合类<code>Widget</code>，这类<code>Widget</code>都直接或间接继承于<code>StatelessWidget</code>或<code>StatefulWidget</code>，上一小节提到过在<code>Widget</code>设计上遵循组合大于继承的原则，通过组合功能相对单一的 Widget 可以得到功能更为复杂的 Widget。平常的业务开发主要是在开发这一类型的 Widget；</p>
</li>
<li><p>「Proxy Widget」 —— 代理类<code>Widget</code>，正如其名，「Proxy Widget」本身并不涉及 Widget 内部逻辑，只是为「Child Widget」提供一些附加的中间功能。典型的如：InheritedWidget 用于在「Descendant Widgets」间传递共享信息、ParentDataWidget 用于配置「Descendant Renderer Widget」的布局信息；</p>
</li>
<li><p>「Renderer Widget」 —— 渲染类 Widget，是最核心的 Widget 类型，会直接参与后面的「Layout」、「Paint」流程，无论是「Component Widget」还是「Proxy Widget」最终都会映射到「Renderer Widget」上，否则将无法被绘制到屏幕上。这 3 类 Widget 中，只有「Renderer Widget」有与之一一对应的「Render Object」。</p>
</li>
</ul>

        <h1 id="核心方法源码分析"   >
          <a href="#核心方法源码分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心方法源码分析" class="headerlink" title="核心方法源码分析"></a>核心方法源码分析</h1>
      <p>下面，我们重点介绍各类型 Widget 的核心方法，以便更好地理解 Widget 是如何参与整个 UI 的构建过程。</p>

        <h2 id="Widget"   >
          <a href="#Widget" class="heading-link"><i class="fas fa-link"></i></a><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2>
      <p><code>Widget</code>，所有 Widget 的基类。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/a608f3e3ef40475a9f5aa44c462b5aaa_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>如上图所示，在<code>Widget</code>基类中有 3 个重要的方法 (属性)：</p>
<ul>
<li>Key key —— 在同一父节点下，用作兄弟节点间的唯一标识，主要用于控制当 Widget 更新时，对应的 Element 如何处理 (是更新还是新建)。若某 Widget 是其「Parent Widget」唯一的子节点时，一般不用设置 key；</li>
</ul>
<blockquote>
<p>GlobalKey 是一类较特殊的<code>key</code>，在介绍<code>Element</code>时会附带介绍。</p>
</blockquote>
<ul>
<li><p>Element createElement() —— 每个 Widget 都有一个与之对应的 Element，由该方法负责创建，createElement 可以理解为设计模式中的工厂方法，具体的 Element 类型由对应的 Widget 子类负责创建；</p>
</li>
<li><p>static bool canUpdate(Widget oldWidget, Widget newWidget) —— 是否可以用 new widget 修改前一帧用 old widget 生成的 Element，而不是创建新的 Element，Widget 类的默认实现为：2 个 Widget 的 runtimeType 与 key 都相等时，返回 true，即可以直接更新 (key 为 null 时，认为相等)。</p>
</li>
</ul>
<blockquote>
<p>上述更新流程，同样在介绍 Element 时会重点分析。</p>
</blockquote>

        <h2 id="StatelessWidget"   >
          <a href="#StatelessWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h2>
      <p>无状态-组合型 Widget，由其<code>build</code>方法描述组合 UI 的层级结构。在其生命周期内状态不可变。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/063fd9df872444758d43454ca2257808_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/e3e9b2c48047448181a6254ce4f7bc54_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<blockquote>
<p>ps: 对于有父子关系的类，在子类中只会介绍新增或有变化的方法</p>
</blockquote>
<ul>
<li><p>StatelessElement createElement() ——「Stateless Widget」对应的 Element 为 StatelessElement，一般情况下 StatelessWidget 子类不必重写该方法，即子类对应的 Element 也是 StatelessElement；</p>
</li>
<li><p>Widget build(BuildContext context) —— 算是 Flutter 体系中的核心方法之一，以『声明式 UI』的形式描述了该组合式 Widget 的 UI 层级结构及样式信息，也是开发 Flutter 应用的主要工作『场所』。该方法在 3 种情况下被调用：</p>
<ul>
<li>Widget 第一次被加入到 Widget Tree 中 (更准确地说是其对应的 Element 被加入到 Element Tree 时，即 Element 被挂载『mount』时)；</li>
<li>「Parent Widget」修改了其配置信息；</li>
<li>该 Widget 依赖的「Inherited Widget」发生变化时。</li>
</ul>
</li>
</ul>
<p>当「Parent Widget」或 依赖的「Inherited Widget」频繁变化时，build 方法也会频繁被调用。因此，提升 build 方法的性能就显得十分重要，Flutter 官方给出了几点建议：</p>
<ul>
<li><p>减少不必要的中间节点，即减少 UI 的层级，如：对于「Single Child Widget」，没必要通过组合「Row」、「Column」、「Padding」、「SizedBox」等复杂的 Widget 达到某种布局的目标，或许通过简单的「Align」、「CustomSingleChildLayout」即可实现。又或者，为了实现某种复杂精细的 UI 效果，不一定要通过组合多个「Container」，再附加「Decoration」来实现，通过 「CustomPaint」自定义或许是更好的选择；</p>
</li>
<li><p>尽可能使用 const Widget，为 Widget 提供 const 构造方法；</p>
</li>
<li><p>必要时，可以将「Stateless Widget」重构成「Stateful Widget」，以便可以使用「Stateful Widget」中一些特定的优化手法，如：缓存「sub trees」的公共部分，并在改变树结构时使用 GlobalKey；</p>
</li>
<li><p>尽量减小 rebuilt 范围，如：某个 Widget 因使用了「Inherited Widget」，导致频繁 rebuilt，可以将真正依赖「Inherited Widget」的部分提取出来，封装成更小的独立 Widget，并尽量将该独立 Widget 推向树的叶子节点，以便减小 rebuilt 时受影响的范围。</p>
</li>
</ul>

        <h2 id="StatefulWidget"   >
          <a href="#StatefulWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2>
      <p>有状态-组合型 Widget，但要注意的是<code>StatefulWidget</code>本身还是不可变的，其可变状态存在于<code>State</code>中。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/fddeb1525cce44ef96fd32c98430e89f_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/d1f19d4128f8405f80c3a84b908cea3c_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<ul>
<li><p>StatefulElement createElement() ——「Stateful Widget」对应的 Element 为 StatefulElement，一般情况下 StatefulWidget 子类不用重写该方法，即子类对应的 Element 也是 StatefulElement；</p>
</li>
<li><p>State createState() —— 创建对应的 State，该方法在 StatefulElement 的构造方法中被调用。可以简单地理解为当「Stateful Widget」被添加到 Widget Tree 时会调用该方法。</p>
</li>
</ul>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码已精简处理(本文中其他代码会做同样的简化处理)</span></span><br><span class="line">StatefulElement(StatefulWidget widget)</span><br><span class="line">  : _state = widget.createState(), <span class="keyword">super</span>(widget) &#123;</span><br><span class="line">  _state._element = <span class="keyword">this</span>;</span><br><span class="line">  _state._widget = widget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>实际上是「Stateful Widget」对应的「Stateful Element」被添加到 Element Tree 时，伴随「Stateful Element」的初始化，createState 方法被调用。<br>从后文可知一个 Widget 实例可以对应多个 Element 实例 (也就是同一份配置信息 (Widget) 可以在 Element Tree 上不同位置配置多个 Element 节点)，因此，createState 方法在「Stateful Widget」生命周期内可能会被调用多次。</p>
<p>另外，需要注意的是配有 GlobalKey 的 Widget 对应的 Element 在整个 Element Tree 中只有一个实例。</p>

        <h2 id="State"   >
          <a href="#State" class="heading-link"><i class="fas fa-link"></i></a><a href="#State" class="headerlink" title="State"></a>State</h2>
      <blockquote>
<p>The logic and internal state for a 「Stateful Widget」.</p>
</blockquote>
<p>State 用于处理「Stateful Widget」的业务逻辑以及可变状态。<br>由于其内部状态是可变的，故 State 有较复杂的生命周期：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/0041fcdd6a7344e29edcc13c4817c84f_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>如上图，State 的生命周期大致可以分为 8 个阶段：</p>
<ol>
<li>在对应的「Stateful Element」被挂载 (mount) 到树上时，通过 StatefulElement.constructor –&gt; StatefulWidget.createState 创建 State 实例；</li>
</ol>
<blockquote>
<p>从 StatefulElement.constructor 中的_state._element &#x3D; this;可知，State._emelent 指向了对应的 Element 实例，而我们熟知的 State.context 引用的就是这个_element：BuildContext get context &#x3D;&gt; _element;。State 实例与 Element 实例间的绑定关系一经确定，在整个生命周期内不会再变了 (Element 对应的 Widget 可能会变，但对应的 State 永远不会变)，期间，Element 可以在树上移动，但上述关系不会变 (即「Stateful Element」是带着状态移动的)。</p>
</blockquote>
<ol start="2">
<li><p>StatefulElement 在挂载过程中接着会调用 State.initState，子类可以重写该方法执行相关的初始化操作 (此时可以引用 context、widget 属性)；</p>
</li>
<li><p>同样在挂载过程中会调用 State.didChangeDependencies，该方法在 State 依赖的对象 (如：「Inherited Widget」) 状态发生变化时也会被调用，子类很少需要重写该方法，除非有非常耗时不宜在 build 中进行的操作，因为在依赖有变化时 build 方法也会被调用；</p>
</li>
<li><p>此时，State 初始化已完成，其 build 方法此后可能会被多次调用，在状态变化时 State 可通过 setState 方法来触发其子树的重建；</p>
</li>
<li><p>此时，「element tree」、「renderobject tree」、「layer tree」已构建完成，完整的 UI 应该已呈现出来。此后因为变化，「element tree」中「parent element」可能会对树上该位置的节点用新配置 (Widget) 进行重建，当新老配置 (oldWidget、newWidget)具有相同的「runtimeType」&amp;&amp;「key」时，framework 会用 newWidget 替换 oldWidget，并触发一系列的更新操作 (在子树上递归进行)。同时，State.didUpdateWidget 方法被调用，子类重写该方法去响应 Widget 的变化；</p>
</li>
</ol>
<blockquote>
<p>上述 3 棵树以及更新流程在后续文章中会有详细介绍</p>
</blockquote>
<ol start="6">
<li>在 UI 更新过程中，任何节点都有被移除的可能，State 也会随之移除，(如上一步中「runtimeType」||「key」不相等时)。此时会调用 State.deactivate 方法，由于被移除的节点可能会被重新插入树中某个新的位置上，故子类重写该方法以清理与节点位置相关的信息 (如：该 State 对其他 element 的引用)、同时，不应在该方法中做资源清理；</li>
</ol>
<blockquote>
<p>重新插入操作必须在当前帧动画结束之前</p>
</blockquote>
<ol start="7">
<li><p>当节点被重新插入树中时，State.build 方法被再次调用；</p>
</li>
<li><p>对于在当前帧动画结束时尚未被重新插入的节点，State.dispose 方法被执行，State 生命周期随之结束，此后再调用 State.setState 方法将报错。子类重写该方法以释放任何占用的资源。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/1c5760ab4e884dd3827d71628a7078af_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>至此，State 中的核心方法基本都已在上述过程中介绍了，下面重点看一下 <code>setState</code>方法：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(fn != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.defunct) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.created &amp;&amp; !mounted) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">dynamic</span> result = fn() <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">is</span> Future) &#123;</span><br><span class="line">      <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line"></span><br><span class="line">  _element.markNeedsBuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上述源码可以看到，关于<code>setState</code>方法有几点值得关注：</p>
<ul>
<li><p>在<code>State.dispose</code>后不能调用<code>setState</code>；</p>
</li>
<li><p>在<code>State</code>的构造方法中不能调用<code>setState</code>；</p>
</li>
<li><p><code>setState</code>方法的回调函数 (<code>fn</code>) 不能是异步的 (返回值为<code>Future</code>)，原因很简单，因为从流程设计上 framework 需要根据回调函数产生的新状态去刷新 UI；</p>
</li>
<li><p>通过<code>setState</code>方法之所以能更新 UI，是在其内部调用<code>_element.markNeedsBuild()</code>实现的 (具体过程在介绍 Element 时再详细分析)。</p>
</li>
</ul>
<p>关于 State 最后再强调 2 点：</p>
<ol>
<li>若<code>State.build</code>方法依赖了自身状态会变化的对象，如：<code>ChangeNotifier</code>、<code>Stream</code>或其他可以被订阅的对象，需要确保在 <code>initState</code>、<code>didUpdateWidget</code>、<code>dispose</code>等 3 方法间有正确的订阅 (subscribe) 与取消订阅 (unsubscribe) 的操作：</li>
</ol>
<ul>
<li>在<code>initState</code>中执行 subscribe；</li>
<li>如果关联的「Stateful Widget」与订阅有关，在<code>didUpdateWidget</code>中先取消旧的订阅，再执行新的订阅；</li>
<li>在<code>dispose</code>中执行 unsubscribe。</li>
</ul>
<ol start="2">
<li>在<code>State.initState</code>方法中不能调用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>，但<code>State.didChangeDependencies</code>会随之执行，在该方法中可以调用。</li>
</ol>

        <h2 id="ParentDataWidget"   >
          <a href="#ParentDataWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#ParentDataWidget" class="headerlink" title="ParentDataWidget"></a>ParentDataWidget</h2>
      <p><code>ParentDataWidget</code>以及下面要介绍的<code>InheritedElement</code>都继承自 <code>ProxyWidget</code>，由于<code>ProxyWidget</code>作为抽象基类本身没有任何功能，故下面直接介绍<code>ParentDataWidget</code>、<code>InheritedElement</code>。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/2a70ad26731c4528a59c758aa1656061_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p><code>ParentDataWidget</code>作为 Proxy 型 Widget，其功能主要是为其他 Widget 提供<code>ParentData</code>信息。虽然其 child widget 不一定是 RenderObejctWidget 类型，但其提供的<code>ParentData</code>信息最终都会落地到 RenderObejctWidget 类型子孙 Widget 上。</p>
<blockquote>
<p>ParentData 是『parent renderobject』在 layout『child renderobject』时使用的辅助定位信息，详细信息会在介绍 RenderObject 时介绍。</p>
</blockquote>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> attachRenderObject(<span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_ancestorRenderObjectElement == <span class="keyword">null</span>);</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _ancestorRenderObjectElement = _findAncestorRenderObjectElement();</span><br><span class="line">  _ancestorRenderObjectElement?.insertChildRenderObject(renderObject, newSlot);</span><br><span class="line">  <span class="keyword">final</span> ParentDataElement&lt;RenderObjectWidget&gt; parentDataElement = _findAncestorParentDataElement();</span><br><span class="line">  <span class="keyword">if</span> (parentDataElement != <span class="keyword">null</span>)</span><br><span class="line">  _updateParentData(parentDataElement.widget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ParentDataElement&lt;RenderObjectWidget&gt; _findAncestorParentDataElement() &#123;</span><br><span class="line">  <span class="built_in">Element</span> ancestor = _parent;</span><br><span class="line">  <span class="keyword">while</span> (ancestor != <span class="keyword">null</span> &amp;&amp; ancestor <span class="keyword">is</span>! RenderObjectElement) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ancestor <span class="keyword">is</span> ParentDataElement&lt;RenderObjectWidget&gt;)</span><br><span class="line">      <span class="keyword">return</span> ancestor;</span><br><span class="line">    ancestor = ancestor._parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _updateParentData(ParentDataWidget&lt;RenderObjectWidget&gt; parentData) &#123;</span><br><span class="line">  parentData.applyParentData(renderObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面这段代码来自<code>RenderObjectElement</code>，可以看到在其 <code>attachRenderObject</code>方法第 6 行从祖先节点找<code>ParentDataElement</code>，如果找到就用其 Widget(ParentDataWidget) 中的 parentData 信息去设置 Render Obejct。在查找过程中如查到<code>RenderObjectElement</code>(第 13 行)，说明当前 RenderObject 没有 Parent Data 信息。</p>
<p>最终会调用到<code>ParentDataWidget.applyParentData(RenderObject renderObject)</code>，子类需要重写该方法，以便设置对应<code>RenderObject.parentData</code>。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/9f692b89d69043d69b7d61799147bf07_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>来看个例子，通常配合 Stack 使用的 Positioned(继承自 ParentDataWidget)：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> applyParentData(RenderObject renderObject) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(renderObject.parentData <span class="keyword">is</span> StackParentData);</span><br><span class="line">  <span class="keyword">final</span> StackParentData parentData = renderObject.parentData;</span><br><span class="line">  <span class="built_in">bool</span> needsLayout = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (parentData.left != left) &#123;</span><br><span class="line">    parentData.left = left;</span><br><span class="line">    needsLayout = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (parentData.width != width) &#123;</span><br><span class="line">    parentData.width = width;</span><br><span class="line">    needsLayout = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (needsLayout) &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNode targetParent = renderObject.parent;</span><br><span class="line">    <span class="keyword">if</span> (targetParent <span class="keyword">is</span> RenderObject)</span><br><span class="line">      targetParent.markNeedsLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以看到，<code>Positioned</code>在必要时将自己的属性赋值给了对应的<code>RenderObject.parentData</code>(此处是<code>StackParentData</code>)，并对「parent render object」调用<code>markNeedsLayout</code>(第 19 行)，以便重新 layout，毕竟修改了布局相关的信息。</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentDataWidget</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span>&gt; <span class="keyword">extends</span> <span class="title">ProxyWidget</span></span></span><br></pre></td></tr></table></div></figure>

<p>如上所示，<code>ParentDataWidget</code>在定义上使用了泛型<code>&lt;T extends RenderObjectWidget&gt;</code>，其背后的含义是：从当前<code>ParentDataWidget</code>节点向上追溯形成的祖先节点链(『parent widget chain』)上，在 2 个 <code>ParentDataWidget</code>类型的节点形成的链上至少要有一个『RenderObject Widget』类型的节点。因为一个『RenderObject Widget』不能接受来自 2 个及以上『ParentData Widget』的信息。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/bb0bb8fbef2941d0b8348a04d37aef72_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>

        <h2 id="InheritedWidget"   >
          <a href="#InheritedWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h2>
      <p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/e21fa41da458487c82a4b653d0fb45cd_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<p>InheritedWidget 用于在树上向下传递数据。</p>
<p>通过<code>BuildContext.dependOnInheritedWidgetOfExactType</code>可以获取最近的「Inherited Widget」，需要注意的是通过这种方式获取「Inherited Widget」时，当「Inherited Widget」状态有变化时，会导致该引用方 rebuild。</p>
<blockquote>
<p>具体原理在介绍 Element 时会详细分析。</p>
</blockquote>
<p>通常，为了使用方便会「Inherited Widget」会提供静态方法<code>of</code>，在该方法中调用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>。<code>of</code>方法可以直接返回「Inherited Widget」，也可以是具体的数据。</p>
<p>有时，「Inherited Widget」是作为另一个类的实现细节而存在的，其本身是私有的(外部不可见)，此时<code>of</code>方法就会放到对外公开的类上。最典型的例子就是<code>Theme</code>，其本身是<code>StatelessWidget</code>类型，但其内部创建了一个「Inherited Widget」：<code>_InheritedTheme</code>，<code>of</code>方法就定义在上<code>Theme</code>上：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThemeData of(BuildContext context, &#123; <span class="built_in">bool</span> shadowThemeOnly = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> _InheritedTheme inheritedTheme = context.dependOnInheritedWidgetOfExactType&lt;\_InheritedTheme&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ThemeData.localize(theme, theme.typography.geometryThemeFor(category));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>该<code>of</code>方法返回的是<code>ThemeData</code>类型的具体数据，并在其内部首先调用了 <code>BuildContext.dependOnInheritedWidgetOfExactType</code>。<br>我们经常使用的「Inherited Widget」莫过于<code>MediaQuery</code>，同样提供了<code>of</code>方法：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MediaQueryData of(BuildContext context, &#123; <span class="built_in">bool</span> nullOk = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> MediaQuery query = context.dependOnInheritedWidgetOfExactType&lt;MediaQuery&gt;();</span><br><span class="line">  <span class="keyword">if</span> (query != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> query.data;</span><br><span class="line">  <span class="keyword">if</span> (nullOk)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/89aeac1cc6de483f90fcbf74687daf26_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<ul>
<li><p>InheritedElement createElement() ——「Inherited Widget」对应的 Element 为 InheritedElement，一般情况下 InheritedElement 子类不用重写该方法；</p>
</li>
<li><p>bool updateShouldNotify(covariant InheritedWidget oldWidget) —— 在「Inherited Widget」rebuilt 时判断是否需要 rebuilt 那些依赖它的 Widget；</p>
</li>
</ul>
<p>如下是<code>MediaQuery.updateShouldNotify</code>的实现，在新老<code>Widget.data</code>不相等时才 rebuilt 那依赖的 Widget。</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> updateShouldNotify(MediaQuery oldWidget) =&gt; data != oldWidget.data;</span><br></pre></td></tr></table></div></figure>


        <h2 id="RenderObjectWidget"   >
          <a href="#RenderObjectWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#RenderObjectWidget" class="headerlink" title="RenderObjectWidget"></a>RenderObjectWidget</h2>
      <p>真正与渲染相关的 Widget，属于最核心的类型，一切其他类型的 Widget 要渲染到屏幕上，最终都要回归到该类型的 Widget 上。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/095c50c0cc914c0689f381881715a2d4_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>
<ul>
<li><p>RenderObjectElement createElement() ——「RenderObject Widget」对应的 Element 为 RenderObjectElement，由于 RenderObjectElement 也是抽象类，故子类需要重写该方法；</p>
</li>
<li><p>RenderObject createRenderObject(BuildContext context) —— 核心方法，创建 Render Widget 对应的 Render Object，同样子类需要重写该方法。该方法在对应的 Element 被挂载到树上时调用(Element.mount)，即在 Element 挂载过程中同步构建了「Render Tree」(详细过程后续文章会详细分析)；</p>
</li>
</ul>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">RenderFlex createRenderObject(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> RenderFlex(</span><br><span class="line">    direction: direction,</span><br><span class="line">    mainAxisAlignment: mainAxisAlignment,</span><br><span class="line">    mainAxisSize: mainAxisSize,</span><br><span class="line">    crossAxisAlignment: crossAxisAlignment,</span><br><span class="line">    textDirection: getEffectiveTextDirection(context),</span><br><span class="line">    verticalDirection: verticalDirection,</span><br><span class="line">    textBaseline: textBaseline,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面是<code>Flex.createRenderObject</code>的源码，真实感受一下 (还是代码更有感觉)。可以看到，用 Flex 的信息(配置)初始化了<code>RenderFlex</code>。</p>
<blockquote>
<p><code>Flex</code>是<code>Row</code>、<code>Column</code>的基类，<code>RenderFlex</code>继承自<code>RenderBox</code>，后者继续自<code>RenderObject</code>。</p>
</blockquote>
<ul>
<li><code>void updateRenderObject(BuildContext context, covariant RenderObject renderObject)</code>—— 核心方法，在 Widget 更新后，修改对应的 Render Object。该方法在首次 build 以及需要更新 Widget 时都会调用；</li>
</ul>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> updateRenderObject(BuildContext context, <span class="keyword">covariant</span> RenderFlex renderObject) &#123;</span><br><span class="line">  renderObject</span><br><span class="line">    ..direction = direction</span><br><span class="line">    ..mainAxisAlignment = mainAxisAlignment</span><br><span class="line">    ..mainAxisSize = mainAxisSize</span><br><span class="line">    ..crossAxisAlignment = crossAxisAlignment</span><br><span class="line">    ..textDirection = getEffectiveTextDirection(context)</span><br><span class="line">    ..verticalDirection = verticalDirection</span><br><span class="line">    ..textBaseline = textBaseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>Flex.updateRenderObject</code>的源码也很简单，与<code>Flex.createRenderObject</code>几乎一一对应，用当前<code>Flex</code>的信息修改<code>renderObject</code>。</p>
<ul>
<li><code>void didUnmountRenderObject(covariant RenderObject renderObject)</code>—— 对应的「Render Object」从「Render Tree」上移除时调用该方法。</li>
</ul>
<blockquote>
<p><code>RenderObjectWidget</code>的几个子类：<code>LeafRenderObjectWidget</code>、<code>SingleChildRenderObjectWidget</code>、<code>MultiChildRenderObjectWidget</code>只是重写了<code>createElement</code>方法以便返回各自对应的具体的 Element 类实例。</p>
</blockquote>

        <h1 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h1>
      <p>至此，重要的基础型 Widget 基本介绍完了，总结一下：</p>
<ul>
<li><p>Widget 本质上是 UI 的配置信息 (附加部分业务逻辑)，并不存在一颗真实的「Widget Tree」(与「Element Tree」、「RenderObject Tree」以及「Layer Tree」相比)；</p>
</li>
<li><p>Widget 从功能上可以分为 3 类：「Component Widget」、「Proxy Widget」以及「Renderer Widget」；</p>
</li>
<li><p>Widget 与 Element 一一对应，Widget 提供创建 Element 的方法 (createElement，本质上是一个工厂方法)；</p>
</li>
<li><p>只有「Renderer Widget」才会参与最终的 UI 生成过程(Layout、Paint)，只有该类型的 Widget 才有与之对应的「Render Object」，同样由其提供创建方法(createRenderObject)。</p>
</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E5%9F%BA%E4%BA%8Etimestamp%E5%92%8Cnonce%E7%9A%84%E9%98%B2%E6%AD%A2%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%E6%96%B9%E6%A1%88/">基于 timestamp 和 nonce 的防止重放攻击方案</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2022-03-07</span></span></div></header><div class="post-body"><div class="post-excerpt"><p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/1610c97ae68f2c5f_tplv-t2oaga2asx-zoom-crop-mark_3024_3024_3024_1702.awebp"></p>
<p>以前总是通过 timestamp 来防止重放攻击，但是这样并不能保证每次请求都是一次性的。今天看到了一篇文章介绍的通过 nonce（Number used once）来保证一次有效，感觉两者结合一下，就能达到一个非常好的效果了。</p>
<blockquote>
<p>重放攻击是计算机世界黑客常用的攻击方式之一，所谓重放攻击就是攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程。</p>
</blockquote>
<p>首先要明确一个事情，重放攻击是二次请求，黑客通过抓包获取到了请求的 HTTP 报文，然后黑客自己编写了一个类似的 HTTP 请求，发送给服务器。也就是说服务器处理了两个请求，先处理了正常的 HTTP 请求，然后又处理了黑客发送的篡改过的 HTTP 请求。</p>

        <h1 id="基于-timestamp-的方案"   >
          <a href="#基于-timestamp-的方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#基于-timestamp-的方案" class="headerlink" title="基于 timestamp 的方案"></a>基于 timestamp 的方案</h1>
      <p>每次 HTTP 请求，都需要加上 timestamp 参数，然后把 timestamp 和其他参数一起进行数字签名。因为一次正常的 HTTP 请求，从发出到达服务器一般都不会超过 60s，所以服务器收到 HTTP 请求之后，首先判断时间戳参数与当前时间相比较，是否超过了 60s，如果超过了则认为是非法的请求。</p>
<p>假如黑客通过抓包得到了我们的请求 url： koastal.site&#x2F;index&#x2F;Info?…</p>
<p>其中</p>
<figure class="highlight php"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="variable">$sign</span>=<span class="title function_ invoke__">md5</span>(<span class="variable">$uid</span>.<span class="variable">$token</span>.<span class="variable">$stime</span>);</span><br><span class="line"><span class="comment">// 服务器通过 uid 从数据库中可读出 token</span></span><br></pre></td></tr></table></div></figure>

<p>一般情况下，黑客从抓包重放请求耗时远远超过了 60s，所以此时请求中的 stime 参数已经失效了。 如果黑客修改 stime 参数为当前的时间戳，则 sign 参数对应的数字签名就会失效，因为黑客不知道 token 值，没有办法生成新的数字签名。</p>
<p>但这种方式的漏洞也是显而易见的，如果在 60s 之后进行重放攻击，那就没办法了，所以这种方式不能保证请求仅一次有效。</p>

        <h1 id="基于-nonce-的方案"   >
          <a href="#基于-nonce-的方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#基于-nonce-的方案" class="headerlink" title="基于 nonce 的方案"></a>基于 nonce 的方案</h1>
      <p>nonce 的意思是仅一次有效的随机字符串，要求每次请求时，该参数要保证不同，所以该参数一般与时间戳有关，我们这里为了方便起见，直接使用时间戳的 16 进制，实际使用时可以加上客户端的 ip 地址，mac 地址等信息做个哈希之后，作为 nonce 参数。</p>
<p>我们将每次请求的 nonce 参数存储到一个“集合”中，可以 json 格式存储到数据库或缓存中。 每次处理 HTTP 请求时，首先判断该请求的 nonce 参数是否在该“集合”中，如果存在则认为是非法请求。</p>
<p>假如黑客通过抓包得到了我们的请求 url： koastal.site&#x2F;index&#x2F;Info?…</p>
<p>其中</p>
<figure class="highlight php"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sign</span>=<span class="title function_ invoke__">md5</span>(<span class="variable">$uid</span>.<span class="variable">$token</span>.<span class="variable">$nonce</span>);</span><br><span class="line"><span class="comment">// 服务器通过 uid 从数据库中可读出 token</span></span><br></pre></td></tr></table></div></figure>

<p>nonce 参数在首次请求时，已经被存储到了服务器上的“集合”中，再次发送请求会被识别并拒绝。 nonce 参数作为数字签名的一部分，是无法篡改的，因为黑客不清楚 token，所以不能生成新的 sign。</p>
<p>这种方式也有很大的问题，那就是存储 nonce 参数的“集合”会越来越大，验证 nonce 是否存在“集合”中的耗时会越来越长。我们不能让 nonce“集合”无限大，所以需要定期清理该“集合”，但是一旦该“集合”被清理，我们就无法验证被清理了的 nonce 参数了。也就是说，假设该“集合”平均 1 天清理一次的话，我们抓取到的该 url，虽然当时无法进行重放攻击，但是我们还是可以每隔一天进行一次重放攻击的。而且存储 24 小时内，所有请求的“nonce”参数，也是一笔不小的开销。</p>

        <h1 id="基于-timestamp-和-nonce-的方案"   >
          <a href="#基于-timestamp-和-nonce-的方案" class="heading-link"><i class="fas fa-link"></i></a><a href="#基于-timestamp-和-nonce-的方案" class="headerlink" title="基于 timestamp 和 nonce 的方案"></a>基于 timestamp 和 nonce 的方案</h1>
      <p>那我们如果同时使用 timestamp 和 nonce 参数呢？ nonce 的一次性可以解决 timestamp 参数 60s 的问题，timestamp 可以解决 nonce 参数“集合”越来越大的问题。</p>
<p>我们在 timestamp 方案的基础上，加上 nonce 参数，因为 timstamp 参数对于超过 60s 的请求，都认为非法请求，所以我们只需要存储 60s 的 nonce 参数的“集合”即可。</p>
<p>假如黑客通过抓包得到了我们的请求 url： koastal.site&#x2F;index&#x2F;Info?…</p>
<p>其中</p>
<figure class="highlight php"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sign</span>=<span class="title function_ invoke__">md5</span>(<span class="variable">$uid</span>.<span class="variable">$token</span>.<span class="variable">$stime</span>.<span class="variable">$nonce</span>);</span><br><span class="line"><span class="comment">// 服务器通过 uid 从数据库中可读出 token</span></span><br></pre></td></tr></table></div></figure>

<p>如果在 60s 内，重放该 HTTP 请求，因为 nonce 参数已经在首次请求的时候被记录在服务器的 nonce 参数“集合”中，所以会被判断为非法请求。超过 60s 之后，stime 参数就会失效，此时因为黑客不清楚 token 的值，所以无法重新生成签名。</p>
<p>综上，我们认为一次正常的 HTTP 请求发送不会超过 60s，在 60s 之内的重放攻击可以由 nonce 参数保证，超过 60s 的重放攻击可以由 stime 参数保证。</p>
<p>因为 nonce 参数只会在 60s 之内起作用，所以只需要保存 60s 之内的 nonce 参数即可。</p>
<p>我们并不一定要每个 60s 去清理该 nonce 参数的集合，只需要在新的 nonce 到来时，判断 nonce 集合最后一次修改时间，超过 60s 的话，就清空该集合，存放新的 nonce 参数集合。其实 nonce 参数集合可以存放的时间更久一些，但是最少是 60s。</p>
<p>验证流程</p>
<figure class="highlight php"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断stime参数是否有效</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$now</span> - <span class="variable">$stime</span> &gt; <span class="number">60</span>)&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;请求超时&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断nonce参数是否在“集合”已存在</span></span><br><span class="line"><span class="keyword">if</span>( <span class="title function_ invoke__">in_array</span>(<span class="variable">$nonce</span>,<span class="variable">$nonceArray</span>) )&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;请求仅一次有效&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//验证数字签名</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="variable">$sign</span> != <span class="title function_ invoke__">md5</span>(<span class="variable">$uid</span>.<span class="variable">$token</span>.<span class="variable">$stime</span>.<span class="variable">$nonce</span>) )&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;数字签名验证失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否需要清理nonce集合</span></span><br><span class="line"><span class="keyword">if</span>( <span class="variable">$now</span> - <span class="variable">$nonceArray</span>-&gt;lastModifyTime &gt; <span class="number">60</span> )&#123;</span><br><span class="line">    <span class="variable">$nonceArray</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//记录本次请求的nonce参数</span></span><br><span class="line"><span class="variable">$nonceArray</span>.<span class="title function_ invoke__">push</span>(<span class="variable">$nonce</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始处理合法的请求</span></span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E4%BB%8Ereflect-metadata%E7%90%86%E8%A7%A3Nest%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">从 reflect metadata 理解 Nest 的实现原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2022-02-21</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="依赖注入"   >
          <a href="#依赖注入" class="heading-link"><i class="fas fa-link"></i></a><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1>
      <p>Nest 是 Node.js 的服务端框架，它最出名的就是 IOC（inverse of control） 机制了，也就是不需要手动创建实例，框架会自动扫描需要加载的类，并创建他们的实例放到容器里，实例化时还会根据该类的构造器参数自动注入依赖。</p>
<p>它一般是这样用的：</p>
<p>比如入口 Module 里引入某个模块的 Module：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@nestjs/common&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsModule</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./cats/cats.module&quot;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [<span class="title class_">CatsModule</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppModule</span> &#123;&#125;</span><br></pre></td></tr></table></div></figure>

<p>然后这个模块的 Module 里会声明 Controller 和 Service：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@nestjs/common&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsController</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./cats.controller&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsService</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./cats.service&quot;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Module</span>(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [<span class="title class_">CatsController</span>],</span><br><span class="line">  <span class="attr">providers</span>: [<span class="title class_">CatsService</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsModule</span> &#123;&#125;</span><br></pre></td></tr></table></div></figure>

<p>Controller 里就是声明 url 对应的处理逻辑：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Body</span>, <span class="title class_">Controller</span>, <span class="title class_">Get</span>, <span class="title class_">Param</span>, <span class="title class_">Post</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CreateCatDto</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto/create-cat.dto&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Controller</span>(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsController</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">private readonly catsService: CatsService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Post</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">@Body() createCatDto: CreateCatDto</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">catsService</span>.<span class="title function_">create</span>(createCatDto);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Get</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">findAll</span>(): <span class="title class_">Promise</span>&lt;<span class="title class_">Cat</span>[]&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">catsService</span>.<span class="title function_">findAll</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这个 CatsController 的构造器声明了对 CatsService 的依赖：</p>
<p>然后 CatsService 里就可以去操作数据库进行增删改查了。这里简单实现一下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Cat</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./interfaces/cat.interface&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsService</span> &#123;</span><br><span class="line">private readonly <span class="attr">cats</span>: <span class="title class_">Cat</span>[] = [];</span><br><span class="line"></span><br><span class="line"><span class="title function_">create</span>(<span class="params">cat: Cat</span>) &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">cats</span>.<span class="title function_">push</span>(cat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">findAll</span>(): <span class="title class_">Cat</span>[] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">cats</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<p>之后在入口处调用 create 把整个 nest 应用跑起来：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NestFactory</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@nestjs/core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AppModule</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./app.module&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">bootstrap</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> <span class="title class_">NestFactory</span>.<span class="title function_">create</span>(<span class="title class_">AppModule</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">bootstrap</span>();</span><br></pre></td></tr></table></div></figure>

<p>然后浏览器访问下我们写的那个 controller 对应的 url，打个断点：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/86d0535710ad48348206520ee2cb89ee_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>你会发现 controller 的实例已经创建了，而且 service 也给注入了。这就是依赖注入的含义。</p>
<p>这种机制就叫做 IOC（控制反转），也叫依赖注入，好处是显而易见的，就是只需要声明依赖关系，不需要自己创建对象，框架会扫描声明然后自动创建并注入依赖。</p>
<p>Java 里最流行的 Spring 框架就是 IOC 的实现，而 Nest 也是这样一个实现了 IOC 机制的 Node.js 的后端框架。</p>
<p>不知道大家有没有感觉很神奇，只是通过装饰器声明了一下，然后启动 Nest 应用，这时候对象就给创建好了，依赖也给注入了。</p>
<p>那它是怎么实现的呢？</p>
<p>大家如果就这样去思考它的实现原理，还真不一定能想出来，因为缺少了一些前置知识。也就是实现 Nest 最核心的一些 api： Reflect 的 metadata 的 api。</p>

        <h1 id="Reflect-Metadata"   >
          <a href="#Reflect-Metadata" class="heading-link"><i class="fas fa-link"></i></a><a href="#Reflect-Metadata" class="headerlink" title="Reflect Metadata"></a>Reflect Metadata</h1>
      <p>有的同学会说，Reflect 的 api 我很熟呀，就是操作对象的属性、方法、构造器的一些 api：</p>
<p>比如 Reflect.get 是获取对象属性值</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/b5a7ba0e6dc94d0fb842cafc25ac4dd2_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>Reflect.set 是设置对象属性值</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/69c386cd587d4b958212a5ee1ee09a96_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>Reflect.has 是判断对象属性是否存在</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/783e8067a805459d9ec0d56292f529a4_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>Reflect.apply 是调用某个方法，传入对象和参数</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/7708d7a8c01a4fb6ae10b51b98442921_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>Reflect.construct 是用构造器创建对象实例，传入构造器参数</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/ed7bde270882465cb9ffdc624bbb4e61_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>这些 api 在 MDN 文档里可以查到，因为它们都已经是 es 标准了，也被很多浏览器实现了。</p>
<p>但是实现 Nest 用到的 api 还没有进入标准，还在草案阶段，也就是 metadata 的 api：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/a9cf799a18794e0a903170b6bf76fa21_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>它有这些 api：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(metadataKey, metadataValue, target);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">defineMetadata</span>(metadataKey, metadataValue, target, propertyKey);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(metadataKey, target);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(metadataKey, target, propertyKey);</span><br></pre></td></tr></table></div></figure>

<p><code>Reflect.defineMetadata</code>和<code>Reflect.getMetadata</code>分别用于设置和获取某个类的元数据，如果最后传入了属性名，还可以单独为某个属性设置元数据。</p>
<p>那元数据存在哪呢？</p>
<p>存在类或者对象上呀，如果给类或者类的静态属性添加元数据，那就保存在类上，如果给实例属性添加元数据，那就保存在对象上，用类似<code>[[metadata]]</code>的<code>key</code>来存的。</p>
<p>这有啥用呢？</p>
<p>看上面的 api 确实看不出啥来，但它也支持装饰器的方式使用：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(metadataKey, metadataValue)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">  @<span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(metadataKey, metadataValue)</span><br><span class="line">  <span class="title function_">method</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>Reflect.metadata</code>装饰器当然也可以再封装一层：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Type</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&quot;design:type&quot;</span>, type);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ParamTypes</span>(<span class="params">...types</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&quot;design:paramtypes&quot;</span>, types);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ReturnType</span>(<span class="params">type</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&quot;design:returntype&quot;</span>, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">ParamTypes</span>(<span class="title class_">String</span>, <span class="title class_">Number</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Guang</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">text, i</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Type</span>(<span class="title class_">String</span>)</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;text&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Type</span>(<span class="title class_">Function</span>)</span><br><span class="line">  @<span class="title class_">ParamTypes</span>(<span class="title class_">Number</span>, <span class="title class_">Number</span>)</span><br><span class="line">  @<span class="title class_">ReturnType</span>(<span class="title class_">Number</span>)</span><br><span class="line">  <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>然后我们就可以通过 Reflect metadata 的 api 或者这个类和对象的元数据了：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Guang</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> paramTypes = <span class="title class_">Reflect</span>.<span class="title function_">getMetadata</span>(<span class="string">&quot;design:paramtypes&quot;</span>, obj, <span class="string">&quot;add&quot;</span>);</span><br><span class="line"><span class="comment">// [Number, Number]</span></span><br></pre></td></tr></table></div></figure>

<p>这里我们用 Reflect.getMetadata 的 api 取出了 add 方法的参数的类型。</p>
<p>看到这里，大家是否明白 nest 的原理了呢？</p>
<p>我们再看下 nest 的源码：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/f2bb578b9b624bf993aaedc250ec053d_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>上面就是<code>@Module</code>装饰器的实现，里面就调用了 Reflect.defineMetadata 来给这个类添加了一些元数据。<br>所以我们这样用的时候：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@nestjs/common&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsController</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./cats.controller&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsService</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./cats.service&quot;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Module</span>(&#123;</span><br><span class="line">  <span class="attr">controllers</span>: [<span class="title class_">CatsController</span>],</span><br><span class="line">  <span class="attr">providers</span>: [<span class="title class_">CatsService</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsModule</span> &#123;&#125;</span><br></pre></td></tr></table></div></figure>

<p>其实就是给 CatsModule 添加了 controllers 的元数据和 providers 的元数据。</p>
<p>后面创建 IOC 容器的时候就会取出这些元数据来处理：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/12e7eca6e54e4fa1867b16b83237135a_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/32ea9f7aa5374ce681053a4dcae06723_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>而且 @Controller 和 @Injectable 的装饰器也是这样实现的：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/bd7235bd63374965a7d55c5866471983_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/c82a1514a28749668ec631b7e565e466_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>看到这里，大家是否想明白 nest 的实现原理了呢？</p>
<p>其实就是通过装饰器给 class 或者对象添加元数据，然后初始化的时候取出这些元数据，进行依赖的分析，然后创建对应的实例对象就可以了。</p>
<p>所以说，nest 实现的核心就是 Reflect metadata 的 api。</p>
<p>当然，现在 metadata 的 api 还在草案阶段，需要使用 reflect-metadata 这个 polyfill 包才行。</p>
<p>其实还有一个疑问，依赖的扫描可以通过 metadata 数据，但是创建的对象需要知道构造器的参数，现在并没有添加这部分 metadata 数据呀：</p>
<p>比如这个 CatsController 依赖了 CatsService，但是并没有添加 metadata 呀：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Body</span>, <span class="title class_">Controller</span>, <span class="title class_">Get</span>, <span class="title class_">Param</span>, <span class="title class_">Post</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CatsService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./cats.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CreateCatDto</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto/create-cat.dto&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Controller</span>(<span class="string">&#x27;cats&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CatsController</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">private readonly catsService: CatsService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Post</span>()</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">create</span>(<span class="params">@Body() createCatDto: CreateCatDto</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">catsService</span>.<span class="title function_">create</span>(createCatDto);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Get</span>()</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">findAll</span>(): <span class="title class_">Promise</span>&lt;<span class="title class_">Cat</span>[]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">catsService</span>.<span class="title function_">findAll</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这就不得不提到 TypeScript 的优势了，TypeScript 支持编译时自动添加一些 metadata 数据：</p>
<p>比如这段代码：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;reflect-metadata&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Guang</span> &#123;</span><br><span class="line">  @<span class="title class_">Reflect</span>.<span class="title function_">metadata</span>(<span class="string">&quot;名字&quot;</span>, <span class="string">&quot;光光&quot;</span>)</span><br><span class="line">  public <span class="title function_">say</span>(<span class="attr">a</span>: number): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;加油鸭&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>按理说我们只添加了一个元数据，生成的代码也确实是这样的：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/4c525cd38ea542bab80ef31a15719265_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>但是呢，ts 有一个编译选项叫做 emitDecoratorMetadata，开启它就会自动添加一些元数据。</p>
<p>开启之后再试一下：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/d14d5736bef144a9a6830c7626b15b9f_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>你会看到多了三个元数据：</p>
<p><code>design:type</code>是<code>Function</code>，很明显，这个是描述装饰目标的元数据，这里装饰的是函数</p>
<p><code>design:paramtypes</code>是<code>[Number]</code>，很容易理解，就是参数的类型</p>
<p><code>design:returntype</code>是<code>String</code>，也很容易理解，就是返回值的类型</p>
<p>所以说，只要开启了这个编译选项，ts 生成的代码会自动添加一些元数据。</p>
<p>然后创建对象的时候就可以通过 design:paramtypes 来拿到构造器参数的类型了，那不就知道怎么注入依赖了么？</p>
<p>所以，nest 源码里你会看到这样的代码：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/af6a8ad0ce814857881fbf2a7c503e7c_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>就是获取构造器的参数类型的。这个常量就是我们上面说的那个：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/3c6b32199ab1443794f56bdac63a2a5b_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>这也是为什么 nest 会用 ts 来写，因为它很依赖这个 emitDecoratorMetadata 的编译选项。</p>
<p>你用 cli 生成的代码模版里也都默认开启了这个编译选项：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/a984d979388a42bbb77bcef2b3c4dc26_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>这就是 nest 的核心实现原理：<strong>通过装饰器给 class 或者对象添加 metadata，并且开启 ts 的 emitDecoratorMetadata 来自动添加类型相关的 metadata，然后运行的时候通过这些元数据来实现依赖的扫描，对象的创建等等功能。</strong></p>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>Nest 是 Node.js 的后端框架，他的核心就是 IOC 容器，也就是自动扫描依赖，创建实例对象并且自动依赖注入。</p>
<p>要搞懂它的实现原理，需要先学习<code>Reflect metadata</code>的 api：</p>
<p>这个是给类或者对象添加<code>metadata</code>的。可以通过<code>Reflect.metadata</code>给类或者对象添加元数据，之后用到这个类或者对象的时候，可以通过<code>Reflect.getMetadata</code>把它们取出来。</p>
<p><code>Nest</code>的<code>Controller</code>、<code>Module</code>、<code>Service</code>等等所有的装饰器都是通过 <code>Reflect.meatdata</code>给类或对象添加元数据的，然后初始化的时候取出来做依赖的扫描，实例化后放到<code>IOC</code>容器里。</p>
<p>实例化对象还需要构造器参数的类型，这个开启 ts 的<code>emitDecoratorMetadata</code>的编译选项之后， ts 就会自动添加一些元数据，也就是<code>design:type</code>、<code>design:paramtypes</code>、<code>design:returntype</code>这三个，分别代表被装饰的目标的类型、参数的类型、返回值的类型。</p>
<p>当然，<code>reflect metadata</code>的 api 还在草案阶段，需要引入 refelect metadata 的包做 polyfill。</p>
<p>nest 的一系列装饰器就是给 class 和对象添加 metadata 的，然后依赖扫描和依赖注入的时候就把 metadata 取出来做一些处理。</p>
<p>理解了 metadata，nest 的实现原理就很容易搞懂了。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E4%B8%BA%E4%BB%80%E4%B9%88React%E7%9A%84Diff%E7%AE%97%E6%B3%95%E4%B8%8D%E9%87%87%E7%94%A8Vue%E7%9A%84%E5%8F%8C%E7%AB%AF%E5%AF%B9%E6%AF%94%E7%AE%97%E6%B3%95/">为什么React的Diff算法不采用Vue的双端对比算法</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-05-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="前言"   >
          <a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1>
      <p>都说“双端对比算法”，那么双端对比算法，到底是怎么样的呢？跟 React 中的 Diff 算法又有什么不同呢？</p>
<p>要了解这些，我们先了解 React 中的 Diff 算法，然后再了解 Vue3 中的 Diff 算法，最后讲一下 Vue2 中的 Diff 算法，才能去比较一下他们的区别。</p>
<p>最后讲一下为什么 Vue 中不需要使用 Fiber 架构。</p>

        <h1 id="React-官方的解析"   >
          <a href="#React-官方的解析" class="heading-link"><i class="fas fa-link"></i></a><a href="#React-官方的解析" class="headerlink" title="React 官方的解析"></a>React 官方的解析</h1>
      <p>其实为什么 React 不采用 Vue 的双端对比算法，React 官方已经在源码的注释里已经说明了，我们来看一下 React 官方是怎么说的。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reconcileChildrenArray</span>(<span class="params"></span></span><br><span class="line"><span class="params">returnFiber: Fiber,</span></span><br><span class="line"><span class="params">currentFirstChild: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">newChildren: <span class="built_in">Array</span>&lt;\*&gt;,</span></span><br><span class="line"><span class="params">expirationTime: ExpirationTime,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line"><span class="comment">// This algorithm can&#x27;t optimize by searching from boths ends since we</span></span><br><span class="line"><span class="comment">// don&#x27;t have backpointers on fibers. I&#x27;m trying to see how far we can get</span></span><br><span class="line"><span class="comment">// with that model. If it ends up not being worth the tradeoffs, we can</span></span><br><span class="line"><span class="comment">// add it later.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Even with a two ended optimization, we&#x27;d want to optimize for the case</span></span><br><span class="line">    <span class="comment">// where there are few changes and brute force the comparison instead of</span></span><br><span class="line">    <span class="comment">// going for the Map. It&#x27;d like to explore hitting that path first in</span></span><br><span class="line">    <span class="comment">// forward-only mode and only go for the Map once we notice that we need</span></span><br><span class="line">    <span class="comment">// lots of look ahead. This doesn&#x27;t handle reversal as well as two ended</span></span><br><span class="line">    <span class="comment">// search but that&#x27;s unusual. Besides, for the two ended optimization to</span></span><br><span class="line">    <span class="comment">// work on Iterables, we&#x27;d need to copy the whole set.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// In this first iteration, we&#x27;ll just live with hitting the bad case</span></span><br><span class="line">    <span class="comment">// (adding everything to a Map) in for every insert/move.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// If you change this code, also update reconcileChildrenIterator() which</span></span><br><span class="line">    <span class="comment">// uses the same algorithm.</span></span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></div></figure>

<p>大概的意思就是说：</p>
<p>React 不能通过双端对比进行 Diff 算法优化是因为目前 Fiber 上没有设置反向链表，而且想知道就目前这种方案能持续多久，如果目前这种模式不理想的话，那么也可以增加双端对比算法。</p>
<p>即使是双端对比算法，我们也要对这种情况进行优化，我们应该使用 Map 这种数据结构方案去替代原来那种几乎没有什么变化也进行暴力比较的方案。它第一次搜索循环是通过 forward-only 这种模式（就是只从左向右查找），（第一次循环可能还没有结束，还有节点没有比对的时候）如果还要继续向前循环查找那么就要通过 Map 这种数据类型了。（就目前这个单向链表的数据结构，如果采用）双端对比查找算法比较难控制它反向查找的，但它确实是一种成功的算法。此外，双端对比算法的实现也在我们的工作迭代当中。</p>
<p>第一次迭代，我们就先将就使用这种不好的方案吧，每次新增&#x2F;移动都要添加所有的数据到一个 Map 的数据类型对象中。</p>
<p>React 的官方虽然解析了，但我们想要彻底理解到底为什么，还是要去详细了解 React 的 Diff 算法是怎么样的。在了解 React Diff 算法之前，我们首先要了解什么是 Fiber，为什么 React 中要使用 Fiber？</p>

        <h1 id="Fiber-的结构"   >
          <a href="#Fiber-的结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#Fiber-的结构" class="headerlink" title="Fiber 的结构"></a>Fiber 的结构</h1>
      <p>在 React15 以前 React 的组件更新创建虚拟 DOM 和 Diff 的过程是不可中断，如果需要更新组件树层级非常深的话，在 Diff 的过程会非常占用浏览器的线程，而我们都知道浏览器执行 JavaScript 的线程和渲染真实 DOM 的线程是互斥的，也就是同一时间内，浏览器要么在执行 JavaScript 的代码运算，要么在渲染页面，如果 JavaScript 的代码运行时间过长则会造成页面卡顿。</p>
<p>基于以上原因 React 团队在 React16 之后就改写了整个架构，将原来数组结构的虚拟 DOM，改成叫 Fiber 的一种数据结构，基于这种 Fiber 的数据结构可以实现由原来不可中断的更新过程变成异步的可中断的更新。</p>
<p>Fiber 的数据结构主要长成以下的样子，主要通过 Fiber 的一些属性去保存组件相关的信息。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FiberNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">  tag: WorkTag,</span></span><br><span class="line"><span class="params">  pendingProps: mixed,</span></span><br><span class="line"><span class="params">  key: <span class="literal">null</span> | string,</span></span><br><span class="line"><span class="params">  mode: TypeOfMode</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 作为静态数据结构的属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">tag</span> = tag;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">elementType</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">type</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">stateNode</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于连接其他 Fiber 节点形成 Fiber 树</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">ref</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 作为动态的工作单元的属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pendingProps</span> = pendingProps;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedProps</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updateQueue</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">memoizedState</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dependencies</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">mode</span> = mode;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">effectTag</span> = <span class="title class_">NoEffect</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">nextEffect</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstEffect</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lastEffect</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调度优先级相关</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">childLanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向该 fiber 在另一次更新时对应的 fiber</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">alternate</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Fiber 主要靠以下属性连成一棵树结构的数据的，也就是 Fiber 链表。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指向父级 Fiber 节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">return</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 指向子 Fiber 节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">child</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 指向右边第一个兄弟 Fiber 节点</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">sibling</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></div></figure>

<p>举个例子，如下的组件结构：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      i am</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>Coboy<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>对应的 Fiber 链表结构：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/1a288abba50a46b28fa887b080ad8828_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>那么以上的 Fiber 链表的数据结构有什么特点，就是任何一个位置的 Fiber 节点，都可以非常容易知道它的父 Fiber, 第一个子元素的 Fiber,和它的兄弟节点 Fiber。却不容易知道它前一个 Fiber 节点是谁，这就是 React 中单向链表 Fiber 节点的特点。也正是因为这些即便在协调的过程被中断了，再恢复协调的时候，依然知道当前的 父节点和孩子节点等信息。</p>
<p>那么 React 是将对应组件怎么生成一个 Fiber 链表数据的呢？</p>

        <h1 id="Fiber-链表的生成"   >
          <a href="#Fiber-链表的生成" class="heading-link"><i class="fas fa-link"></i></a><a href="#Fiber-链表的生成" class="headerlink" title="Fiber 链表的生成"></a>Fiber 链表的生成</h1>
      <p>上面的组件在经过 JSX 的编译之后，初始化的时候会生成成一个类似于 React 15 或者 Vue 那种虚拟 DOM 的数据结构。然后创建一个叫 fiberRoot 的 Fiber 节点，然后开始从 fiberRoot 这个根 Fiber 开始进行协调，生成一棵 Fiber 树，这个棵树被称为：<code>workInProgress Fiber</code>树 ，意思是正在工作的 Fiber 树，接下来我们详细了解一下具体是怎么生成一棵 Fiber 树的。要先了解 Fiber 树的生成原理才更好去理解 Fiber 树 diff 的过程。</p>
<p>以下是一段简单版的 Fiber 链表生成的代码片段。这个协调子节点的函数接收两个参数，returnFiber 是父 Fiber，children 是这个节点的子元素的虚拟 DOM 数据。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个协调子节点的函数接收两个参数，returnFiber 是父 Fiber，children 是这个节点的子元素的虚拟 DOM 数据。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">reconcileChildren</span>(<span class="params">returnFiber, children</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果是字符串或者数字则不创建 Fiber</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isStringOrNumber</span>(children)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> newChildren = <span class="title function_">isArray</span>(children) ? children : [children];</span><br><span class="line">  <span class="comment">// 上一轮的 fiber 节点</span></span><br><span class="line">  <span class="keyword">let</span> previousNewFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 初次渲染（false）还是更新（true）</span></span><br><span class="line">  <span class="keyword">let</span> shouldTrackSideEffects = !!returnFiber.<span class="property">alternate</span>;</span><br><span class="line">  <span class="comment">// 老 Fiber 节点</span></span><br><span class="line">  <span class="keyword">let</span> oldFiber = returnFiber.<span class="property">alternate</span> &amp;&amp; returnFiber.<span class="property">alternate</span>.<span class="property">child</span>;</span><br><span class="line">  <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 上一次协调返回的位置</span></span><br><span class="line">  <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 记录每个 fiber 节点的位置</span></span><br><span class="line">  <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 如果不存在老 Fiber 则是初始化的过程，进行 Fiber 链表的创建</span></span><br><span class="line">  <span class="keyword">if</span> (!oldFiber) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.<span class="property">length</span>; newIdx++) &#123;</span><br><span class="line">      <span class="comment">// 获取节点元素内容</span></span><br><span class="line">      <span class="keyword">const</span> newChild = newChildren[newIdx];</span><br><span class="line">      <span class="comment">// 如果节点为 null 则不需要创建 fiber 节点</span></span><br><span class="line">      <span class="keyword">if</span> (newChild === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建新 fiber 的时候记录了关键的父 fiber 等重要信息</span></span><br><span class="line">      <span class="keyword">const</span> newFiber = <span class="title function_">createFiber</span>(newChild, returnFiber);</span><br><span class="line">      <span class="comment">// 记录当前每一个 fiber 的位置</span></span><br><span class="line">      lastPlacedIndex = <span class="title function_">placeChild</span>(</span><br><span class="line">        newFiber,</span><br><span class="line">        lastPlacedIndex,</span><br><span class="line">        newIdx,</span><br><span class="line">        shouldTrackSideEffects <span class="comment">// 初次渲染（false）还是更新（true）</span></span><br><span class="line">      );</span><br><span class="line">      <span class="comment">// 当上一轮的 fiber 节点为 null 的时候，这一轮的 fiber 就是头节点</span></span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 父 fiber 的 child 就是第一个节点</span></span><br><span class="line">        returnFiber.<span class="property">child</span> = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是第一个节点，那么就是兄弟节点</span></span><br><span class="line">        <span class="comment">// 上一轮 fiber 的兄弟节点是这一轮的 fiber 节点</span></span><br><span class="line">        previousNewFiber.<span class="property">sibling</span> = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 记录上一轮的 fiber，既是这一轮的 fiber 便是下一轮的上一轮 fiber</span></span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>构建完的<code>workInProgress Fiber</code>树 会在<code>commit</code>阶段 渲染到页面。</p>
<p>在组件状态数据发生变更的时候，会根据最新的状态数据先会生成新的虚拟 DOM，再去构建一棵新的<code>workInProgress Fiber</code>树 ，而在重新协调构建新的 Fiber 树的过程也就是 React Diff 发生的地方。接下来，我们就看看 React Diff 算法是怎么样的。</p>

        <h1 id="React-的-Diff-算法"   >
          <a href="#React-的-Diff-算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#React-的-Diff-算法" class="headerlink" title="React 的 Diff 算法"></a>React 的 Diff 算法</h1>
      <p>深度优先，有子节点，就遍历子节点，没有子节点，就找兄弟节点，没有兄弟节点，就找叔叔节点，叔叔节点也没有的话，就继续往上找，它爷爷的兄弟，如果一直没找到，就代表所有的更新任务都更新完毕了。</p>
<p><strong>重点是在更新自己的同时需要去协调子节点，也就是传说中进行 Diff 的地方。</strong></p>
<p>进入协调的时候它自己就是父 Fiber，它的子节点在协调之前，是刚刚通过更新的状态数据生成的最新的虚拟 DOM 数据，是个数组结构的元素数据。</p>
<p>那么要进行更新，就肯定是以为最新的节点数据为准了，又因为最新的节点数据是一个数组，所以可以进行循环对比每一个节点，很明显这个循环是从<strong>左向右进行查找比对</strong>的。</p>

        <h2 id="第一轮，常见情况的比对"   >
          <a href="#第一轮，常见情况的比对" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一轮，常见情况的比对" class="headerlink" title="第一轮，常见情况的比对"></a>第一轮，常见情况的比对</h2>
      <p>那么第一个节点的老 Fiber 怎么拿到呢？可以通过 父 Fiber 的 child 属性拿到，这样第一个节点的老 Fiber 就拿到了，那么第二节点的老 Fiber，很明显可以通过第一个节点的老 Fiber 节点的 sibling 属性拿到，后面的以此类推。</p>
<p>怎么比对呢？</p>
<p>在循环的新节点虚拟 DOM 数据的时候，拿到新节点虚拟 DOM 信息，然后就去和老 Fiber 节点进行比对，如果两个节点相同则创建一个新的 Fiber 节点并复用一些老 Fiber 节点的信息，比如真实 DOM，并给这个新的 Fiber 节点打上一个 Update 的标记，代表这个节点需要更新即可。</p>
<p>接着去更新协调位置信息。</p>
<p>在循环的最后进行 Fiber 链表的处理：</p>
<p>如果是头节点，则把新 Fiber 设置为父 Fiber 的 child 属性的值；<br>如果不是头节点，则把新 Fiber 设置为上一轮循环的创建的 Fiber 节点的 sibing 属性的值；更新上一轮 Fiber 变量的值，就是把这一轮的 Fiber 设置成下一轮的 Fiber;更新比对的老 Fiber 的值。</p>
<p>如果新节点都能找到能复用的节点，则判断是否还存在老节点，有则删除。</p>

        <h2 id="第二轮，不常见的情况的比对"   >
          <a href="#第二轮，不常见的情况的比对" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二轮，不常见的情况的比对" class="headerlink" title="第二轮，不常见的情况的比对"></a>第二轮，不常见的情况的比对</h2>
      <p>如果经过第一轮比对，新节点还存在未比对的，则继续循环查找。</p>
<p>先将剩下未比对的老 Fiber 节点全部处理成一个 老 Fiber 的 key 或老 Fiber 的 index 为 key，Fiber 节点为 value 的 Map 中，这样就可以，以 O(1) 复杂度，通过新 Fiber 的 key 去 Map 对象中查找匹配的 Fiber，找到了，则删除 Map 对象中的老 Fiber 数据，然后复用匹配到的 Fiber 数据。</p>
<p>接下来，不管有没有匹配到都进行位置协调，记录最新的位置信息，新增的 Fiber 因为没有存在老 Fiber 而会被打上 Placement 的标记，在将来提交的阶段将会被进行新增操作。这个过程跟第一轮最后的处理是一样的。</p>
<p>在循环的最后进行 Fiber 链表的处理：</p>
<p>如果是头节点，则把新 Fiber 设置为父 Fiber 的 child 属性的值；<br>如果不是头节点，则把新 Fiber 设置为上一轮循环的创建的 Fiber 节点的 sibing 属性的值；更新上一轮 Fiber 变量的值，就是把这一轮的 Fiber 设置成下一轮的 Fiber；更新比对的老 Fiber 的值。</p>

        <h2 id="重点如何协调更新位置信息"   >
          <a href="#重点如何协调更新位置信息" class="heading-link"><i class="fas fa-link"></i></a><a href="#重点如何协调更新位置信息" class="headerlink" title="重点如何协调更新位置信息"></a>重点如何协调更新位置信息</h2>
      <p>如果是初始渲染，那么协调位置就只是记录当前元素下标的位置到 Fiber 节点上。如果是更新阶段，就先判断有没有老 Fiber 节点，如果没有老 Fiber 节点，则说明该节点需要创建，就给当前新的 Fiber 节点打上一个 Placement 的标记，如果有老 Fiber 节点，则判断老 Fiber 节点的位置是否比上一次协调的返回的位置小，如果是，则说明该节点需要移动，给新 Fiber 节点打上一个 Placement 的标记，并继续返回上一次协调返回的位置；如果老 Fiber 节点的位置大或者等于上一次协调返回的位置，则说明该节点不需要进行位置移动操作，就返回老 Fiber 的位置即可。</p>
<p>这里需要说明的一点，为什么移动和新增节点都是 Placement 的标记呢？</p>
<p>因为我们是在协调一个子节点列表，所以不管是新增还是移动都是属于位置是需要发生变化的，所以新增和移动都是同一种操作情况。</p>

        <h2 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h2>
      <p>总个来说，React Diff 算法分以下几个步骤：</p>
<ol>
<li>第一轮，从左向右新老节点进行比对查找能复用的旧节点，如果有新老节点比对不成功的，则停止这一轮的比对，并记录了停止的位置。</li>
<li>如果第一轮比对，能把所有的新节点都比对完毕，则删除旧节点还没进行比对的节点。</li>
<li>如果第一轮的比对，没能将所有的新节点都比对完毕，则继续从第一轮比对停止的位置继续开始循环新节点，拿每一个新节点去老节点里面进行查找，有匹配成功的则复用，没匹配成功的则在协调位置的时候打上 Placement 的标记。</li>
<li>在所有新节点比对完毕之后，检查还有没有没进行复用的旧节点，如果有，则全部删除。</li>
</ol>

        <h1 id="图文解释-React-Diff-算法"   >
          <a href="#图文解释-React-Diff-算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#图文解释-React-Diff-算法" class="headerlink" title="图文解释 React Diff 算法"></a>图文解释 React Diff 算法</h1>
      <p>接下来我们使用图文进行 React Diff 算法讲解，希望可以更进一步了解 React 的 Diff 算法。</p>

        <h2 id="最简单的-Diff-场景"   >
          <a href="#最简单的-Diff-场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#最简单的-Diff-场景" class="headerlink" title="最简单的 Diff 场景"></a>最简单的 Diff 场景</h2>
      <p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/16b1e863962145b697c2ca46a0b3f78e_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>上图的 Diff 场景是最简单的一种，新虚拟 DOM 从左到右都能和老 Fiber 的节点一一匹配成功，协调位置的时候，老 Fiber A 的位置是 0，默认上一次协调返回的位置也是 0，根据协调位置规则，老 Fiber 的位置不比上一次协调返回的位置小，则只需要返回老 Fiber A 的位置 0 即可；到了 B 进行协调位置的时候，老 Fiber B 位置 1 不比上一次协调返回的位置 0 小，则只需返回老 Fiber B 的位置 1 即可；到了 C 进行协调位置的时候，老 Fiber C 位置 2 不比上一次协调返回的位置 1 小，则只需要返回老 Fiber C 的位置 2 即可；</p>
<p>最后全部的新虚拟 DOM 比对完毕，但老 Fiber 上还存在节点信息，则需要将剩下的老 Fiber 进行删除标记。</p>
<p>接下来我们看看复杂的 Diff 场景。</p>

        <h2 id="复杂的-Diff-场景"   >
          <a href="#复杂的-Diff-场景" class="heading-link"><i class="fas fa-link"></i></a><a href="#复杂的-Diff-场景" class="headerlink" title="复杂的 Diff 场景"></a>复杂的 Diff 场景</h2>
      <p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/c64e51345d234cac87538fa2c980ae9f_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>在上图中，第一轮循环比对的时候，新虚拟节点 A 和第一个老 Fiber 节点是可以匹配的，所以就可以复用老 Fiber 的节点信息了，并且在协调的位置信息的时候，是存在老 Fiber 的，那么就去比较老 Fiber 的位置和上一次协调返回的位置进行比较（上一次协调返回的位置默认为 0），老 Fiber 的位置是等于新 Fiber 的位置，根据协调规则，位置不需要移动，返回老 Fiber 的位置信息即可，很明显这次返回的协调位置是 0。</p>
<p>到了第二个新虚拟节点 C 的时候，C 和老 Fiber 中的 B 是不匹配的，则第一轮比对结束。</p>
<p>第一轮比对结束之后，新虚拟 DOM 是还存在未比对的节点的，那么继续开始第二轮的比对。</p>
<p>在第二轮比对开始之前，会先将剩下未比对的老 Fiber 节点全部处理成一个 老 Fiber 的 key 或老 Fiber 的 index 为 key，Fiber 节点为 value 的 Map 中。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/c47d858bbaea45dc85a33fccd08166f8_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>然后进行第二轮的比对。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/759a187018fc42cfb6a03ca305558815_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>虚拟 DOM C 可以通过 C 的 key 值在老 Fiber 的 Map 中找到老 Fiber C 节点，这个时候会 C 进行暂存，然后把 Map 中的 C 进行删除，再进行老 Fiber 的节点信息复用，然后去协调比对位置信息。</p>
<p>老 Fiber C 的位置是 2，然后上一次新 Fiber A 协调比对返回的位置信息是 0，那么这一次协调的位置是老 Fiber 的位置比上一次协调返回的位置大，那么这次协调是不用标记 Placement 标记的，直接返回老 Fiber C 的位置 2。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/42ffcd9248b849d7be239e8c6c3f2f04_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>虚拟 DOM E，在老 Fiber 的 Map 中是没有匹配成功的，所以在创建 Fiber E 的时候，是没有进行老 Fiber 的复用的，去协调比对位置的时候，根据协调位置规则，没有老 Fiber，就标记 Placement 并返回上一次协调返回的位置，那么上一次 C 协调位置返回的位置信息是 2，这一次 E 协调位置依然返回 2。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/3c94f4eae88347c593a6ccdd0297820d_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>虚拟 DOM B 也在 Fiber 的 Map 中匹配成功了，那么匹配成功之后，就对老 Fiber B 进行暂存，然后删除老 Fiber B,再进行信息复用，然后又进行位置协调，老 Fiber B 的位置是 1，上一次协调返回的位置是 2，根据协调位置规则，老 Fiber 的位置小于上一次协调返回的位置，则标记 Placement 并返回上一次协调返回的位置 2。</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/b7eda9e4bd00443ca4d703f4aaaffc1b_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>最后，老 Fiber 的 Map 中还存在一个 D 节点没处理，则需要对其进行删除标记操作。<br>最终新 Fiber 将被协调成下面的样子：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/7cd0844cbe0641a68046416a0981efdd_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp"></p>
<p>那么根据图片，我们又可以得出一个结论，匹配到的老 Fiber 如果和新 Fiber 相同或者在新 Fiber 位置的右边则不需要进行移动标记。</p>

        <h1 id="Vue3-的-Diff-算法"   >
          <a href="#Vue3-的-Diff-算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#Vue3-的-Diff-算法" class="headerlink" title="Vue3 的 Diff 算法"></a>Vue3 的 Diff 算法</h1>
      <p>在我看来 Vue3 的 Diff 算法是 Vue2、Vue3、React 的 Diff 算法中最复杂的一种。下面我们来简单说一下 Vue3 的 Diff 算法，只说数组和数组比对的情况。</p>

        <h2 id="第一轮，常见情况的比对-1"   >
          <a href="#第一轮，常见情况的比对-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一轮，常见情况的比对-1" class="headerlink" title="第一轮，常见情况的比对"></a>第一轮，常见情况的比对</h2>
      <p>首先从左往右进行比对，如果是相同的就进行更新比对，如果不相同则停止比对，并且记录停止的下标。</p>
<p>再从右往左进行比对，如果是相同的就进行更新比对，如果不相同也停止比对，也进行记录停止的下标。</p>
<p>通过这样左右进行比对，最后就可以把真正复杂部分进行范围锁定了。</p>
<p>左右比对完之后，如果新节点已经比对完了，老节点列表还存在节点未比对，则删除老节点列表上的未比对的节点，如果老节点已经比对完了，新节点列表还存在未比对的节点则进行创建。</p>

        <h2 id="第二轮，复杂情况的比对"   >
          <a href="#第二轮，复杂情况的比对" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二轮，复杂情况的比对" class="headerlink" title="第二轮，复杂情况的比对"></a>第二轮，复杂情况的比对</h2>
      <p>如果新节点未比对完，老节点也未比对完，则进行最后最复杂的处理。</p>
<p>先把剩下的新节点处理成节点的 key 为 key, 节点下标为 value 的 Map；接着初始化一个长度为剩下未比对的新节点的长度的数组 newIndexToOldIndexMap，初始化每个数组的下标的默认值为 0。再循环剩下的旧节点，通过旧节点的 key 去刚刚创建的 Map 中查找，看看旧节点有没有在新节点中，如果旧节点没有 key 则需要通过循环剩下的新节点进行查找。如果旧节点在新节点中没找到，则说明该旧节点需要进行删除。如果找到了，则把找到的新节点的下标对应存储到上述的数组 newIndexToOldIndexMap 中，然后更新比对匹配到的新老节点。</p>
<p>把所有的旧节点比对完成后，就会得到一个刚刚收集的新节点的下标数组，然后对这个新节点的下标数组进行进行最长递增子序列查找得到一个最长递增子序列的下标数据。然后再进行循环左右对比完之后剩余新节点的下标，然后判断循环的下标是否被上述的数组 newIndexToOldIndexMap 进行收集了，如果没被收集到则说明这个新节点需要进行创建，如果已经被收集了则判断该循环的下标是否在上面计算得到的最长递增子序列中，如果不在则需要对该循环节点进行移动操作。</p>
<p>以上就是 Vue3 Diff 算法大概过程了。</p>

        <h1 id="Vue2-的-Diff-算法"   >
          <a href="#Vue2-的-Diff-算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#Vue2-的-Diff-算法" class="headerlink" title="Vue2 的 Diff 算法"></a>Vue2 的 Diff 算法</h1>
      <p>Vue2 的 Diff 算法就是以新的虚拟 DOM 为准进行与老虚拟 DOM 的比对，继而进行各种情况的处理。大概可以分为 4 种情况：更新节点、新增节点、删除节点、移动节点位置。比对新老两个虚拟 DOM，就是通过循环，每循环到一个新节点，就去老节点列表里面找到和当前新节点相同的旧节点。如果在旧节点列表中找不到，说明当前节点是需要新增的节点，我们就需要进行创建节点并插入视图的操作；如果找到了，就做更新操作；如果找到的旧节点与新节点位置不同，则需要移动节点等。</p>

        <h2 id="第一轮，简单情况的比对"   >
          <a href="#第一轮，简单情况的比对" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一轮，简单情况的比对" class="headerlink" title="第一轮，简单情况的比对"></a>第一轮，简单情况的比对</h2>
      <p>其中为了快速查找到节点，Vue2 的 Diff 算法设置了 4 种优化策略，分别是：</p>
<ol>
<li>老数组的开始与新数组的开始</li>
<li>老数组的结尾与新数组的结尾</li>
<li>老数组的开始与新数组的结尾</li>
<li>老数组的结尾与新数组的开始</li>
</ol>
<p>通过这 4 种快捷的查找方式，我们就不需要循环来查找了，只有当以上 4 种方式都查找不到的时候，再进行循环查找。</p>

        <h2 id="第二轮，不常见的情况的比对-1"   >
          <a href="#第二轮，不常见的情况的比对-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二轮，不常见的情况的比对-1" class="headerlink" title="第二轮，不常见的情况的比对"></a>第二轮，不常见的情况的比对</h2>
      <p>最后循环结束后需要对未处理的节点进行处理。</p>
<p>如果是老节点列表先循环完毕，这个时候如果新节点列表还有剩余的节点，则说明这些节点都是需要新增的节点，直接把这些节点创建并插入到 DOM 中就行了。</p>
<p>如果是新节点列表先循环完毕，这个时候如果老节点列表还有剩余节点，则说明这些节点都是要被废弃的节点，是应该被删除的节点，直接批量删除就可以了。</p>

        <h1 id="React、Vue3、Vue2-的-Diff-算法对比"   >
          <a href="#React、Vue3、Vue2-的-Diff-算法对比" class="heading-link"><i class="fas fa-link"></i></a><a href="#React、Vue3、Vue2-的-Diff-算法对比" class="headerlink" title="React、Vue3、Vue2 的 Diff 算法对比"></a>React、Vue3、Vue2 的 Diff 算法对比</h1>
      
        <h2 id="相同点"   >
          <a href="#相同点" class="heading-link"><i class="fas fa-link"></i></a><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2>
      <p>只有使用了虚拟 DOM 的这些框架，在进行更新 Diff 对比的时候，都是优先处理简单的场景，再处理复杂的场景。</p>
<p>React 中是先处理左边部分，左边部分处理不了，再进行复杂部分的处理；Vue2 则先进行首尾、首首、尾尾部分的处理，然后再进行中间复杂部分的处理；Vue3 则先处理首尾部分，然后再处理中间复杂部分，Vue2 和 Vue3 最大的区别就是在处理中间复杂部分使用了最长递增子序列算法找出稳定序列的部分。</p>
<p>在处理老节点部分，都需要把节点处理 key - value 的 Map 数据结构，方便在往后的比对中可以快速通过节点的 key 取到对应的节点。同样在比对两个新老节点是否相同时，key 是否相同也是非常重要的判断标准。所以不同是 React, 还是 Vue，在写动态列表的时候，都需要设置一个唯一值 key，这样在 diff 算法处理的时候性能才最大化。</p>
<p>在移动或者创建节点的时候都使用了<code>insertBefore(newnode,existingnode)</code>这个 API：</p>
<ol>
<li>newnode 必需。需要插入的节点对象。</li>
<li>existingnode 可选。在其之前插入新节点的子节点。如果未规定，则 insertBefore 方法会在结尾插入 newnode。</li>
</ol>

        <h2 id="不同点"   >
          <a href="#不同点" class="heading-link"><i class="fas fa-link"></i></a><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2>
      <p>对静态节点的处理不一样。</p>
<p>由于 Vue 是通过 template 模版进行编译的，所以在编译的时候可以很好对静态节点进行分析然后进行打补丁标记，然后在 Diff 的时候，Vue2 是判断如果是静态节点则跳过过循环对比，而 Vue3 则是把整个静态节点进行提升处理，Diff 的时候是不过进入循环的，所以 Vue3 比 Vue2 的 Diff 性能更高效。而 React 因为是通过 JSX 进行编译的，是无法进行静态节点分析的，所以 React 在对静态节点处理这一块是要逊色的。</p>
<p>Vue2 和 Vue3 的比对和更新是同步进行的，这个跟 React15 是相同的，就是在比对的过程中，如果发现了那些节点需要移动或者更新或删除，是立即执行的，也就是 React 中常讲的不可中断的更新，如果比对量过大的话，就会造成卡顿，所以 React16 起就更改为了比对和更新是异步进行的，所以 React16 以后的 Diff 是可以中断，Diff 和任务调度都是在内存中进行的，所以即便中断了，用户也不会知道。</p>
<p>另外 Vue2 和 Vue3 都使用了双端对比算法，而 React 的 Fiber 由于是单向链表的结构，所以在 React 不设置由右向左的链表之前，都无法实现双端对比。那么双端对比目前 React 的 Diff 算法要好吗？接下来我们来看看一个例子，看看它分别在 React、Vue2、Vue3 中的是怎么处理的。</p>
<p>比如说我们现在有以下两组新老节点：</p>
<p>老：A, B, C, D<br>新：D, A, B, C</p>
<p>那么我们可以看到，新老两组节点唯一的不同点就是，D 节点在新的节点中跑到开头去了，像这种情况：</p>
<p>React 是从左向右进行比对的，在上述这种情况，React 需要把 A, B, C 三个节点分别移动到 D 节点的后面。</p>
<p>Vue2 在进行老节点的结尾与新节点的开始比对的时候，就发现这两个节点是相同的，所以直接把老节点结尾的 D 移动到新节点开头就行了，剩下的就只进行老节点的开始与新节点的开始进行比对，就可以发现它们的位置并没有发生变化，不需要进行移动。</p>
<p>Vue3 是没有了 Vue2 的新老首尾节点进行比较，只是从两组节点的开头和结尾进行比较，然后往中间靠拢，那么 Vue3 在进行新老节点的开始和结尾比对的时候，都没有比对成功，接下来就进行中间部分的比较，先把老节点处理成 key - value 的 Map 数据结构，然后又使用最长递增子序列算法找出其中的稳定序列部分，也就是：A, B, C，然再对新节点进行循环比对，然后就会发现新节点的 A, B, C 都在稳定序列部分，不需要进行移动，然就只对 D，进行移动即可。</p>
<p>最后上述的例子在 Vue2 和 Vue3 中都只需要移动一个节点就可以完成 Diff 算法比对，而 React 在这种极端例子中则没办法进行很好的优化，需要进行多次节点移动操作。</p>

        <h1 id="为什么-Vue-中不需要使用-Fiber"   >
          <a href="#为什么-Vue-中不需要使用-Fiber" class="heading-link"><i class="fas fa-link"></i></a><a href="#为什么-Vue-中不需要使用-Fiber" class="headerlink" title="为什么 Vue 中不需要使用 Fiber"></a>为什么 Vue 中不需要使用 Fiber</h1>
      <p>其实这个问题也可以叫做：为什么 Vue 不需要时间分片？对于这个问题其实尤雨溪也在英文社区里回答过，也有前端大牛翻译发布在公众号上，那么下面我也进行一下总结。</p>
<ol>
<li><p>首先时间分片是为了解决 CPU 进行大量计算的问题，因为 React 本身架构的问题，在默认的情况下更新会进行过多的计算，就算使用 React 提供的性能优化 API，进行设置，也会因为开发者本身的问题，依然可能存在过多计算的问题。</p>
</li>
<li><p>而 Vue 通过响应式依赖跟踪，在默认的情况下可以做到只进行组件树级别的更新计算，而默认下 React 是做不到的（据说 React 已经在进行这方面的优化工作了），再者 Vue 是通过 template 进行编译的，可以在编译的时候进行非常好的性能优化，比如对静态节点进行静态节点提升的优化处理，而通过 JSX 进行编译的 React 是做不到的。</p>
</li>
<li><p>React 为了解决更新的时候进行过多计算的问题引入了时间分片，但同时又带来了额外的计算开销，就是任务协调的计算，虽然 React 也使用最小堆等的算法进行优化，但相对 Vue 还是多了额外的性能开销，因为 Vue 没有时间分片，所以没有这方面的性能担忧。</p>
</li>
<li><p>根据研究表明，人类的肉眼对 100 毫秒以内的时间并不敏感，所以时间分片只对于处理超过 100 毫秒以上的计算才有很好的收益，而 Vue 的更新计算是很少出现 100 毫秒以上的计算的，所以 Vue 引入时间分片的收益并不划算。</p>
</li>
</ol>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>我们先由 “ React 的 Diff 算法为什么不采用 Vue 的双端对比的 Diff 算法？” 这个问题引出对 React 中的一些知识点的学习理解，比如什么是 Fiber，Fiber 链表是如何生成的，然后详细解析了 React Diff 算法，还对 React Diff 算法进行图文并茂解析，让我们可以更加理解 React 的 Diff 算法。其后，我们又简单介绍了 Vue3 和 Vue2 的 Diff 算法，之后对 React、Vue3、Vue2 之间的算法的异同进行了讲解。最后我们又总结了一下尤雨溪对 “为什么 Vue 不需要时间分片？” 这个问题的解析。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/React%20hooks%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">React hooks 源码解析</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-04-15</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>本文将讲解 hooks 的执行过程以及常用的 hooks 的源码。</p>

        <h1 id="hooks-相关数据结构"   >
          <a href="#hooks-相关数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#hooks-相关数据结构" class="headerlink" title="hooks 相关数据结构"></a>hooks 相关数据结构</h1>
      <p>要理解 hooks 的执行过程，首先想要大家对 hooks 相关的数据结构有所了解，便于后面大家顺畅地阅读代码。</p>

        <h2 id="Hook"   >
          <a href="#Hook" class="heading-link"><i class="fas fa-link"></i></a><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2>
      <p>每一个 hooks 方法都会生成一个类型为 Hook 的对象，用来存储一些信息，前面提到过函数组件 fiber 中的 memoizedState 会存储 hooks 链表，每个链表结点的结构就是 Hook。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Hook</span> = &#123;|</span><br><span class="line">  <span class="attr">memoizedState</span>: any, <span class="comment">// 上次渲染时所用的 state</span></span><br><span class="line">  <span class="attr">baseState</span>: any, <span class="comment">// 已处理的 update 计算出的 state</span></span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="title class_">Update</span>&lt;any, any&gt; | <span class="literal">null</span>, <span class="comment">// 未处理的 update 队列（一般是上一轮渲染未完成的 update）</span></span><br><span class="line">  <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;any, any&gt; | <span class="literal">null</span>, <span class="comment">// 当前出发的 update 队列</span></span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Hook</span> | <span class="literal">null</span>, <span class="comment">// 指向下一个 hook，形成链表结构</span></span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></div></figure>

<p>举个例子，我们通过函数组件使用了两个 useState hooks：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&quot;小科比&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> [age, setAge] = <span class="title function_">useState</span>(<span class="number">23</span>);</span><br></pre></td></tr></table></div></figure>

<p>则实际的 Hook 结构如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">next</span>: &#123;</span><br><span class="line">    <span class="attr">memoizedState</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">baseState</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>不同的 hooks 方法，memoizedState 存储的内容不同，常用的 hooks memoizedState 存储的内容如下：</p>
<ul>
<li>useState: state</li>
<li>useEffect: effect 对象</li>
<li>useMemo&#x2F;useCallback: [callback, deps]</li>
<li>useRef: { current: xxx }</li>
</ul>

        <h2 id="Update-amp-UpdateQueue"   >
          <a href="#Update-amp-UpdateQueue" class="heading-link"><i class="fas fa-link"></i></a><a href="#Update-amp-UpdateQueue" class="headerlink" title="Update &amp; UpdateQueue"></a>Update &amp; UpdateQueue</h2>
      <p>Update 和 UpdateQueue 是存储 useState 的 state 及 useReducer 的 reducer 相关内容的数据结构。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line">type <span class="title class_">Update</span>&lt;S, A&gt; = &#123;|</span><br><span class="line">  <span class="attr">lane</span>: <span class="title class_">Lane</span>, <span class="comment">// 优先级</span></span><br><span class="line">  <span class="comment">// reducer 对应要执行的 action</span></span><br><span class="line">  <span class="attr">action</span>: A,</span><br><span class="line">  <span class="comment">// 触发 dispatch 时的 reducer</span></span><br><span class="line">  <span class="attr">eagerReducer</span>: (<span class="function">(<span class="params">S, A</span>) =&gt;</span> S) | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 触发 dispatch 是的 state</span></span><br><span class="line">  <span class="attr">eagerState</span>: S | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 下一个要执行的 Update</span></span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Update</span>&lt;S, A&gt;,</span><br><span class="line">  <span class="comment">// react 的优先级权重</span></span><br><span class="line">  priority?: <span class="title class_">ReactPriorityLevel</span>,</span><br><span class="line">|&#125;;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">UpdateQueue</span>&lt;S, A&gt; = &#123;|</span><br><span class="line">  <span class="comment">// 当前要触发的 update</span></span><br><span class="line">  <span class="attr">pending</span>: <span class="title class_">Update</span>&lt;S, A&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 存放 dispatchAction.bind() 的值</span></span><br><span class="line">  <span class="attr">dispatch</span>: (<span class="function">(<span class="params">A</span>) =&gt;</span> mixed) | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 上一次 render 的 reducer</span></span><br><span class="line">  <span class="attr">lastRenderedReducer</span>: (<span class="function">(<span class="params">S, A</span>) =&gt;</span> S) | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 上一次 render 的 state</span></span><br><span class="line">  <span class="attr">lastRenderedState</span>: S | <span class="literal">null</span>,</span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></div></figure>

<p>每次调用 setState 或者 useReducer 的 dispatch 时，都会生成一个 Update 类型的对象，并将其添加到 UpdateQueue 队列中。<br>例如，在如下的函数组件中:</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&quot;小科比&quot;</span>);</span><br><span class="line"><span class="title function_">setName</span>(<span class="string">&quot;大科比&quot;</span>);</span><br></pre></td></tr></table></div></figure>

<p>当我们点击 input 按钮时，执行了 setName()，此时对应的 hook 结构如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">queue</span>: &#123;</span><br><span class="line">    <span class="attr">pending</span>: &#123;</span><br><span class="line">      <span class="attr">lane</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">action</span>: <span class="string">&#x27;大科比&#x27;</span>,</span><br><span class="line">      <span class="attr">eagerState</span>: <span class="string">&#x27;大科比&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">lastRenderedState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>最后 react 会遍历 UpdateQueue 中的每个 Update 去进行更新。</p>

        <h2 id="Effect"   >
          <a href="#Effect" class="heading-link"><i class="fas fa-link"></i></a><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h2>
      <p>Effect 结构是和 useEffect 等 hooks 相关的，我们看一下它的结构：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Effect</span> = &#123;|</span><br><span class="line">  <span class="attr">tag</span>: <span class="title class_">HookFlags</span>, <span class="comment">// 标记是否有 effect 需要执行</span></span><br><span class="line">  <span class="attr">create</span>: <span class="function">() =&gt;</span> (<span class="function">() =&gt;</span> <span class="keyword">void</span>) | <span class="keyword">void</span>, <span class="comment">// 回调函数</span></span><br><span class="line">  <span class="attr">destroy</span>: (<span class="function">() =&gt;</span> <span class="keyword">void</span>) | <span class="keyword">void</span>, <span class="comment">// 销毁时触发的回调</span></span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span>, <span class="comment">// 依赖的数组</span></span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Effect</span>, <span class="comment">// 下一个要执行的 Effect</span></span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></div></figure>

<p>当我们的函数组件中使用了如下的 useEffect 时：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></div></figure>

<p>对应的 Hook 如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: &#123;</span><br><span class="line">    <span class="attr">create</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>) &#125;,</span><br><span class="line">    <span class="attr">destroy</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bye&#x27;</span>) &#125;,</span><br><span class="line">    <span class="attr">deps</span>: [],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">baseState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="执行过程"   >
          <a href="#执行过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1>
      <p>下面我们探索一下 hooks 在 react 中具体的执行流程。<br>引入 hooks<br>我们以一个简单的 hooks 写法的 react 应用程序为例去寻找 hooks 源码:</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&quot;增加&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          setCount(count + 1);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>根据引入的 useState api，我们找到 react hooks 的入口文件：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react/src/ReactHooks.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveDispatcher</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> useState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = <span class="title function_">resolveDispatcher</span>();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.<span class="title function_">useState</span>(initialState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></div></figure>

<p>根据上面的源码我们可以知道，所有的 hooks api 都是挂载在 resolveDispatcher 中返回的 dispatcher 对象上面的，也就是挂载在 ReactCurrentDispatcher.current 上面，那么我们再继续去看一下 ReactCurrentDispatcher 是什么：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react/src/ReactCurrentDispatcher.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> type &#123; <span class="title class_">Dispatcher</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-reconciler/src/ReactInternalTypes&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReactCurrentDispatcher</span> = &#123;</span><br><span class="line">  <span class="attr">current</span>: (<span class="attr">null</span>: <span class="literal">null</span> | <span class="title class_">Dispatcher</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ReactCurrentDispatcher</span>;</span><br></pre></td></tr></table></div></figure>

<p>到这里我们的线索就断了，ReactCurrentDispatcher 上只有一个 current 用于挂在 hooks，但是 hooks 的详细源码以及 ReactCurrentDispatcher 的具体内容我们并没有找到在哪里，所以我们只能另寻出路，从 react 的执行过程去入手。</p>

        <h2 id="函数组件更新过程"   >
          <a href="#函数组件更新过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数组件更新过程" class="headerlink" title="函数组件更新过程"></a>函数组件更新过程</h2>
      <p>我们的 hooks 都是在函数组件中使用的，所以让我们去看一下 render 过程关于函数组件的更新。render 过程中的调度是从 beginWork 开始的，来到 beginWork 的源码后我们可以发现，针对函数组件的渲染和更新，使用了 updateFunctionComponent 函数：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberBeginWork.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>: &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateFunctionComponent</span>(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        <span class="title class_">Component</span>,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>那我们在继续看一下 updateFunctionComponent 函数的源码，里面调用了 renderWithHooks 函数，这便是函数组件更新和渲染过程执行的入口：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberBeginWork.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateFunctionComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current,</span></span><br><span class="line"><span class="params">  workInProgress,</span></span><br><span class="line"><span class="params">  Component,</span></span><br><span class="line"><span class="params">  nextProps: any,</span></span><br><span class="line"><span class="params">  renderLanes</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  nextChildren = <span class="title function_">renderWithHooks</span>(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    <span class="title class_">Component</span>,</span><br><span class="line">    nextProps,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="renderWithHooks"   >
          <a href="#renderWithHooks" class="heading-link"><i class="fas fa-link"></i></a><a href="#renderWithHooks" class="headerlink" title="renderWithHooks"></a>renderWithHooks</h2>
      <p>费劲千辛万苦，我们终于来到了函数组件更新过程的执行入口 —— renderWithHooks 函数的源码：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberBeginWork.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> renderWithHooks&lt;<span class="title class_">Props</span>, <span class="title class_">SecondArg</span>&gt;(</span><br><span class="line">  <span class="attr">current</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">workInProgress</span>: <span class="title class_">Fiber</span>,</span><br><span class="line">  <span class="title class_">Component</span>: <span class="function">(<span class="params">p: Props, arg: SecondArg</span>) =&gt;</span> any,</span><br><span class="line">  <span class="attr">props</span>: <span class="title class_">Props</span>,</span><br><span class="line">  <span class="attr">secondArg</span>: <span class="title class_">SecondArg</span>,</span><br><span class="line">  <span class="attr">nextRenderLanes</span>: <span class="title class_">Lanes</span>,</span><br><span class="line">): any &#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  <span class="comment">// currentlyRenderingFiber 指向当前所执行的 fiber</span></span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 置空 workInProgress fiber 中的 memoizedState 和 updateQueue</span></span><br><span class="line">  workInProgress.<span class="property">memoizedState</span> = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.<span class="property">updateQueue</span> = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 根据是否首次渲染，分别将 HooksDispatcherOnMount 和 HooksDispatcherOnUpdate 赋值给 ReactCurrentDispatcher.current</span></span><br><span class="line">  <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> =</span><br><span class="line">  current === <span class="literal">null</span> || current.<span class="property">memoizedState</span> === <span class="literal">null</span></span><br><span class="line">  ? <span class="title class_">HooksDispatcherOnMount</span></span><br><span class="line">  : <span class="title class_">HooksDispatcherOnUpdate</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行函数组件的构造函数</span></span><br><span class="line">  <span class="keyword">let</span> children = <span class="title class_">Component</span>(props, secondArg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (didScheduleRenderPhaseUpdateDuringThisPass) &#123;</span><br><span class="line">    <span class="comment">// didScheduleRenderPhaseUpdateDuringThisPass 为 true 说明发生了 re-render，会再次执行 render</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">numberOfReRenders</span>: number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      didScheduleRenderPhaseUpdateDuringThisPass = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = **<span class="variable constant_">DEV</span>**</span><br><span class="line">      ? <span class="title class_">HooksDispatcherOnRerenderInDEV</span></span><br><span class="line">      : <span class="title class_">HooksDispatcherOnRerender</span>;</span><br><span class="line"></span><br><span class="line">      children = <span class="title class_">Component</span>(props, secondArg);</span><br><span class="line">    &#125; <span class="keyword">while</span> (didScheduleRenderPhaseUpdateDuringThisPass);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 函数执行结束后，关闭 hooks 入口</span></span><br><span class="line">  <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">ContextOnlyDispatcher</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...当前 fiber 的任务执行结束，重置全局变量</span></span><br><span class="line"></span><br><span class="line">  renderLanes = <span class="title class_">NoLanes</span>;</span><br><span class="line">  currentlyRenderingFiber = (<span class="attr">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><code>renderWithHooks</code>函数中首先会将 workInProgress fiber 树的 memoizedState（前面深入理解 fiber 一文中提到过，memoizedState 记录了当前页面的 state，在函数组件中，它以链表的形式记录了 hooks 信息） 和 updateQueue 置为 null，在接下来的函数组件执行过程中，会把新的 hooks 信息挂载到这两个属性上，然后在 commit 阶段，会将根据 current fiber 树构建当前的 workInProgress fiber 树，并保存 hooks 信息，用于替换真实的 DOM 元素节点。<br>然后会通过 current 上是否有 memoizedState，判断组件是否首次渲染，从而分别将 HooksDispatcherOnMount 和 HooksDispatcherOnUpdate 赋值给 <code>ReactCurrentDispatcher.current</code>。<br>接下来执行<code>Component()</code>来调用函数组件的构造函数，组件的 hooks 会被依次执行，并将 hooks 的信息保存到 workInProgress fiber 上（待会儿会细讲执行过程），然后将返回的 jsx 信息保存到 children 上。<br>最后会重置一些变量，并返回函数组件执行后的 jsx。</p>

        <h2 id="不同阶段更新-Hook"   >
          <a href="#不同阶段更新-Hook" class="heading-link"><i class="fas fa-link"></i></a><a href="#不同阶段更新-Hook" class="headerlink" title="不同阶段更新 Hook"></a>不同阶段更新 Hook</h2>
      <p>现在我们终于找到了<code>ReactCurrentDispatcher.current</code>的定义，首次渲染时，会将 <code>HooksDispatcherOnMount</code>赋值给 <code>ReactCurrentDispatcher.current</code>，更新时，会将<code>HooksDispatcherOnUpdate</code> 赋值给 <code>ReactCurrentDispatcher.current</code>， dispatcher 上面挂在了各种 hooks：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  <span class="attr">useCallback</span>: mountCallback,</span><br><span class="line">  <span class="attr">useContext</span>: readContext,</span><br><span class="line">  <span class="attr">useEffect</span>: mountEffect,</span><br><span class="line">  <span class="attr">useImperativeHandle</span>: mountImperativeHandle,</span><br><span class="line">  <span class="attr">useLayoutEffect</span>: mountLayoutEffect,</span><br><span class="line">  <span class="attr">useMemo</span>: mountMemo,</span><br><span class="line">  <span class="attr">useReducer</span>: mountReducer,</span><br><span class="line">  <span class="attr">useRef</span>: mountRef,</span><br><span class="line">  <span class="attr">useState</span>: mountState,</span><br><span class="line">  <span class="attr">useDebugValue</span>: mountDebugValue,</span><br><span class="line">  <span class="attr">useDeferredValue</span>: mountDeferredValue,</span><br><span class="line">  <span class="attr">useTransition</span>: mountTransition,</span><br><span class="line">  <span class="attr">useMutableSource</span>: mountMutableSource,</span><br><span class="line">  <span class="attr">useOpaqueIdentifier</span>: mountOpaqueIdentifier,</span><br><span class="line"></span><br><span class="line">  <span class="attr">unstable_isNewReconciler</span>: enableNewReconciler,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnUpdate</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  <span class="attr">useCallback</span>: updateCallback,</span><br><span class="line">  <span class="attr">useContext</span>: readContext,</span><br><span class="line">  <span class="attr">useEffect</span>: updateEffect,</span><br><span class="line">  <span class="attr">useImperativeHandle</span>: updateImperativeHandle,</span><br><span class="line">  <span class="attr">useLayoutEffect</span>: updateLayoutEffect,</span><br><span class="line">  <span class="attr">useMemo</span>: updateMemo,</span><br><span class="line">  <span class="attr">useReducer</span>: updateReducer,</span><br><span class="line">  <span class="attr">useRef</span>: updateRef,</span><br><span class="line">  <span class="attr">useState</span>: updateState,</span><br><span class="line">  <span class="attr">useDebugValue</span>: updateDebugValue,</span><br><span class="line">  <span class="attr">useDeferredValue</span>: updateDeferredValue,</span><br><span class="line">  <span class="attr">useTransition</span>: updateTransition,</span><br><span class="line">  <span class="attr">useMutableSource</span>: updateMutableSource,</span><br><span class="line">  <span class="attr">useOpaqueIdentifier</span>: updateOpaqueIdentifier,</span><br><span class="line"></span><br><span class="line">  <span class="attr">unstable_isNewReconciler</span>: enableNewReconciler,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>首次渲染时，<code>HooksDispatcherOnMount</code>上挂载的 hook 都是 mountXXX，而更新时 <code>HooksDispatcherOnMount</code>上挂在的 hook 都是 updateXXX。所有 mount 阶段的 hook 中，都会执行 <code>mountWorkInProgressHook</code>这个函数，而所有 update 阶段的 hook 中，都会执行 <code>updateWorkInProgressHook</code>这个函数。下面我们来看下这两个函数分别做了什么。</p>

        <h3 id="mountWorkInProgressHook"   >
          <a href="#mountWorkInProgressHook" class="heading-link"><i class="fas fa-link"></i></a><a href="#mountWorkInProgressHook" class="headerlink" title="mountWorkInProgressHook"></a>mountWorkInProgressHook</h3>
      <p>每个 hooks 方法中，都需要有一个 Hook 结构来存储相关信息。<code>mountWorkInProgressHook</code>中，会初始化创建一个 Hook，然后将其挂载到 workInProgress fiber 的 memoizedState 所指向的 hooks 链表上，以便于下次 update 的时候取出该 Hook：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title class_">Hook</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">hook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">    <span class="attr">memoizedState</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">baseState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若当前 workInProgressHook 为 null，将此 hook 作为 memoizedState 的头结点</span></span><br><span class="line">    currentlyRenderingFiber.<span class="property">memoizedState</span> = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 若不为 null，将 hook 挂载到链表最后</span></span><br><span class="line">    workInProgressHook = workInProgressHook.<span class="property">next</span> = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="updateWorkInProgressHook"   >
          <a href="#updateWorkInProgressHook" class="heading-link"><i class="fas fa-link"></i></a><a href="#updateWorkInProgressHook" class="headerlink" title="updateWorkInProgressHook"></a>updateWorkInProgressHook</h3>
      <p><code>updateWorkInProgressHook</code>的作用主要是取出 current fiber 中的 hooks 链表中对应的 hook 节点，挂载到 workInProgress fiber 上的 hooks 链表：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title class_">Hook</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">nextCurrentHook</span>: <span class="literal">null</span> | <span class="title class_">Hook</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代 current fiber 链表</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若 current 为 null，从 currentlyRenderingFiber.alternate 取 current</span></span><br><span class="line">    <span class="keyword">const</span> current = currentlyRenderingFiber.<span class="property">alternate</span>;</span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextCurrentHook = current.<span class="property">memoizedState</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则从 current fiber 中取下一个 hook</span></span><br><span class="line">    nextCurrentHook = currentHook.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代 workInProgress fiber 链表</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">nextWorkInProgressHook</span>: <span class="literal">null</span> | <span class="title class_">Hook</span>;</span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// workInProgressHook 说明是首次创建</span></span><br><span class="line">    nextWorkInProgressHook 为 <span class="literal">null</span> = currentlyRenderingFiber.<span class="property">memoizedState</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 取下一个 workInProgress Hook</span></span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 只有 re-render 的情况下，nextWorkInProgressHook 不为 null，因为在之前的 render 过程中已经创建过 workInProgress hook 了</span></span><br><span class="line">    <span class="comment">// 此时复用</span></span><br><span class="line">    workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">        currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 正常情况下，currentlyRenderingFiber.memoizedState 为 null，需要到从 current fiber 中克隆一个新的创建</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">invariant</span>(</span><br><span class="line">      nextCurrentHook !== <span class="literal">null</span>,</span><br><span class="line">      <span class="string">&#x27;Rendered more hooks than during the previous render.&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">newHook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">      <span class="attr">memoizedState</span>: currentHook.<span class="property">memoizedState</span>,</span><br><span class="line"></span><br><span class="line">      <span class="attr">baseState</span>: currentHook.<span class="property">baseState</span>,</span><br><span class="line">      <span class="attr">baseQueue</span>: currentHook.<span class="property">baseQueue</span>,</span><br><span class="line">      <span class="attr">queue</span>: currentHook.<span class="property">queue</span>,</span><br><span class="line"></span><br><span class="line">      <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 若 workInProgressHook 为 null，作为首节点赋值给 memoizedState</span></span><br><span class="line">      currentlyRenderingFiber.<span class="property">memoizedState</span> = workInProgressHook = newHook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将 workInProgressHook 添加到链表尾</span></span><br><span class="line">      workInProgressHook = workInProgressHook.<span class="property">next</span> = newHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们详细理解一下上述代码，前面我们提到过 <code>renderWithHooks</code>函数中会执行如下代码：<code>workInProgress.memoizedState = null</code>，所以在执行上述函数时，正常来说 <code>currentlyRenderingFiber.memoizedState</code>为 null，需要从 current fiber 对应的节点中取 clone 对应的 hook，再挂载到 workInProgress fiber 的 memoizedState 链表上；re-render 的情况下，由于已经创建过了 hooks，会复用已有的 workInProgress fiber 的 memoizedState。<br>这里正好提到，为什么 hook 不能用在条件语句中，因为如果前后两次渲染的条件判断不一致时，会导致 current fiber 和 workInProgress fiber 的 hooks 链表结点无法对齐。</p>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>所以我们总结一下<code>renderWithHooks</code>这个函数，它所做的事情如下：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/8cbbf443229943d89902355c2dc5d373_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>

        <h1 id="hooks-源码"   >
          <a href="#hooks-源码" class="heading-link"><i class="fas fa-link"></i></a><a href="#hooks-源码" class="headerlink" title="hooks 源码"></a>hooks 源码</h1>
      <p>前面 hooks 的执行入口我们都找到了，现在我们看一下常用的一些 hooks 源码。</p>

        <h2 id="useState-amp-useReducer"   >
          <a href="#useState-amp-useReducer" class="heading-link"><i class="fas fa-link"></i></a><a href="#useState-amp-useReducer" class="headerlink" title="useState &amp; useReducer"></a>useState &amp; useReducer</h2>
      <p>这里会把 useState 和 useReducer 放在一起来说，因为 useState 相当于一个简化版的 useReducer。</p>

        <h3 id="用法"   >
          <a href="#用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#用法" class="headerlink" title="用法"></a>用法</h3>
      <p>useState 的简单用法如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 改变 count 的值</span></span><br><span class="line"><span class="title function_">setCount</span>(count++);</span><br></pre></td></tr></table></div></figure>

<p>useReducer 简单用法如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, dispatch] = <span class="title function_">useReducer</span>(<span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increment&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 改变 count 的值</span></span><br><span class="line"><span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;increment&quot;</span> &#125;);</span><br></pre></td></tr></table></div></figure>


        <h3 id="mountState-amp-mountReducer"   >
          <a href="#mountState-amp-mountReducer" class="heading-link"><i class="fas fa-link"></i></a><a href="#mountState-amp-mountReducer" class="headerlink" title="mountState &amp; mountReducer"></a>mountState &amp; mountReducer</h3>
      <p>我们先从 useState 开始讲起，mount 阶段，useState 对应的源码是 mountState。这里面后创建初始的 hook 和更新队列 queue，然后创建 dispatch，最终返回 [hook.memoizedState, dispatch]，对应的是我们代码中的 [count, setCount]，供我们使用：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  <span class="comment">// 创建一个 hook，链接到 hooks 链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="comment">// 校验初始的 state 是否是个函数，是的话执行该函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    initialState = <span class="title function_">initialState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前面提到过，对于 useState，memoizedState 保存的是 state</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = hook.<span class="property">baseState</span> = initialState;</span><br><span class="line">  <span class="comment">// 创建更新队列 updateQueue</span></span><br><span class="line">  <span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>, <span class="comment">// 待执行的 hook</span></span><br><span class="line">    <span class="attr">dispatch</span>: <span class="literal">null</span>, <span class="comment">// 更新函数</span></span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: basicStateReducer, <span class="comment">// 上次渲染的 reducer</span></span><br><span class="line">    <span class="attr">lastRenderedState</span>: (<span class="attr">initialState</span>: any), <span class="comment">// 上次渲染的 state</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 创建 dispatch（负责更新的函数）</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt; = (queue.<span class="property">dispatch</span> =</span><br><span class="line">    (dispatchAction.<span class="title function_">bind</span>(<span class="literal">null</span>, currentlyRenderingFiber, queue): any));</span><br><span class="line">  <span class="comment">// 返回 useState 的 state 及 dispatch，供我们使用</span></span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>再来看下 mount 阶段的 useReducer 的源码，也就是 mountReducer，可以看到和 mountState 所做的事情基本时一样的，mountState 可以看做是有一个初始 state 的 mountReducer：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountReducer&lt;S, I, A&gt;(</span><br><span class="line">  <span class="attr">reducer</span>: <span class="function">(<span class="params">S, A</span>) =&gt;</span> S,</span><br><span class="line">  <span class="attr">initialArg</span>: I,</span><br><span class="line">  init?: <span class="function">(<span class="params">I</span>) =&gt;</span> S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;A&gt;] &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">let</span> initialState;</span><br><span class="line">  <span class="keyword">if</span> (init !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    initialState = <span class="title function_">init</span>(initialArg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    initialState = ((<span class="attr">initialArg</span>: any): S);</span><br><span class="line">  &#125;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = hook.<span class="property">baseState</span> = initialState;</span><br><span class="line">  <span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">dispatch</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: reducer,</span><br><span class="line">    <span class="attr">lastRenderedState</span>: (<span class="attr">initialState</span>: any),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;A&gt; = (queue.<span class="property">dispatch</span> = (dispatchAction.<span class="title function_">bind</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    queue</span><br><span class="line">  ): any));</span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="dispatchAction"   >
          <a href="#dispatchAction" class="heading-link"><i class="fas fa-link"></i></a><a href="#dispatchAction" class="headerlink" title="dispatchAction"></a>dispatchAction</h3>
      <p>上面的代码中，其他内容我们前面基本都有讲过，你们应该了解它们的作用，我们着重来看一下 dispatch，它是通过执行 dispatchAction 创建的。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> dispatchAction&lt;S, A&gt;(</span><br><span class="line">  <span class="attr">fiber</span>: <span class="title class_">Fiber</span>,</span><br><span class="line">  <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;S, A&gt;,</span><br><span class="line">  <span class="attr">action</span>: A,</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 获取更新触发时间及优先级</span></span><br><span class="line">  <span class="keyword">const</span> eventTime = <span class="title function_">requestEventTime</span>();</span><br><span class="line">  <span class="keyword">const</span> lane = <span class="title function_">requestUpdateLane</span>(fiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 update</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">update</span>: <span class="title class_">Update</span>&lt;S, A&gt; = &#123;</span><br><span class="line">    lane,</span><br><span class="line">    action,</span><br><span class="line">    <span class="attr">eagerReducer</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">eagerState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 update 链接到更新队列中</span></span><br><span class="line">  <span class="keyword">const</span> pending = queue.<span class="property">pending</span>;</span><br><span class="line">  <span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">    update.<span class="property">next</span> = update;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    update.<span class="property">next</span> = pending.<span class="property">next</span>;</span><br><span class="line">    pending.<span class="property">next</span> = update;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.<span class="property">pending</span> = update;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> alternate = fiber.<span class="property">alternate</span>;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    fiber === currentlyRenderingFiber ||</span><br><span class="line">    (alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// currentlyRenderingFiber 存在，说明是在 render 过程发生的更新</span></span><br><span class="line">    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">    fiber.<span class="property">lanes</span> === <span class="title class_">NoLanes</span> &amp;&amp;</span><br><span class="line">    (alternate === <span class="literal">null</span> || alternate.<span class="property">lanes</span> === <span class="title class_">NoLanes</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// fiber.lanes === NoLanes 说明是首次更新</span></span><br><span class="line">      <span class="comment">// 如果值不同，则保存在 eagerState，下次 render 时可以直接使用，而无需再计算。</span></span><br><span class="line">      <span class="keyword">const</span> lastRenderedReducer = queue.<span class="property">lastRenderedReducer</span>;</span><br><span class="line">      <span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> prevDispatcher;</span><br><span class="line">        <span class="keyword">if</span> (**<span class="variable constant_">DEV</span>**) &#123;</span><br><span class="line">          prevDispatcher = <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span>;</span><br><span class="line">          <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">InvalidNestedHooksDispatcherOnUpdateInDEV</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> <span class="attr">currentState</span>: S = (queue.<span class="property">lastRenderedState</span>: any);</span><br><span class="line">          <span class="comment">// 我们可以根据当前 state 和 action 来计算新的 state 值</span></span><br><span class="line">          <span class="keyword">const</span> eagerState = <span class="title function_">lastRenderedReducer</span>(currentState, action);</span><br><span class="line">          update.<span class="property">eagerReducer</span> = lastRenderedReducer;</span><br><span class="line">          update.<span class="property">eagerState</span> = eagerState;</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">is</span>(eagerState, currentState)) &#123;</span><br><span class="line">            <span class="comment">// 如果与当前值相同，则跳过更新</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 如果值不同，新一轮更新时渲染 eagerState</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (**<span class="variable constant_">DEV</span>**) &#123;</span><br><span class="line">            <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = prevDispatcher;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 开启调度，触发新的一轮更新，也就是走 beginWork, completeWork 那一套流程</span></span><br><span class="line">    <span class="title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line">    <span class="title function_">markStateUpdateScheduled</span>(fiber, lane);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>首先，会创建一个初始的 update 对象，用来记录相关的 hook 信息，并将它添加到 queue 中，这里的 queue 的添加你可以发现它形成了一个循环链表，这样 pending 作为链表的一个尾结点，而 pending.next 就能够获取链表的头结点。这样做的目的是，在 setCount 时，我们需要将 update 添加到链表的尾部；而在下面的 updateReducer 中，我们需要获取链表的头结点来遍历链表，通过循环链表能够轻松实现我们的需求。<br>之后，会根据当前所处的阶段是否在 render 阶段发生：</p>
<p>如果是 render 阶段发生，那么会触发 re-render 过程，将 didScheduleRenderPhaseUpdateDuringThisPass 置为 true。前面 renderWithHooks 的代码中我们说了，didScheduleRenderPhaseUpdateDuringThisPass 为 true 时会代表 re-render，会重新执行 render 过程，直至其为 false。<br>如果不是在 render 阶段发生，那么会通过当前的 state 和 action 来判断下次渲染的 state 的值，并与当前 state 的值进行比较，如果两个值一致，则不需要更新，跳过更新过程；如果两个值不一致，调用 scheduleUpdateOnFiber 开始调度，触发新一轮更新。</p>

        <h3 id="updateReducer"   >
          <a href="#updateReducer" class="heading-link"><i class="fas fa-link"></i></a><a href="#updateReducer" class="headerlink" title="updateReducer"></a>updateReducer</h3>
      <p>update 时，useState 和 useReducer 就更没什么区别了，updateState 就是直接返回了 updateReducer 函数，所以我们直接看 updateReducer 的源码就可以。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">updateReducer</span>(basicStateReducer, (<span class="attr">initialState</span>: any));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>updateReducer 中，用 pending 来指向本次要触发的 update，然后将本次 hook 要执行的 update 和 current fiber 中之前未完成的 update 全部链接到 baseQueue，也就是代表全局的 update。<br>在 render 阶段，会遍历 update 来计算 state 的值，若某个 update 的优先级低于当前 render 执行的任务的优先级，则跳过此次 update 及未遍历完的 update 的执行，先执行其他的 update。然后再下一次 render 时从跳过的 update 开始继续执行。<br>update 阶段 dispatch 会生成一个新的 update 链接到 hooks 中，并根据之前的 state 和本次 action 去计算新的 state。<br>updateReducer 的源码如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateReducer&lt;S, I, A&gt;(</span><br><span class="line">  <span class="attr">reducer</span>: <span class="function">(<span class="params">S, A</span>) =&gt;</span> S,</span><br><span class="line">  <span class="attr">initialArg</span>: I,</span><br><span class="line">  init?: <span class="function">(<span class="params">I</span>) =&gt;</span> S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;A&gt;] &#123;</span><br><span class="line">  <span class="comment">// 取出 hook 节点</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> queue = hook.<span class="property">queue</span>;</span><br><span class="line">  <span class="title function_">invariant</span>(</span><br><span class="line">    queue !== <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;Should have a queue. This is likely a bug in React. Please file an issue.&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  queue.<span class="property">lastRenderedReducer</span> = reducer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">Hook</span> = (<span class="attr">currentHook</span>: any);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上次未完成的 update</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = current.<span class="property">baseQueue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取本次待执行的 update</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.<span class="property">pending</span>;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果 baseQueue 和 pendingQueue 都存在，将 pendingQueue 链接到 baseQueue 尾部</span></span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.<span class="property">next</span>;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.<span class="property">next</span>;</span><br><span class="line">      baseQueue.<span class="property">next</span> = pendingFirst;</span><br><span class="line">      pendingQueue.<span class="property">next</span> = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// react 的异步模型，可能发生一个更高优先级任务打断当前任务的执行</span></span><br><span class="line">    <span class="comment">// 所以要将 baseQueue 也赋值给 current fiber</span></span><br><span class="line">    current.<span class="property">baseQueue</span> = baseQueue = pendingQueue;</span><br><span class="line">    queue.<span class="property">pending</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> newState = current.<span class="property">baseState</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueLast = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line">    <span class="comment">// 遍历 hooks 链表，计算 state</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> updateLane = update.<span class="property">lane</span>;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isSubsetOfLanes</span>(renderLanes, updateLane)) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的 update 优先级低于 render 优先级，下次 render 时再执行本次的 update</span></span><br><span class="line">        <span class="keyword">const</span> <span class="attr">clone</span>: <span class="title class_">Update</span>&lt;S, A&gt; = &#123;</span><br><span class="line">          <span class="attr">lane</span>: updateLane,</span><br><span class="line">          <span class="attr">action</span>: update.<span class="property">action</span>,</span><br><span class="line">          <span class="attr">eagerReducer</span>: update.<span class="property">eagerReducer</span>,</span><br><span class="line">          <span class="attr">eagerState</span>: update.<span class="property">eagerState</span>,</span><br><span class="line">          <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 把这个 update 添加到 newBaseQueue 中下次 render 执行</span></span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">          newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.<span class="property">next</span> = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 queue 的优先级</span></span><br><span class="line">        currentlyRenderingFiber.<span class="property">lanes</span> = <span class="title function_">mergeLanes</span>(</span><br><span class="line">          currentlyRenderingFiber.<span class="property">lanes</span>,</span><br><span class="line">          updateLane</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 标记本次 update 跳过了</span></span><br><span class="line">        <span class="title function_">markSkippedUpdateLanes</span>(updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// newBaseQueueLast 不为 null，说明此前有跳过的 update</span></span><br><span class="line">          <span class="comment">// update 之间可能存在依赖，将后续 update 都连接到 newBaseQueue 中留到下次 render 执行</span></span><br><span class="line">          <span class="keyword">const</span> <span class="attr">clone</span>: <span class="title class_">Update</span>&lt;S, A&gt; = &#123;</span><br><span class="line">            <span class="attr">lane</span>: <span class="title class_">NoLane</span>,</span><br><span class="line">            <span class="attr">action</span>: update.<span class="property">action</span>,</span><br><span class="line">            <span class="attr">eagerReducer</span>: update.<span class="property">eagerReducer</span>,</span><br><span class="line">            <span class="attr">eagerState</span>: update.<span class="property">eagerState</span>,</span><br><span class="line">            <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">          &#125;;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.<span class="property">next</span> = clone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行本次的 update，计算新的 state</span></span><br><span class="line">        <span class="keyword">if</span> (update.<span class="property">eagerReducer</span> === reducer) &#123;</span><br><span class="line">          <span class="comment">// update.eagerReducer 和 reducer 相等，说明 reducer 已经计算过，直接取结算过的 state</span></span><br><span class="line">          newState = ((update.<span class="property">eagerState</span>: any): S);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 根据 state 和 action 计算新的 state</span></span><br><span class="line">          <span class="keyword">const</span> action = update.<span class="property">action</span>;</span><br><span class="line">          newState = <span class="title function_">reducer</span>(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      update = update.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// newBaseQueueLast 为 null，说明所有 update 处理完了，更新 baseState</span></span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 未处理完留到下次执行</span></span><br><span class="line">      newBaseQueueLast.<span class="property">next</span> = (<span class="attr">newBaseQueueFirst</span>: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的 state 和之前的 state 不相等，标记需要更新</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is</span>(newState, hook.<span class="property">memoizedState</span>)) &#123;</span><br><span class="line">      <span class="title function_">markWorkInProgressReceivedUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的 state 和 baseQueue 保存到 hook 中</span></span><br><span class="line">    hook.<span class="property">memoizedState</span> = newState;</span><br><span class="line">    hook.<span class="property">baseState</span> = newBaseState;</span><br><span class="line">    hook.<span class="property">baseQueue</span> = newBaseQueueLast;</span><br><span class="line"></span><br><span class="line">    queue.<span class="property">lastRenderedState</span> = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;A&gt; = (queue.<span class="property">dispatch</span>: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结-1"   >
          <a href="#总结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3>
      <p>总结一下 useState 和 useReducer 的执行过程如下图：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/f6dd618d1c1642a6bbec25ed82c0a408_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>

        <h2 id="useEffect"   >
          <a href="#useEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2>
      <p>同样，我们也分为 mount 和 update 两种情况来看 useEffect。</p>

        <h3 id="用法-1"   >
          <a href="#用法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3>
      <p>useEffect 的使用大家应该都了解，在这里就不赘述了，我们本次的用例如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;unmount&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></div></figure>


        <h3 id="mountEffect"   >
          <a href="#mountEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#mountEffect" class="headerlink" title="mountEffect"></a>mountEffect</h3>
      <p>mount 阶段 useEffect 实际上是调用了 mountEffect 方法，进一步通过传递参数调用了 mountEffectImpl 这个函数：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  create: () =&gt; (() =&gt; <span class="keyword">void</span>) | <span class="keyword">void</span>, <span class="comment">// 执行的回调函数</span></span></span><br><span class="line"><span class="params">  deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span> <span class="comment">// 依赖项</span></span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountEffectImpl</span>(</span><br><span class="line">    <span class="title class_">UpdateEffect</span> | <span class="title class_">PassiveEffect</span>,</span><br><span class="line">    <span class="title class_">HookPassive</span>,</span><br><span class="line">    create,</span><br><span class="line">    deps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>和 mountState 中所做的事情类似，mountEffectImpl 中首先通过 mountWorkInProgressHook 创建了 hook 链接到 hooks 链表中，前面提到过 useEffect 的 hook 是一个 Effect 类型的对象。然后通过 pushEffect 方法创建一个 effect 添加到 hook 的 memoizedState 属性：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 创建 hook 并链接到 hooks 链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  currentlyRenderingFiber.<span class="property">flags</span> |= fiberFlags;</span><br><span class="line">  <span class="comment">// 创建一个 effect 对象并添加到 hook 的 memoizedState 中</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(</span><br><span class="line">    <span class="title class_">HookHasEffect</span> | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="pushEffect"   >
          <a href="#pushEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#pushEffect" class="headerlink" title="pushEffect"></a>pushEffect</h3>
      <p><code>pushEffect</code>函数中主要做了两件事，创建 effect 对象，然后将其添加到 fiber 的 updateQueue 链表上：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建 effect</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">effect</span>: <span class="title class_">Effect</span> = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">componentUpdateQueue</span>: <span class="literal">null</span> | <span class="title class_">FunctionComponentUpdateQueue</span> =</span><br><span class="line">    (currentlyRenderingFiber.<span class="property">updateQueue</span>: any);</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// componentUpdateQueue 为 null，将 effect 添加到 componentUpdateQueue 头结点</span></span><br><span class="line">    componentUpdateQueue = <span class="title function_">createFunctionComponentUpdateQueue</span>();</span><br><span class="line">    currentlyRenderingFiber.<span class="property">updateQueue</span> = (<span class="attr">componentUpdateQueue</span>: any);</span><br><span class="line">    componentUpdateQueue.<span class="property">lastEffect</span> = effect.<span class="property">next</span> = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 链接到当前 fiber 节点的 updateQueue 的 lastEffect 中</span></span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.<span class="property">lastEffect</span>;</span><br><span class="line">    <span class="comment">// 构成循环链表结构</span></span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.<span class="property">lastEffect</span> = effect.<span class="property">next</span> = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.<span class="property">next</span>;</span><br><span class="line">      lastEffect.<span class="property">next</span> = effect;</span><br><span class="line">      effect.<span class="property">next</span> = firstEffect;</span><br><span class="line">      componentUpdateQueue.<span class="property">lastEffect</span> = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="updateEffect"   >
          <a href="#updateEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#updateEffect" class="headerlink" title="updateEffect"></a>updateEffect</h3>
      <p>update 阶段，<code>useEffect</code>实际上是调用了<code>updateEffect</code>函数，同样是进一步调用了<code>updateEffectImpl</code>函数：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  create: () =&gt; (() =&gt; <span class="keyword">void</span>) | <span class="keyword">void</span>,</span></span><br><span class="line"><span class="params">  deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">updateEffectImpl</span>(</span><br><span class="line">    <span class="title class_">UpdateEffect</span> | <span class="title class_">PassiveEffect</span>,</span><br><span class="line">    <span class="title class_">HookPassive</span>,</span><br><span class="line">    create,</span><br><span class="line">    deps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>所以我们接着往下看<code>updateEffectImpl</code>函数做了什么，它从 <code>updateWorkInProgressHook</code>取出对应的 hook，然后看上一轮 render 中是否有 hook 存在，若存在且上一轮 render 和本轮的依赖项没发生变化，说明副作用不需要执行，创建一个 effect 对象添加到 updateQueue 链表后直接返回；若两次的依赖项发生了变化，向 fiber 添加 flags 副作用标签，待 commit 时更新，然后再创建一个 effect 对象添加到 updateQueue 链表：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 从 hooks 链表中取出对应 hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若上一轮 render 对应 hook 存在</span></span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.<span class="property">memoizedState</span>;</span><br><span class="line">    destroy = prevEffect.<span class="property">destroy</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.<span class="property">deps</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="comment">// 若上一轮和本次的依赖项未发生变化，说明没有副作用</span></span><br><span class="line">        <span class="comment">// 创建一个 effect 对象添加到 updateQueue 链表中，然后返回</span></span><br><span class="line">        <span class="title function_">pushEffect</span>(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行到这里说明上一轮和本轮依赖项发生变化</span></span><br><span class="line">  <span class="comment">// 向 fiber 添加 flags 副作用标签，待 commit 时更新</span></span><br><span class="line">  currentlyRenderingFiber.<span class="property">flags</span> |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 effect 对象添加到 updateQueue 链表中</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(</span><br><span class="line">    <span class="title class_">HookHasEffect</span> | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结-2"   >
          <a href="#总结-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3>
      <p>总结一下 useEffect 的大体流程如下：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/22a64ff368474815b9cbc58fefd755a8_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>

        <h2 id="useRef"   >
          <a href="#useRef" class="heading-link"><i class="fas fa-link"></i></a><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2>
      <p><code>useRef</code>的代码十分的简单了，我们直接将 mount 阶段和 update 阶段的放到一起来看：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountRef&lt;T&gt;(<span class="attr">initialValue</span>: T): &#123;| <span class="attr">current</span>: T |&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> ref = &#123; <span class="attr">current</span>: initialValue &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateRef&lt;T&gt;(<span class="attr">initialValue</span>: T): &#123;| <span class="attr">current</span>: T |&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">return</span> hook.<span class="property">memoizedState</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>mount 阶段，调用<code>mountRef</code>函数，通过 <code>mountWorkInProgressHook</code>创建一个 hook 并添加到 hooks 链表上，<code>hook.memoizedState</code>上存储的是{current: initialValue}这个 ref 对象。<br>update 阶段，调用<code>updateRef</code>函数，通过<code>updateWorkInProgressHook</code>方法直接取出<code>hook.memoizedState</code>。<br>可以看到<code>hook.memoizedState</code>指向的是一个对象的引用，这就解释了我们可以直接通过 <code>ref.current</code>去改变和获取最新的值，不必进行任何依赖注入。</p>

        <h2 id="useCallback-amp-useMemo"   >
          <a href="#useCallback-amp-useMemo" class="heading-link"><i class="fas fa-link"></i></a><a href="#useCallback-amp-useMemo" class="headerlink" title="useCallback &amp; useMemo"></a>useCallback &amp; useMemo</h2>
      <p><code>useCallback</code>和<code>useMemo</code>也是一样，源码结构上十分相似，所以也放在一起来讲。</p>

        <h3 id="用法-2"   >
          <a href="#用法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3>
      <p>基础用法如下：<br>&#x2F;&#x2F; 第一个参数是 “创建” 函数，第二个参数是依赖项数组<br>&#x2F;&#x2F; “创建” 函数会根据依赖项数组返回一个值，并且仅会在某个依赖项改变时才重新计算</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">add</span>(a, b), [a, b]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是回调函数，第二个参数是依赖项数组</span></span><br><span class="line"><span class="comment">// 依赖项改变时回调函数会进行更新</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">add</span>(a, b);</span><br><span class="line">&#125;, [a, b]);</span><br></pre></td></tr></table></div></figure>


        <h3 id="mount-阶段"   >
          <a href="#mount-阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#mount-阶段" class="headerlink" title="mount 阶段"></a>mount 阶段</h3>
      <p>mount 时，分别调用了<code>mountCallback</code>和<code>mountMemo</code>函数，两者都通过 <code>mountWorkInProgressHook</code>方法创建 hook 添加到了 hooks 链表中。不同的是，<code>mountCallback</code>的 memoizedState 是[callback, nextDeps]，并且返回的是其第一个参数；<code>mountMemo</code>的 memoizedState 是 [nextValue, nextDeps]，返回的也是 nextValue 也就是其第一个参数的执行结果。<br>所以看上去<code>useMemo</code>就是比<code>useCallback</code>多了一步第一个参数的执行过程。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="comment">// 创建 hook 添加到链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountMemo&lt;T&gt;(</span><br><span class="line">  <span class="attr">nextCreate</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span><br><span class="line">): T &#123;</span><br><span class="line">  <span class="comment">// 创建 hook 添加到链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>();</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="update-阶段"   >
          <a href="#update-阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#update-阶段" class="headerlink" title="update 阶段"></a>update 阶段</h3>
      <p>update 时，分别调用了<code>updateCallback</code>和<code>updateMemo</code> 函数，它们都通过 <code>updateWorkInProgressHook</code>取出对应的 hook，若依赖项未发生改变，则取上一轮的 callback 或者 value 返回；若依赖项发生改变，则重新赋值 hook.memoizedState 并返回新的 callback 或新计算的 value：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="comment">// 获取对应 hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">prevDeps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 依赖项未发生改变，取上一轮的 callback 并返回</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖项改变了，重新赋值 hook.memoizedState，返回新的 callback</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateMemo&lt;T&gt;(</span><br><span class="line">  <span class="attr">nextCreate</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span><br><span class="line">): T &#123;</span><br><span class="line">  <span class="comment">// 获取对应 hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">prevDeps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 依赖项未发生改变，取上一轮的值并返回</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖项改变了，计算新的值，重新赋值 hook.memoizedState 并返回新的值</span></span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>();</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="结语"   >
          <a href="#结语" class="heading-link"><i class="fas fa-link"></i></a><a href="#结语" class="headerlink" title="结语"></a>结语</h1>
      <p>本章讲解了 react hooks 的源码，理解了 hooks 的设计思想和工作过程。其他 hook 平时用的比较少，就不在这里展开讲了，但通过上面几个 hook 的源码讲解，其他 hook 看源码你应该也能看得懂。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/%E4%BB%8E%E4%B8%80%E9%81%93promise%E9%A2%98%E7%9B%AE%E6%9D%A5%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/">从一道 promise 题目来深入理解执行过程</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-09-21</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>要解决的题目如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<p>输出结果按顺序为 0,1,2,3,4,5,6</p>

        <h1 id="分析"   >
          <a href="#分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#分析" class="headerlink" title="分析"></a>分析</h1>
      <p>一般遇到<code>Promise.resolve()</code>时，相当于<code>new Promise(resolve =&gt; &#123;resolve()&#125;)</code>都是同步完成的，不会消耗微任务。<br>但以下情况时，需要注意，我们先看三组代码：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)); <span class="comment">//resolve 了一个 Promise</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>

<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码 2</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>); <span class="comment">//return 了一个 Promise</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码 3</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>; <span class="comment">//return 了一个 Number 类型的 4</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<p>这三个输出结果，打印出来的都是数字 4。<br>我们可以看出不同，代码 3 是我们最常见的情况。代码 3 里打印的 res 是 4，和上边 return 的是同样的数据类型。那么代码 1 和代码 2 的 res 为什么不是 <code>Object</code>类型的<code>Promise&#123;&lt;fulfilled&gt;: 4&#125;</code>呢？<br>在一般情况下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>

<p>这段代码中，<code>Promise.resolve().then</code>是一个构造函数,<code>() =&gt; &#123;return 4;&#125;</code>是这个函数的参数，这个函数调用，最后返回一个值为 4 的<code>Promise</code>(即<code>new Promise(resolve =&gt; resolve(4)</code>).<br>而在</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)); <span class="comment">//resolve 了一个 Promise</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>

<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>); <span class="comment">//return 了一个 Promise</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>

<p>中，因为 js 在遇到<code>resolve</code>或者<code>return</code>一个<code>Promise</code>对象时，会先求得这个 Promise 对象的值，也就是这个 Promise 的状态为<code>fulfilled</code>或<code>rejected</code>的值(假如这个值是’a’)，再用这个值作为返回的新的<code>Promised</code>的值，这个新的<code>Promise</code>(就是<code>new Promise(resolve =&gt; resolve(&#39;a&#39;)</code>)作为下级链式调用的<code>Promise</code>。</p>

        <h1 id="结论"   >
          <a href="#结论" class="heading-link"><i class="fas fa-link"></i></a><a href="#结论" class="headerlink" title="结论"></a>结论</h1>
      <p>在 chrome 内部实现的 Promise 和标准的 Promise&#x2F;A+规范存在差异。浏览器内部实现的区别。我们可以理解为，resolve 或者 return 遇到一个 Promise 对象时，得到这个 Promise 的值之后，会把这个值用微任务包装起来，在 return 值向外传递(因为后边没有.then()了，所以是向父级的外层传递)时，会产生第二个微任务。<br>所以代码</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)); <span class="comment">//resolve 了一个 Promise</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>

<p>可以理解为</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>()</span><br><span class="line">  .<span class="title function_">then</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<p>对应的，代码</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码 2</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>); <span class="comment">//return 了一个 Promise</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<p>可以理解为</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>()</span><br><span class="line">  .<span class="title function_">then</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<p>这样理解的，和文章开头的题目结果是一致的，核心就是会比正常的 return 一个非 Promise 的值时，多两个微任务.then().then()<br>另外的</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)));</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<p>像这样的<code>return Promise.resolve(Promise.resolve(Promise.resolve(4)))</code>嵌套多层<code>Promise</code>，其实和<code>Promise.resolve(4)</code>是一样的，并不会多产生微任务。因为这两段代码的<code>Promise</code>状态变为<code>fulfilled</code>的过程并不需要等待。而是拿到它的值之后，在向后运行的时候，会产生微任务。<br>但如果是</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4.1</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4.2</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<p>这时<code>.then(res =&gt; &#123; console.log(res); &#125;)</code>想要运行，需要等待前边 return 的 Promise 状态变为<code>fulfilled</code>才行，</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4.1</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4.2</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<p>本身是会注册两个微任务的，而拿到它的值之后，在向后运行的时候，又会产生两个任务(包装值一次，return 传递一次)。</p>

        <h1 id="回顾"   >
          <a href="#回顾" class="heading-link"><i class="fas fa-link"></i></a><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1>
      <p>我们来回顾下文章开头的题目</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<p>按照上边的分析，可以对应转化为</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>()</span><br><span class="line">  .<span class="title function_">then</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<p>运行结果都是 0,1,2,3,4,5,6<br>题目 2</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="string">&quot;then4_1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4.1</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4.2</span>;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res, <span class="string">&quot;then4_2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></div></figure>

<p>运行结果为</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">题目 <span class="number">3</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)));</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>

<p>运行结果 0,1,2,3,4,5,6</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/for-in%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81hasOwnProperty%E5%88%A4%E6%96%AD%EF%BC%9F/">for...in为什么需要hasOwnProperty判断？</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-02-11</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>我们经常使用 for…in 循环对象输出键和值</p>
<p>如：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// =&gt; a b</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[key]); <span class="comment">// =&gt; 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>但在某些编辑器（如 vscode）中输入 forin，会自动生成如下代码：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(object, key)) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = object[key];</span><br><span class="line">    <span class="comment">// todo ..</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>每次都会想这句是不是多余的呢？</p>
<p><code>(Object.hasOwnProperty.call(object, key)</code></p>
<p>引用 MDN 解释，<code>for...in</code>语句以任意顺序迭代一个对象的除<code>Symbol</code>以外的可枚举属性，包括继承的可枚举属性。</p>
<p>重点：<strong>包括继承的可枚举属性</strong></p>
<p>下面看一个例子：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">School</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">school</span> = <span class="string">&quot;清北&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="string">&quot;18&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">School</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们要打印 p 上面的属性</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> p) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;p[key]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// name = 小明</span></span><br><span class="line"><span class="comment">// age = 18</span></span><br><span class="line"><span class="comment">// school = 南翔</span></span><br></pre></td></tr></table></div></figure>

<p><code>Person.prototype = new School()</code></p>
<p>Person 的原型上继承了 School，输出了<code>school = 南翔</code>，这里不明白的话建议看看你红宝书继承那一章，这里简单使用，不做解释！</p>
<p>我们的目标是输出 p 自己的属性，明显这不符合如期，所以 hasOwnProperty 派上用场了</p>
<p>引用 MDN 解释：</p>
<p><code>hasOwnProperty()</code>方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键）</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..省略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> p) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="property">hasOwnProperty</span>.<span class="title function_">call</span>(p.<span class="property">key</span>)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;p[key]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// name = 小明</span></span><br><span class="line"><span class="comment">// age = 18</span></span><br></pre></td></tr></table></div></figure>

<p>当然，小伙伴工作时候一般遍历<code>let obj = &#123;&#125;</code>这种对象，其实可以省略，但是如果我们开发一些工具库的时候还是严谨点好。</p>
<p>延伸问题：</p>
<p><code>Object.hasOwnProperty.call(p. key)</code></p>
<p>hasOwnProperty 是 Object 上的方法，所有对象默认会继承该方法，为什么不直接</p>
<p><code>p.hasOwnProperty(key)</code></p>
<p>而使用</p>
<p><code>Object.hasOwnProperty.call(object, key)</code></p>
<p>我们试试：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..省略</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> p) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;p[key]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// name = 小明</span></span><br><span class="line"><span class="comment">// age = 18</span></span><br></pre></td></tr></table></div></figure>

<p>好明显是符合如期的!</p>
<p>为啥要这么写呢，那肯定有它的原因！！！</p>
<p>假设我们把代码改一下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ..其他省略</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="string">&quot;18&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">hasOwnProperty</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> p) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;p[key]&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 ??? 啥也没有</span></span><br></pre></td></tr></table></div></figure>

<p>好明显，我们定义 hasOwnProperty 把原来的方法覆盖了，虽然我们平时不会这样做，但还是那句话，如果我们开发工具或者库得时候，写代码还是得严谨点好！</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">Keep studying, Keep Creating</p></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>WuQianying</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v6.3.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-banner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script></body></html>