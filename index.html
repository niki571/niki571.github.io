<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.8.0" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="吴倩颖的网络日志">
<meta property="og:url" content="https://niki571.github.io/index.html">
<meta property="og:site_name" content="吴倩颖的网络日志">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="WuQianying">
<meta name="twitter:card" content="summary"><title>吴倩颖的网络日志</title><link ref="canonical" href="https://niki571.github.io/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"carbon","highlight":"ocean","wordWrap":true},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: {"avoidBanner":true},
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return false;"><span class="header-nav-menu-item__icon"><i class="fas fa-solid fa-pen-nib"></i></span><span class="header-nav-menu-item__text">文章</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/archives/"><span class="header-nav-submenu-item__icon"><i class="fas fa-solid fa-folder-open"></i></span><span class="header-nav-submenu-item__text">归档</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/categories/"><span class="header-nav-submenu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-submenu-item__text">分类</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/tags/"><span class="header-nav-submenu-item__icon"><i class="fas fa-solid fa-tag"></i></span><span class="header-nav-submenu-item__text">标签</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/me/"><span class="header-nav-menu-item__icon"><i class="fas fa-solid fa-star"></i></span><span class="header-nav-menu-item__text">我</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">吴倩颖的网络日志</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/Flutter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89-Widget/">Flutter 源码解析（一） Widget</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-01-13</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-20</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="Widget"   >
          <a href="#Widget" class="heading-link"><i class="fas fa-link"></i></a><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h1>
      <blockquote>
<p>Everything’s a widget.</p>
</blockquote>
<p>在开发 Flutter 应用过程中，接触最多的无疑就是<code>Widget</code>，是『描述』 Flutter UI 的基本单元，通过<code>Widget</code>可以做到：</p>
<ul>
<li>描述 UI 的层级结构 (通过<code>Widget</code>嵌套)；</li>
<li>定制 UI 的具体样式 (如：<code>font</code>、<code>color</code>等)；</li>
<li>指导 UI 的布局过程 (如：<code>padding</code>、<code>center</code>等)；</li>
<li>…</li>
</ul>
<p>Google 在设计<code>Widget</code>时，还赋予它一些鲜明的特点：</p>
<p>声明式 UI —— 相对于传统 Native 开发中的命令式 UI，声明式 UI 有不少优势，如：开发效率显著提升、UI 可维护性明显加强等；</p>
<p>不可变性 —— Flutter 中所有<code>Widget</code>都是不可变的(immutable)，即其内部成员都是不可变的(final)，对于变化的部分需要通过「Stateful Widget-State」的方式实现；</p>
<p>组合大于继承 ——<code>Widget</code>设计遵循组合大于继承这一优秀的设计理念，通过将多个功能相对单一的 Widget 组合起来便可得到功能相对复杂的 Widget。</p>
<p>在<code>Widget</code>类定义处有这样一段注释：</p>
<p>这段注释阐明了<code>Widget</code>的本质：用于配置 Element 的，Widget 本质上是 UI 的配置信息 (附带部分业务逻辑)。</p>
<p>我们通常会将通过 Widget 描述的 UI 层级结构称之为「Widget Tree」，但与「Element Tree」、「RenderObject Tree」以及「Layer Tree」相比，实质上并不存在「Widget Tree」。为了描述方便，将 Widget 组合描述的 UI 层级结构称之为「Widget Tree」，也未尝不可。</p>

        <h2 id="分类"   >
          <a href="#分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#分类" class="headerlink" title="分类"></a>分类</h2>
      <p>如上图所示，按照功能划分 Widget 大致可以分为 3 类：</p>
<p>「Component Widget」 —— 组合类<code>Widget</code>，这类<code>Widget</code>都直接或间接继承于<code>StatelessWidget</code>或<code>StatefulWidget</code>，上一小节提到过在<code>Widget</code>设计上遵循组合大于继承的原则，通过组合功能相对单一的 Widget 可以得到功能更为复杂的 Widget。平常的业务开发主要是在开发这一类型的 Widget；</p>
<p>「Proxy Widget」 —— 代理类<code>Widget</code>，正如其名，「Proxy Widget」本身并不涉及 Widget 内部逻辑，只是为「Child Widget」提供一些附加的中间功能。典型的如：InheritedWidget 用于在「Descendant Widgets」间传递共享信息、ParentDataWidget 用于配置「Descendant Renderer Widget」的布局信息；</p>
<p>「Renderer Widget」 —— 渲染类 Widget，是最核心的 Widget 类型，会直接参与后面的「Layout」、「Paint」流程，无论是「Component Widget」还是「Proxy Widget」最终都会映射到「Renderer Widget」上，否则将无法被绘制到屏幕上。这 3 类 Widget 中，只有「Renderer Widget」有与之一一对应的「Render Object」。</p>

        <h2 id="核心方法源码分析"   >
          <a href="#核心方法源码分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#核心方法源码分析" class="headerlink" title="核心方法源码分析"></a>核心方法源码分析</h2>
      <p>下面，我们重点介绍各类型 Widget 的核心方法，以便更好地理解 Widget 是如何参与整个 UI 的构建过程。</p>

        <h3 id="Widget-1"   >
          <a href="#Widget-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#Widget-1" class="headerlink" title="Widget"></a>Widget</h3>
      <p>Widget，所有 Widget 的基类。</p>
<p>如上图所示，在 Widget 基类中有 3 个重要的方法 (属性)：</p>
<p>Key key —— 在同一父节点下，用作兄弟节点间的唯一标识，主要用于控制当 Widget 更新时，对应的 Element 如何处理 (是更新还是新建)。若某 Widget 是其「Parent Widget」唯一的子节点时，一般不用设置 key；</p>
<p>GlobalKey 是一类较特殊的<code>key</code>，在介绍<code>Element</code>时会附带介绍。</p>
<p>Element createElement() —— 每个 Widget 都有一个与之对应的 Element，由该方法负责创建，createElement 可以理解为设计模式中的工厂方法，具体的 Element 类型由对应的 Widget 子类负责创建；</p>
<p>static bool canUpdate(Widget oldWidget, Widget newWidget) —— 是否可以用 new widget 修改前一帧用 old widget 生成的 Element，而不是创建新的 Element，Widget 类的默认实现为：2 个 Widget 的 runtimeType 与 key 都相等时，返回 true，即可以直接更新 (key 为 null 时，认为相等)。</p>
<p>上述更新流程，同样在介绍 Element 时会重点分析。</p>

        <h3 id="StatelessWidget"   >
          <a href="#StatelessWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h3>
      <p>无状态-组合型 Widget，由其 build 方法描述组合 UI 的层级结构。在其生命周期内状态不可变。</p>
<p>ps: 对于有父子关系的类，在子类中只会介绍新增或有变化的方法</p>
<p>StatelessElement createElement() ——「Stateless Widget」对应的 Element 为 StatelessElement，一般情况下 StatelessWidget 子类不必重写该方法，即子类对应的 Element 也是 StatelessElement；</p>
<p>Widget build(BuildContext context) —— 算是 Flutter 体系中的核心方法之一，以『声明式 UI』的形式描述了该组合式 Widget 的 UI 层级结构及样式信息，也是开发 Flutter 应用的主要工作『场所』。该方法在 3 种情况下被调用：</p>
<p>Widget 第一次被加入到 Widget Tree 中 (更准确地说是其对应的 Element 被加入到 Element Tree 时，即 Element 被挂载『mount』时)；<br>「Parent Widget」修改了其配置信息；<br>该 Widget 依赖的「Inherited Widget」发生变化时。</p>
<p>当「Parent Widget」或 依赖的「Inherited Widget」频繁变化时，build 方法也会频繁被调用。因此，提升 build 方法的性能就显得十分重要，Flutter 官方给出了几点建议：</p>
<p>减少不必要的中间节点，即减少 UI 的层级，如：对于「Single Child Widget」，没必要通过组合「Row」、「Column」、「Padding」、「SizedBox」等复杂的 Widget 达到某种布局的目标，或许通过简单的「Align」、「CustomSingleChildLayout」即可实现。又或者，为了实现某种复杂精细的 UI 效果，不一定要通过组合多个「Container」，再附加「Decoration」来实现，通过 「CustomPaint」自定义或许是更好的选择；</p>
<p>尽可能使用 const Widget，为 Widget 提供 const 构造方法；</p>
<p>关于 const constructor 推荐 Dart Constant Constructors 看看这篇文章的评论。</p>
<p>必要时，可以将「Stateless Widget」重构成「Stateful Widget」，以便可以使用「Stateful Widget」中一些特定的优化手法，如：缓存「sub trees」的公共部分，并在改变树结构时使用 GlobalKey；</p>
<p>尽量减小 rebuilt 范围，如：某个 Widget 因使用了「Inherited Widget」，导致频繁 rebuilt，可以将真正依赖「Inherited Widget」的部分提取出来，封装成更小的独立 Widget，并尽量将该独立 Widget 推向树的叶子节点，以便减小 rebuilt 时受影响的范围。</p>

        <h3 id="StatefulWidget"   >
          <a href="#StatefulWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h3>
      <p>有状态-组合型 Widget，但要注意的是 StatefulWidget 本身还是不可变的，其可变状态存在于 State 中。</p>
<p>StatefulElement createElement() ——「Stateful Widget」对应的 Element 为 StatefulElement，一般情况下 StatefulWidget 子类不用重写该方法，即子类对应的 Element 也是 StatefulElement；</p>
<p>State createState() —— 创建对应的 State，该方法在 StatefulElement 的构造方法中被调用。可以简单地理解为当「Stateful Widget」被添加到 Widget Tree 时会调用该方法。</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码已精简处理(本文中其他代码会做同样的简化处理)</span></span><br><span class="line">StatefulElement(StatefulWidget widget)</span><br><span class="line">: \_state = widget.createState(), <span class="keyword">super</span>(widget) &#123;</span><br><span class="line">\_state.\_element = <span class="keyword">this</span>;</span><br><span class="line">\_state.\_widget = widget;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>实际上是「Stateful Widget」对应的「Stateful Element」被添加到 Element Tree 时，伴随「Stateful Element」的初始化，createState 方法被调用。<br>从后文可知一个 Widget 实例可以对应多个 Element 实例 (也就是同一份配置信息 (Widget) 可以在 Element Tree 上不同位置配置多个 Element 节点)，因此，createState 方法在「Stateful Widget」生命周期内可能会被调用多次。</p>
<p>另外，需要注意的是配有 GlobalKey 的 Widget 对应的 Element 在整个 Element Tree 中只有一个实例。</p>

        <h3 id="State"   >
          <a href="#State" class="heading-link"><i class="fas fa-link"></i></a><a href="#State" class="headerlink" title="State"></a>State</h3>
      <p>The logic and internal state for a 「Stateful Widget」.</p>
<p>State 用于处理「Stateful Widget」的业务逻辑以及可变状态。<br>由于其内部状态是可变的，故 State 有较复杂的生命周期：</p>
<p>如上图，State 的生命周期大致可以分为 8 个阶段：</p>
<p>在对应的「Stateful Element」被挂载 (mount) 到树上时，通过 StatefulElement.constructor –&gt; StatefulWidget.createState 创建 State 实例；</p>
<p>从 StatefulElement.constructor 中的_state._element &#x3D; this;可知，State._emelent 指向了对应的 Element 实例，而我们熟知的 State.context 引用的就是这个_element：BuildContext get context &#x3D;&gt; _element;。<br>State 实例与 Element 实例间的绑定关系一经确定，在整个生命周期内不会再变了 (Element 对应的 Widget 可能会变，但对应的 State 永远不会变)，期间，Element 可以在树上移动，但上述关系不会变 (即「Stateful Element」是带着状态移动的)。</p>
<p>StatefulElement 在挂载过程中接着会调用 State.initState，子类可以重写该方法执行相关的初始化操作 (此时可以引用 context、widget 属性)；</p>
<p>同样在挂载过程中会调用 State.didChangeDependencies，该方法在 State 依赖的对象 (如：「Inherited Widget」) 状态发生变化时也会被调用，<em>子类很少需要重写该方法，</em>除非有非常耗时不宜在 build 中进行的操作，因为在依赖有变化时 build 方法也会被调用；</p>
<p>此时，State 初始化已完成，其 build 方法此后可能会被多次调用，在状态变化时 State 可通过 setState 方法来触发其子树的重建；</p>
<p>此时，「element tree」、「renderobject tree」、「layer tree」已构建完成，完整的 UI 应该已呈现出来。此后因为变化，「element tree」中「parent element」可能会对树上该位置的节点用新配置 (Widget) 进行重建，当新老配置 (oldWidget、newWidget)具有相同的「runtimeType」&amp;&amp;「key」时，framework 会用 newWidget 替换 oldWidget，并触发一系列的更新操作 (在子树上递归进行)。同时，State.didUpdateWidget 方法被调用，子类重写该方法去响应 Widget 的变化；</p>
<p>上述 3 棵树以及更新流程在后续文章中会有详细介绍</p>
<p>在 UI 更新过程中，任何节点都有被移除的可能，State 也会随之移除，(如上一步中「runtimeType」||「key」不相等时)。此时会调用 State.deactivate 方法，由于被移除的节点可能会被重新插入树中某个新的位置上，故子类重写该方法以清理与节点位置相关的信息 (如：该 State 对其他 element 的引用)、同时，不应在该方法中做资源清理；</p>
<p>重新插入操作必须在当前帧动画结束之前</p>
<p>当节点被重新插入树中时，State.build 方法被再次调用；</p>
<p>对于在当前帧动画结束时尚未被重新插入的节点，State.dispose 方法被执行，State 生命周期随之结束，此后再调用 State.setState 方法将报错。子类重写该方法以释放任何占用的资源。</p>
<p>至此，State 中的核心方法基本都已在上述过程中介绍了，下面重点看一下 setState 方法：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(fn != <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.defunct) &#123;</span><br><span class="line">    <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_debugLifecycleState == _StateLifecycle.created &amp;&amp; !mounted) &#123;</span><br><span class="line">    <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">dynamic</span> result = fn() <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line"><span class="keyword">assert</span>(() &#123;</span><br><span class="line">  <span class="keyword">if</span> (result <span class="keyword">is</span> Future) &#123;</span><br><span class="line">  <span class="keyword">throw</span> FlutterError.fromParts(&lt;DiagnosticsNode&gt;[...]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">element.markNeedsBuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>从上述源码可以看到，关于 setState 方法有几点值得关注：</p>
<p>在 State.dispose 后不能调用 setState；</p>
<p>在 State 的构造方法中不能调用 setState；</p>
<p>setState 方法的回调函数 (fn) 不能是异步的 (返回值为 Future)，原因很简单，因为从流程设计上 framework 需要根据回调函数产生的新状态去刷新 UI；</p>
<p>通过 setState 方法之所以能更新 UI，是在其内部调用_element.markNeedsBuild()实现的 (具体过程在介绍 Element 时再详细分析)。</p>
<p>关于 State 最后再强调 2 点：</p>
<p>若 State.build 方法依赖了自身状态会变化的对象，如：ChangeNotifier、Stream 或其他可以被订阅的对象，需要确保在 initState、didUpdateWidget、dispose 等 3 方法间有正确的订阅 (subscribe) 与取消订阅 (unsubscribe) 的操作：</p>
<p>在 initState 中执行 subscribe；<br>如果关联的「Stateful Widget」与订阅有关，在 didUpdateWidget 中先取消旧的订阅，再执行新的订阅；<br>在 dispose 中执行 unsubscribe。</p>
<p>在 State.initState 方法中不能调用 BuildContext.dependOnInheritedWidgetOfExactType，但 State.didChangeDependencies 会随之执行，在该方法中可以调用。</p>

        <h3 id="ParentDataWidget"   >
          <a href="#ParentDataWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#ParentDataWidget" class="headerlink" title="ParentDataWidget"></a>ParentDataWidget</h3>
      <p>ParentDataWidget 以及下面要介绍的 InheritedElement 都继承自 ProxyWidget，由于 ProxyWidget 作为抽象基类本身没有任何功能，故下面直接介绍 ParentDataWidget、InheritedElement。</p>
<p>ParentDataWidget 作为 Proxy 型 Widget，其功能主要是为其他 Widget 提供 ParentData 信息。虽然其 child widget 不一定是 RenderObejctWidget 类型，但其提供的 ParentData 信息最终都会落地到 RenderObejctWidget 类型子孙 Widget 上。</p>
<p>ParentData 是『parent renderobject』在 layout『child renderobject』时使用的辅助定位信息，详细信息会在介绍 RenderObject 时介绍。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">attachRenderObject</span>(<span class="params">dynamic newSlot</span>) &#123;</span><br><span class="line"><span class="title function_">assert</span>(\_ancestorRenderObjectElement == <span class="literal">null</span>);</span><br><span class="line">\_slot = newSlot;</span><br><span class="line">\_ancestorRenderObjectElement = \<span class="title function_">_findAncestorRenderObjectElement</span>();</span><br><span class="line">\_ancestorRenderObjectElement?.<span class="title function_">insertChildRenderObject</span>(renderObject, newSlot);</span><br><span class="line">final <span class="title class_">ParentDataElement</span>&lt;<span class="title class_">RenderObjectWidget</span>&gt; parentDataElement = \<span class="title function_">_findAncestorParentDataElement</span>();</span><br><span class="line"><span class="keyword">if</span> (parentDataElement != <span class="literal">null</span>)</span><br><span class="line">\<span class="title function_">_updateParentData</span>(parentDataElement.<span class="property">widget</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ParentDataElement</span>&lt;<span class="title class_">RenderObjectWidget</span>&gt; \<span class="title function_">_findAncestorParentDataElement</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title class_">Element</span> ancestor = \_parent;</span><br><span class="line"><span class="keyword">while</span> (ancestor != <span class="literal">null</span> &amp;&amp; ancestor is! <span class="title class_">RenderObjectElement</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ancestor is <span class="title class_">ParentDataElement</span>&lt;<span class="title class_">RenderObjectWidget</span>&gt;)</span><br><span class="line"><span class="keyword">return</span> ancestor;</span><br><span class="line">ancestor = ancestor.\_parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> \<span class="title function_">_updateParentData</span>(<span class="params">ParentDataWidget&lt;RenderObjectWidget&gt; parentData</span>) &#123;</span><br><span class="line">parentData.<span class="title function_">applyParentData</span>(renderObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面这段代码来自 RenderObjectElement，可以看到在其 attachRenderObject 方法第 6 行从祖先节点找 ParentDataElement，如果找到就用其 Widget(ParentDataWidget) 中的 parentData 信息去设置 Render Obejct。在查找过程中如查到 RenderObjectElement (第 13 行)，说明当前 RenderObject 没有 Parent Data 信息。<br>最终会调用到 ParentDataWidget.applyParentData(RenderObject renderObject)，子类需要重写该方法，以便设置对应 RenderObject.parentData。</p>
<p>来看个例子，通常配合 Stack 使用的 Positioned(继承自 ParentDataWidget)：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> applyParentData(RenderObject renderObject) &#123;</span><br><span class="line"><span class="keyword">assert</span>(renderObject.parentData <span class="keyword">is</span> StackParentData);</span><br><span class="line"><span class="keyword">final</span> StackParentData parentData = renderObject.parentData;</span><br><span class="line"><span class="built_in">bool</span> needsLayout = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (parentData.left != left) &#123;</span><br><span class="line">parentData.left = left;</span><br><span class="line">needsLayout = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (parentData.width != width) &#123;</span><br><span class="line">parentData.width = width;</span><br><span class="line">needsLayout = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (needsLayout) &#123;</span><br><span class="line"><span class="keyword">final</span> AbstractNode targetParent = renderObject.parent;</span><br><span class="line"><span class="keyword">if</span> (targetParent <span class="keyword">is</span> RenderObject)</span><br><span class="line">targetParent.markNeedsLayout();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>可以看到，Positioned 在必要时将自己的属性赋值给了对应的 RenderObject.parentData (此处是 StackParentData)，并对「parent render object」调用 markNeedsLayout(第 19 行)，以便重新 layout，毕竟修改了布局相关的信息。</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentDataWidget</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span>&gt; <span class="keyword">extends</span> <span class="title">ProxyWidget</span></span></span><br></pre></td></tr></table></div></figure>

<p>如上所示，ParentDataWidget 在定义上使用了泛型<T extends RenderObjectWidget>，其背后的含义是：<br>从当前 ParentDataWidget 节点向上追溯形成的祖先节点链(『parent widget chain』)上，在 2 个 ParentDataWidget 类型的节点形成的链上至少要有一个『RenderObject Widget』类型的节点。因为一个『RenderObject Widget』不能接受来自 2 个及以上『ParentData Widget』的信息。</p>

        <h3 id="InheritedWidget"   >
          <a href="#InheritedWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3>
      <p>InheritedWidget 用于在树上向下传递数据。<br>通过 BuildContext.dependOnInheritedWidgetOfExactType 可以获取最近的「Inherited Widget」，需要注意的是通过这种方式获取「Inherited Widget」时，当「Inherited Widget」状态有变化时，会导致该引用方 rebuild。</p>
<p>具体原理在介绍 Element 时会详细分析。</p>
<p>通常，为了使用方便会「Inherited Widget」会提供静态方法 of，在该方法中调用 BuildContext.dependOnInheritedWidgetOfExactType。of 方法可以直接返回「Inherited Widget」，也可以是具体的数据。<br>有时，「Inherited Widget」是作为另一个类的实现细节而存在的，其本身是私有的(外部不可见)，此时 of 方法就会放到对外公开的类上。最典型的例子就是 Theme，其本身是 StatelessWidget 类型，但其内部创建了一个「Inherited Widget」：_InheritedTheme，of 方法就定义在上 Theme 上：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> ThemeData of(BuildContext context, &#123; <span class="built_in">bool</span> shadowThemeOnly = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line"><span class="keyword">final</span> \_InheritedTheme inheritedTheme = context.dependOnInheritedWidgetOfExactType&lt;\_InheritedTheme&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ThemeData.localize(theme, theme.typography.geometryThemeFor(category));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>该 of 方法返回的是 ThemeData 类型的具体数据，并在其内部首先调用了 BuildContext.dependOnInheritedWidgetOfExactType。<br>我们经常使用的「Inherited Widget」莫过于 MediaQuery，同样提供了 of 方法：</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MediaQueryData of(BuildContext context, &#123; <span class="built_in">bool</span> nullOk = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line"><span class="keyword">final</span> MediaQuery query = context.dependOnInheritedWidgetOfExactType&lt;MediaQuery&gt;();</span><br><span class="line"><span class="keyword">if</span> (query != <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> query.data;</span><br><span class="line"><span class="keyword">if</span> (nullOk)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>InheritedElement createElement() ——「Inherited Widget」对应的 Element 为 InheritedElement，一般情况下 InheritedElement 子类不用重写该方法；</p>
<p>bool updateShouldNotify(covariant InheritedWidget oldWidget) —— 在「Inherited Widget」rebuilt 时判断是否需要 rebuilt 那些依赖它的 Widget；</p>
<p>如下是 MediaQuery.updateShouldNotify 的实现，在新老 Widget.data 不相等时才 rebuilt 那依赖的 Widget。</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> updateShouldNotify(MediaQuery oldWidget) =&gt; data != oldWidget.data;</span><br></pre></td></tr></table></div></figure>


        <h3 id="RenderObjectWidget"   >
          <a href="#RenderObjectWidget" class="heading-link"><i class="fas fa-link"></i></a><a href="#RenderObjectWidget" class="headerlink" title="RenderObjectWidget"></a>RenderObjectWidget</h3>
      <p>真正与渲染相关的 Widget，属于最核心的类型，一切其他类型的 Widget 要渲染到屏幕上，最终都要回归到该类型的 Widget 上。</p>
<p>RenderObjectElement createElement() ——「RenderObject Widget」对应的 Element 为 RenderObjectElement，由于 RenderObjectElement 也是抽象类，故子类需要重写该方法；</p>
<p>RenderObject createRenderObject(BuildContext context) —— 核心方法，创建 Render Widget 对应的 Render Object，同样子类需要重写该方法。该方法在对应的 Element 被挂载到树上时调用(Element.mount)，即在 Element 挂载过程中同步构建了「Render Tree」(详细过程后续文章会详细分析)；</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line">RenderFlex createRenderObject(BuildContext context) &#123;</span><br><span class="line"><span class="keyword">return</span> RenderFlex(</span><br><span class="line">direction: direction,</span><br><span class="line">mainAxisAlignment: mainAxisAlignment,</span><br><span class="line">mainAxisSize: mainAxisSize,</span><br><span class="line">crossAxisAlignment: crossAxisAlignment,</span><br><span class="line">textDirection: getEffectiveTextDirection(context),</span><br><span class="line">verticalDirection: verticalDirection,</span><br><span class="line">textBaseline: textBaseline,</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>上面是 Flex.createRenderObject 的源码，真实感受一下 (还是代码更有感觉)。可以看到，用 Flex 的信息(配置)初始化了 RenderFlex。</p>
<p>Flex 是 Row、Column 的基类，RenderFlex 继承自 RenderBox，后者继续自 RenderObject。</p>
<p>void updateRenderObject(BuildContext context, covariant RenderObject renderObject) —— 核心方法，在 Widget 更新后，修改对应的 Render Object。该方法在首次 build 以及需要更新 Widget 时都会调用；</p>
<figure class="highlight dart"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> updateRenderObject(BuildContext context, <span class="keyword">covariant</span> RenderFlex renderObject) &#123;</span><br><span class="line">renderObject</span><br><span class="line">..direction = direction</span><br><span class="line">..mainAxisAlignment = mainAxisAlignment</span><br><span class="line">..mainAxisSize = mainAxisSize</span><br><span class="line">..crossAxisAlignment = crossAxisAlignment</span><br><span class="line">..textDirection = getEffectiveTextDirection(context)</span><br><span class="line">..verticalDirection = verticalDirection</span><br><span class="line">..textBaseline = textBaseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Flex.updateRenderObject 的源码也很简单，与 Flex.createRenderObject 几乎一一对应，用当前 Flex 的信息修改 renderObject。</p>
<p>void didUnmountRenderObject(covariant RenderObject renderObject) —— 对应的「Render Object」从「Render Tree」上移除时调用该方法。</p>
<p>RenderObjectWidget 的几个子类：LeafRenderObjectWidget、SingleChildRenderObjectWidget、MultiChildRenderObjectWidget 只是重写了 createElement 方法以便返回各自对应的具体的 Element 类实例。</p>

        <h1 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a><a href="#小结" class="headerlink" title="小结"></a>小结</h1>
      <p>至此，重要的基础型 Widget 基本介绍完了，总结一下：</p>
<p>Widget 本质上是 UI 的配置信息 (附加部分业务逻辑)，并不存在一颗真实的「Widget Tree」(与「Element Tree」、「RenderObject Tree」以及「Layer Tree」相比)；</p>
<p>Widget 从功能上可以分为 3 类：「Component Widget」、「Proxy Widget」以及「Renderer Widget」；</p>
<p>Widget 与 Element 一一对应，Widget 提供创建 Element 的方法 (createElement，本质上是一个工厂方法)；</p>
<p>只有「Renderer Widget」才会参与最终的 UI 生成过程(Layout、Paint)，只有该类型的 Widget 才有与之对应的「Render Object」，同样由其提供创建方法(createRenderObject)。</p>
<p>下篇再见！</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/Flutter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%80-Widget/">Flutter 源码解析(一) Widget</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2023-01-09</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-20</span></span></div></header><div class="post-body"><div class="post-excerpt"></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/React%20hooks%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">React hooks 源码解析</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-04-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">Updated</span><span class="post-meta-item__value">2023-02-20</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>本文将讲解 hooks 的执行过程以及常用的 hooks 的源码。</p>

        <h1 id="hooks-相关数据结构"   >
          <a href="#hooks-相关数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#hooks-相关数据结构" class="headerlink" title="hooks 相关数据结构"></a>hooks 相关数据结构</h1>
      <p>要理解 hooks 的执行过程，首先想要大家对 hooks 相关的数据结构有所了解，便于后面大家顺畅地阅读代码。</p>

        <h2 id="Hook"   >
          <a href="#Hook" class="heading-link"><i class="fas fa-link"></i></a><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h2>
      <p>每一个 hooks 方法都会生成一个类型为 Hook 的对象，用来存储一些信息，前面提到过函数组件 fiber 中的 memoizedState 会存储 hooks 链表，每个链表结点的结构就是 Hook。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Hook</span> = &#123;|</span><br><span class="line">  <span class="attr">memoizedState</span>: any, <span class="comment">// 上次渲染时所用的 state</span></span><br><span class="line">  <span class="attr">baseState</span>: any, <span class="comment">// 已处理的 update 计算出的 state</span></span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="title class_">Update</span>&lt;any, any&gt; | <span class="literal">null</span>, <span class="comment">// 未处理的 update 队列（一般是上一轮渲染未完成的 update）</span></span><br><span class="line">  <span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;any, any&gt; | <span class="literal">null</span>, <span class="comment">// 当前出发的 update 队列</span></span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Hook</span> | <span class="literal">null</span>, <span class="comment">// 指向下一个 hook，形成链表结构</span></span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></div></figure>

<p>举个例子，我们通过函数组件使用了两个 useState hooks：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&quot;小科比&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> [age, setAge] = <span class="title function_">useState</span>(<span class="number">23</span>);</span><br></pre></td></tr></table></div></figure>

<p>则实际的 Hook 结构如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">next</span>: &#123;</span><br><span class="line">    <span class="attr">memoizedState</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">baseState</span>: <span class="number">23</span>,</span><br><span class="line">    <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>不同的 hooks 方法，memoizedState 存储的内容不同，常用的 hooks memoizedState 存储的内容如下：</p>
<ul>
<li>useState: state</li>
<li>useEffect: effect 对象</li>
<li>useMemo&#x2F;useCallback: [callback, deps]</li>
<li>useRef: { current: xxx }</li>
</ul>

        <h2 id="Update-amp-UpdateQueue"   >
          <a href="#Update-amp-UpdateQueue" class="heading-link"><i class="fas fa-link"></i></a><a href="#Update-amp-UpdateQueue" class="headerlink" title="Update &amp; UpdateQueue"></a>Update &amp; UpdateQueue</h2>
      <p>Update 和 UpdateQueue 是存储 useState 的 state 及 useReducer 的 reducer 相关内容的数据结构。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line">type <span class="title class_">Update</span>&lt;S, A&gt; = &#123;|</span><br><span class="line">  <span class="attr">lane</span>: <span class="title class_">Lane</span>, <span class="comment">// 优先级</span></span><br><span class="line">  <span class="comment">// reducer 对应要执行的 action</span></span><br><span class="line">  <span class="attr">action</span>: A,</span><br><span class="line">  <span class="comment">// 触发 dispatch 时的 reducer</span></span><br><span class="line">  <span class="attr">eagerReducer</span>: (<span class="function">(<span class="params">S, A</span>) =&gt;</span> S) | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 触发 dispatch 是的 state</span></span><br><span class="line">  <span class="attr">eagerState</span>: S | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 下一个要执行的 Update</span></span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Update</span>&lt;S, A&gt;,</span><br><span class="line">  <span class="comment">// react 的优先级权重</span></span><br><span class="line">  priority?: <span class="title class_">ReactPriorityLevel</span>,</span><br><span class="line">|&#125;;</span><br><span class="line"></span><br><span class="line">type <span class="title class_">UpdateQueue</span>&lt;S, A&gt; = &#123;|</span><br><span class="line">  <span class="comment">// 当前要触发的 update</span></span><br><span class="line">  <span class="attr">pending</span>: <span class="title class_">Update</span>&lt;S, A&gt; | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 存放 dispatchAction.bind() 的值</span></span><br><span class="line">  <span class="attr">dispatch</span>: (<span class="function">(<span class="params">A</span>) =&gt;</span> mixed) | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 上一次 render 的 reducer</span></span><br><span class="line">  <span class="attr">lastRenderedReducer</span>: (<span class="function">(<span class="params">S, A</span>) =&gt;</span> S) | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 上一次 render 的 state</span></span><br><span class="line">  <span class="attr">lastRenderedState</span>: S | <span class="literal">null</span>,</span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></div></figure>

<p>每次调用 setState 或者 useReducer 的 dispatch 时，都会生成一个 Update 类型的对象，并将其添加到 UpdateQueue 队列中。<br>例如，在如下的函数组件中:</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = <span class="title function_">useState</span>(<span class="string">&quot;小科比&quot;</span>);</span><br><span class="line"><span class="title function_">setName</span>(<span class="string">&quot;大科比&quot;</span>);</span><br></pre></td></tr></table></div></figure>

<p>当我们点击 input 按钮时，执行了 setName()，此时对应的 hook 结构如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">queue</span>: &#123;</span><br><span class="line">    <span class="attr">pending</span>: &#123;</span><br><span class="line">      <span class="attr">lane</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">action</span>: <span class="string">&#x27;大科比&#x27;</span>,</span><br><span class="line">      <span class="attr">eagerState</span>: <span class="string">&#x27;大科比&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">lastRenderedState</span>: <span class="string">&#x27;小科比&#x27;</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>最后 react 会遍历 UpdateQueue 中的每个 Update 去进行更新。</p>

        <h2 id="Effect"   >
          <a href="#Effect" class="heading-link"><i class="fas fa-link"></i></a><a href="#Effect" class="headerlink" title="Effect"></a>Effect</h2>
      <p>Effect 结构是和 useEffect 等 hooks 相关的，我们看一下它的结构：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">Effect</span> = &#123;|</span><br><span class="line">  <span class="attr">tag</span>: <span class="title class_">HookFlags</span>, <span class="comment">// 标记是否有 effect 需要执行</span></span><br><span class="line">  <span class="attr">create</span>: <span class="function">() =&gt;</span> (<span class="function">() =&gt;</span> <span class="keyword">void</span>) | <span class="keyword">void</span>, <span class="comment">// 回调函数</span></span><br><span class="line">  <span class="attr">destroy</span>: (<span class="function">() =&gt;</span> <span class="keyword">void</span>) | <span class="keyword">void</span>, <span class="comment">// 销毁时触发的回调</span></span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span>, <span class="comment">// 依赖的数组</span></span><br><span class="line">  <span class="attr">next</span>: <span class="title class_">Effect</span>, <span class="comment">// 下一个要执行的 Effect</span></span><br><span class="line">|&#125;;</span><br></pre></td></tr></table></div></figure>

<p>当我们的函数组件中使用了如下的 useEffect 时：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></div></figure>

<p>对应的 Hook 如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">memoizedState</span>: &#123;</span><br><span class="line">    <span class="attr">create</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>) &#125;,</span><br><span class="line">    <span class="attr">destroy</span>: <span class="function">() =&gt;</span> &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bye&#x27;</span>) &#125;,</span><br><span class="line">    <span class="attr">deps</span>: [],</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">baseState</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="执行过程"   >
          <a href="#执行过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1>
      <p>下面我们探索一下 hooks 在 react 中具体的执行流程。<br>引入 hooks<br>我们以一个简单的 hooks 写法的 react 应用程序为例去寻找 hooks 源码:</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&quot;增加&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          setCount(count + 1);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>根据引入的 useState api，我们找到 react hooks 的入口文件：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react/src/ReactHooks.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveDispatcher</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> dispatcher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> useState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatcher = <span class="title function_">resolveDispatcher</span>();</span><br><span class="line">  <span class="keyword">return</span> dispatcher.<span class="title function_">useState</span>(initialState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></div></figure>

<p>根据上面的源码我们可以知道，所有的 hooks api 都是挂载在 resolveDispatcher 中返回的 dispatcher 对象上面的，也就是挂载在 ReactCurrentDispatcher.current 上面，那么我们再继续去看一下 ReactCurrentDispatcher 是什么：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react/src/ReactCurrentDispatcher.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> type &#123; <span class="title class_">Dispatcher</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-reconciler/src/ReactInternalTypes&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReactCurrentDispatcher</span> = &#123;</span><br><span class="line">  <span class="attr">current</span>: (<span class="attr">null</span>: <span class="literal">null</span> | <span class="title class_">Dispatcher</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">ReactCurrentDispatcher</span>;</span><br></pre></td></tr></table></div></figure>

<p>到这里我们的线索就断了，ReactCurrentDispatcher 上只有一个 current 用于挂在 hooks，但是 hooks 的详细源码以及 ReactCurrentDispatcher 的具体内容我们并没有找到在哪里，所以我们只能另寻出路，从 react 的执行过程去入手。</p>

        <h2 id="函数组件更新过程"   >
          <a href="#函数组件更新过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数组件更新过程" class="headerlink" title="函数组件更新过程"></a>函数组件更新过程</h2>
      <p>我们的 hooks 都是在函数组件中使用的，所以让我们去看一下 render 过程关于函数组件的更新。render 过程中的调度是从 beginWork 开始的，来到 beginWork 的源码后我们可以发现，针对函数组件的渲染和更新，使用了 updateFunctionComponent 函数：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberBeginWork.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">beginWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">FunctionComponent</span>: &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">updateFunctionComponent</span>(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        <span class="title class_">Component</span>,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>那我们在继续看一下 updateFunctionComponent 函数的源码，里面调用了 renderWithHooks 函数，这便是函数组件更新和渲染过程执行的入口：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberBeginWork.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateFunctionComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current,</span></span><br><span class="line"><span class="params">  workInProgress,</span></span><br><span class="line"><span class="params">  Component,</span></span><br><span class="line"><span class="params">  nextProps: any,</span></span><br><span class="line"><span class="params">  renderLanes</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  nextChildren = <span class="title function_">renderWithHooks</span>(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    <span class="title class_">Component</span>,</span><br><span class="line">    nextProps,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="renderWithHooks"   >
          <a href="#renderWithHooks" class="heading-link"><i class="fas fa-link"></i></a><a href="#renderWithHooks" class="headerlink" title="renderWithHooks"></a>renderWithHooks</h2>
      <p>费劲千辛万苦，我们终于来到了函数组件更新过程的执行入口 —— renderWithHooks 函数的源码：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberBeginWork.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> renderWithHooks&lt;<span class="title class_">Props</span>, <span class="title class_">SecondArg</span>&gt;(</span><br><span class="line">  <span class="attr">current</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">workInProgress</span>: <span class="title class_">Fiber</span>,</span><br><span class="line">  <span class="title class_">Component</span>: <span class="function">(<span class="params">p: Props, arg: SecondArg</span>) =&gt;</span> any,</span><br><span class="line">  <span class="attr">props</span>: <span class="title class_">Props</span>,</span><br><span class="line">  <span class="attr">secondArg</span>: <span class="title class_">SecondArg</span>,</span><br><span class="line">  <span class="attr">nextRenderLanes</span>: <span class="title class_">Lanes</span>,</span><br><span class="line">): any &#123;</span><br><span class="line">  renderLanes = nextRenderLanes;</span><br><span class="line">  <span class="comment">// currentlyRenderingFiber 指向当前所执行的 fiber</span></span><br><span class="line">  currentlyRenderingFiber = workInProgress;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 置空 workInProgress fiber 中的 memoizedState 和 updateQueue</span></span><br><span class="line">  workInProgress.<span class="property">memoizedState</span> = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.<span class="property">updateQueue</span> = <span class="literal">null</span>;</span><br><span class="line">  workInProgress.<span class="property">lanes</span> = <span class="title class_">NoLanes</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 根据是否首次渲染，分别将 HooksDispatcherOnMount 和 HooksDispatcherOnUpdate 赋值给 ReactCurrentDispatcher.current</span></span><br><span class="line">  <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> =</span><br><span class="line">  current === <span class="literal">null</span> || current.<span class="property">memoizedState</span> === <span class="literal">null</span></span><br><span class="line">  ? <span class="title class_">HooksDispatcherOnMount</span></span><br><span class="line">  : <span class="title class_">HooksDispatcherOnUpdate</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行函数组件的构造函数</span></span><br><span class="line">  <span class="keyword">let</span> children = <span class="title class_">Component</span>(props, secondArg);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (didScheduleRenderPhaseUpdateDuringThisPass) &#123;</span><br><span class="line">    <span class="comment">// didScheduleRenderPhaseUpdateDuringThisPass 为 true 说明发生了 re-render，会再次执行 render</span></span><br><span class="line">    <span class="keyword">let</span> <span class="attr">numberOfReRenders</span>: number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      didScheduleRenderPhaseUpdateDuringThisPass = <span class="literal">false</span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = **<span class="variable constant_">DEV</span>**</span><br><span class="line">      ? <span class="title class_">HooksDispatcherOnRerenderInDEV</span></span><br><span class="line">      : <span class="title class_">HooksDispatcherOnRerender</span>;</span><br><span class="line"></span><br><span class="line">      children = <span class="title class_">Component</span>(props, secondArg);</span><br><span class="line">    &#125; <span class="keyword">while</span> (didScheduleRenderPhaseUpdateDuringThisPass);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 函数执行结束后，关闭 hooks 入口</span></span><br><span class="line">  <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">ContextOnlyDispatcher</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...当前 fiber 的任务执行结束，重置全局变量</span></span><br><span class="line"></span><br><span class="line">  renderLanes = <span class="title class_">NoLanes</span>;</span><br><span class="line">  currentlyRenderingFiber = (<span class="attr">null</span>: any);</span><br><span class="line"></span><br><span class="line">  currentHook = <span class="literal">null</span>;</span><br><span class="line">  workInProgressHook = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  didScheduleRenderPhaseUpdate = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><strong>renderWithHooks</strong>函数中首先会将 workInProgress fiber 树的 memoizedState（前面深入理解 fiber 一文中提到过，memoizedState 记录了当前页面的 state，在函数组件中，它以链表的形式记录了 hooks 信息） 和 updateQueue 置为 null，在接下来的函数组件执行过程中，会把新的 hooks 信息挂载到这两个属性上，然后在 commit 阶段，会将根据 current fiber 树构建当前的 workInProgress fiber 树，并保存 hooks 信息，用于替换真实的 DOM 元素节点。<br>然后会通过 current 上是否有 memoizedState，判断组件是否首次渲染，从而分别将 HooksDispatcherOnMount 和 HooksDispatcherOnUpdate 赋值给 <strong>ReactCurrentDispatcher.current</strong>。<br>接下来执行**Component()**来调用函数组件的构造函数，组件的 hooks 会被依次执行，并将 hooks 的信息保存到 workInProgress fiber 上（待会儿会细讲执行过程），然后将返回的 jsx 信息保存到 children 上。<br>最后会重置一些变量，并返回函数组件执行后的 jsx。</p>

        <h2 id="不同阶段更新-Hook"   >
          <a href="#不同阶段更新-Hook" class="heading-link"><i class="fas fa-link"></i></a><a href="#不同阶段更新-Hook" class="headerlink" title="不同阶段更新 Hook"></a>不同阶段更新 Hook</h2>
      <p>现在我们终于找到了<strong>ReactCurrentDispatcher.current</strong>的定义，首次渲染时，会将 <strong>HooksDispatcherOnMount</strong>赋值给 <strong>ReactCurrentDispatcher.current</strong>，更新时，会将<strong>HooksDispatcherOnUpdate</strong> 赋值给 <strong>ReactCurrentDispatcher.current</strong>， dispatcher 上面挂在了各种 hooks：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnMount</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  <span class="attr">useCallback</span>: mountCallback,</span><br><span class="line">  <span class="attr">useContext</span>: readContext,</span><br><span class="line">  <span class="attr">useEffect</span>: mountEffect,</span><br><span class="line">  <span class="attr">useImperativeHandle</span>: mountImperativeHandle,</span><br><span class="line">  <span class="attr">useLayoutEffect</span>: mountLayoutEffect,</span><br><span class="line">  <span class="attr">useMemo</span>: mountMemo,</span><br><span class="line">  <span class="attr">useReducer</span>: mountReducer,</span><br><span class="line">  <span class="attr">useRef</span>: mountRef,</span><br><span class="line">  <span class="attr">useState</span>: mountState,</span><br><span class="line">  <span class="attr">useDebugValue</span>: mountDebugValue,</span><br><span class="line">  <span class="attr">useDeferredValue</span>: mountDeferredValue,</span><br><span class="line">  <span class="attr">useTransition</span>: mountTransition,</span><br><span class="line">  <span class="attr">useMutableSource</span>: mountMutableSource,</span><br><span class="line">  <span class="attr">useOpaqueIdentifier</span>: mountOpaqueIdentifier,</span><br><span class="line"></span><br><span class="line">  <span class="attr">unstable_isNewReconciler</span>: enableNewReconciler,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HooksDispatcherOnUpdate</span>: <span class="title class_">Dispatcher</span> = &#123;</span><br><span class="line">  readContext,</span><br><span class="line"></span><br><span class="line">  <span class="attr">useCallback</span>: updateCallback,</span><br><span class="line">  <span class="attr">useContext</span>: readContext,</span><br><span class="line">  <span class="attr">useEffect</span>: updateEffect,</span><br><span class="line">  <span class="attr">useImperativeHandle</span>: updateImperativeHandle,</span><br><span class="line">  <span class="attr">useLayoutEffect</span>: updateLayoutEffect,</span><br><span class="line">  <span class="attr">useMemo</span>: updateMemo,</span><br><span class="line">  <span class="attr">useReducer</span>: updateReducer,</span><br><span class="line">  <span class="attr">useRef</span>: updateRef,</span><br><span class="line">  <span class="attr">useState</span>: updateState,</span><br><span class="line">  <span class="attr">useDebugValue</span>: updateDebugValue,</span><br><span class="line">  <span class="attr">useDeferredValue</span>: updateDeferredValue,</span><br><span class="line">  <span class="attr">useTransition</span>: updateTransition,</span><br><span class="line">  <span class="attr">useMutableSource</span>: updateMutableSource,</span><br><span class="line">  <span class="attr">useOpaqueIdentifier</span>: updateOpaqueIdentifier,</span><br><span class="line"></span><br><span class="line">  <span class="attr">unstable_isNewReconciler</span>: enableNewReconciler,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>首次渲染时，<strong>HooksDispatcherOnMount</strong>上挂载的 hook 都是 mountXXX，而更新时 <strong>HooksDispatcherOnMount</strong>上挂在的 hook 都是 updateXXX。所有 mount 阶段的 hook 中，都会执行 <strong>mountWorkInProgressHook</strong>这个函数，而所有 update 阶段的 hook 中，都会执行 <strong>updateWorkInProgressHook</strong>这个函数。下面我们来看下这两个函数分别做了什么。</p>

        <h3 id="mountWorkInProgressHook"   >
          <a href="#mountWorkInProgressHook" class="heading-link"><i class="fas fa-link"></i></a><a href="#mountWorkInProgressHook" class="headerlink" title="mountWorkInProgressHook"></a>mountWorkInProgressHook</h3>
      <p>每个 hooks 方法中，都需要有一个 Hook 结构来存储相关信息。<strong>mountWorkInProgressHook</strong>中，会初始化创建一个 Hook，然后将其挂载到 workInProgress fiber 的 memoizedState 所指向的 hooks 链表上，以便于下次 update 的时候取出该 Hook：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountWorkInProgressHook</span>(<span class="params"></span>): <span class="title class_">Hook</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">hook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">    <span class="attr">memoizedState</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">baseState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">baseQueue</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">queue</span>: <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若当前 workInProgressHook 为 null，将此 hook 作为 memoizedState 的头结点</span></span><br><span class="line">    currentlyRenderingFiber.<span class="property">memoizedState</span> = workInProgressHook = hook;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 若不为 null，将 hook 挂载到链表最后</span></span><br><span class="line">    workInProgressHook = workInProgressHook.<span class="property">next</span> = hook;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="updateWorkInProgressHook"   >
          <a href="#updateWorkInProgressHook" class="heading-link"><i class="fas fa-link"></i></a><a href="#updateWorkInProgressHook" class="headerlink" title="updateWorkInProgressHook"></a>updateWorkInProgressHook</h3>
      <p><strong>updateWorkInProgressHook</strong>的作用主要是取出 current fiber 中的 hooks 链表中对应的 hook 节点，挂载到 workInProgress fiber 上的 hooks 链表：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateWorkInProgressHook</span>(<span class="params"></span>): <span class="title class_">Hook</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">nextCurrentHook</span>: <span class="literal">null</span> | <span class="title class_">Hook</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代 current fiber 链表</span></span><br><span class="line">  <span class="keyword">if</span> (currentHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若 current 为 null，从 currentlyRenderingFiber.alternate 取 current</span></span><br><span class="line">    <span class="keyword">const</span> current = currentlyRenderingFiber.<span class="property">alternate</span>;</span><br><span class="line">    <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">      nextCurrentHook = current.<span class="property">memoizedState</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextCurrentHook = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则从 current fiber 中取下一个 hook</span></span><br><span class="line">    nextCurrentHook = currentHook.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代 workInProgress fiber 链表</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">nextWorkInProgressHook</span>: <span class="literal">null</span> | <span class="title class_">Hook</span>;</span><br><span class="line">  <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// workInProgressHook 说明是首次创建</span></span><br><span class="line">    nextWorkInProgressHook 为 <span class="literal">null</span> = currentlyRenderingFiber.<span class="property">memoizedState</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 取下一个 workInProgress Hook</span></span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextWorkInProgressHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 只有 re-render 的情况下，nextWorkInProgressHook 不为 null，因为在之前的 render 过程中已经创建过 workInProgress hook 了</span></span><br><span class="line">    <span class="comment">// 此时复用</span></span><br><span class="line">    workInProgressHook = nextWorkInProgressHook;</span><br><span class="line">    nextWorkInProgressHook = workInProgressHook.<span class="property">next</span>;</span><br><span class="line"></span><br><span class="line">        currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 正常情况下，currentlyRenderingFiber.memoizedState 为 null，需要到从 current fiber 中克隆一个新的创建</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">invariant</span>(</span><br><span class="line">      nextCurrentHook !== <span class="literal">null</span>,</span><br><span class="line">      <span class="string">&#x27;Rendered more hooks than during the previous render.&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line">    currentHook = nextCurrentHook;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">newHook</span>: <span class="title class_">Hook</span> = &#123;</span><br><span class="line">      <span class="attr">memoizedState</span>: currentHook.<span class="property">memoizedState</span>,</span><br><span class="line"></span><br><span class="line">      <span class="attr">baseState</span>: currentHook.<span class="property">baseState</span>,</span><br><span class="line">      <span class="attr">baseQueue</span>: currentHook.<span class="property">baseQueue</span>,</span><br><span class="line">      <span class="attr">queue</span>: currentHook.<span class="property">queue</span>,</span><br><span class="line"></span><br><span class="line">      <span class="attr">next</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (workInProgressHook === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 若 workInProgressHook 为 null，作为首节点赋值给 memoizedState</span></span><br><span class="line">      currentlyRenderingFiber.<span class="property">memoizedState</span> = workInProgressHook = newHook;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 将 workInProgressHook 添加到链表尾</span></span><br><span class="line">      workInProgressHook = workInProgressHook.<span class="property">next</span> = newHook;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgressHook;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们详细理解一下上述代码，前面我们提到过 <strong>renderWithHooks</strong>函数中会执行如下代码：<strong>workInProgress.memoizedState &#x3D; null</strong>，所以在执行上述函数时，正常来说 <strong>currentlyRenderingFiber.memoizedState</strong>为 null，需要从 current fiber 对应的节点中取 clone 对应的 hook，再挂载到 workInProgress fiber 的 memoizedState 链表上；re-render 的情况下，由于已经创建过了 hooks，会复用已有的 workInProgress fiber 的 memoizedState。<br>这里正好提到，为什么 hook 不能用在条件语句中，因为如果前后两次渲染的条件判断不一致时，会导致 current fiber 和 workInProgress fiber 的 hooks 链表结点无法对齐。</p>

        <h1 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结" class="headerlink" title="总结"></a>总结</h1>
      <p>所以我们总结一下<strong>renderWithHooks</strong>这个函数，它所做的事情如下：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/8cbbf443229943d89902355c2dc5d373_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>

        <h1 id="hooks-源码"   >
          <a href="#hooks-源码" class="heading-link"><i class="fas fa-link"></i></a><a href="#hooks-源码" class="headerlink" title="hooks 源码"></a>hooks 源码</h1>
      <p>前面 hooks 的执行入口我们都找到了，现在我们看一下常用的一些 hooks 源码。</p>

        <h2 id="useState-amp-useReducer"   >
          <a href="#useState-amp-useReducer" class="heading-link"><i class="fas fa-link"></i></a><a href="#useState-amp-useReducer" class="headerlink" title="useState &amp; useReducer"></a>useState &amp; useReducer</h2>
      <p>这里会把 useState 和 useReducer 放在一起来说，因为 useState 相当于一个简化版的 useReducer。</p>

        <h3 id="用法"   >
          <a href="#用法" class="heading-link"><i class="fas fa-link"></i></a><a href="#用法" class="headerlink" title="用法"></a>用法</h3>
      <p>useState 的简单用法如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 改变 count 的值</span></span><br><span class="line"><span class="title function_">setCount</span>(count++);</span><br></pre></td></tr></table></div></figure>

<p>useReducer 简单用法如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, dispatch] = <span class="title function_">useReducer</span>(<span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increment&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 改变 count 的值</span></span><br><span class="line"><span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;increment&quot;</span> &#125;);</span><br></pre></td></tr></table></div></figure>


        <h3 id="mountState-amp-mountReducer"   >
          <a href="#mountState-amp-mountReducer" class="heading-link"><i class="fas fa-link"></i></a><a href="#mountState-amp-mountReducer" class="headerlink" title="mountState &amp; mountReducer"></a>mountState &amp; mountReducer</h3>
      <p>我们先从 useState 开始讲起，mount 阶段，useState 对应的源码是 mountState。这里面后创建初始的 hook 和更新队列 queue，然后创建 dispatch，最终返回 [hook.memoizedState, dispatch]，对应的是我们代码中的 [count, setCount]，供我们使用：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  <span class="comment">// 创建一个 hook，链接到 hooks 链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="comment">// 校验初始的 state 是否是个函数，是的话执行该函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> initialState === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    initialState = <span class="title function_">initialState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 前面提到过，对于 useState，memoizedState 保存的是 state</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = hook.<span class="property">baseState</span> = initialState;</span><br><span class="line">  <span class="comment">// 创建更新队列 updateQueue</span></span><br><span class="line">  <span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>, <span class="comment">// 待执行的 hook</span></span><br><span class="line">    <span class="attr">dispatch</span>: <span class="literal">null</span>, <span class="comment">// 更新函数</span></span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: basicStateReducer, <span class="comment">// 上次渲染的 reducer</span></span><br><span class="line">    <span class="attr">lastRenderedState</span>: (<span class="attr">initialState</span>: any), <span class="comment">// 上次渲染的 state</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 创建 dispatch（负责更新的函数）</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt; = (queue.<span class="property">dispatch</span> =</span><br><span class="line">    (dispatchAction.<span class="title function_">bind</span>(<span class="literal">null</span>, currentlyRenderingFiber, queue): any));</span><br><span class="line">  <span class="comment">// 返回 useState 的 state 及 dispatch，供我们使用</span></span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>再来看下 mount 阶段的 useReducer 的源码，也就是 mountReducer，可以看到和 mountState 所做的事情基本时一样的，mountState 可以看做是有一个初始 state 的 mountReducer：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountReducer&lt;S, I, A&gt;(</span><br><span class="line">  <span class="attr">reducer</span>: <span class="function">(<span class="params">S, A</span>) =&gt;</span> S,</span><br><span class="line">  <span class="attr">initialArg</span>: I,</span><br><span class="line">  init?: <span class="function">(<span class="params">I</span>) =&gt;</span> S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;A&gt;] &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">let</span> initialState;</span><br><span class="line">  <span class="keyword">if</span> (init !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    initialState = <span class="title function_">init</span>(initialArg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    initialState = ((<span class="attr">initialArg</span>: any): S);</span><br><span class="line">  &#125;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = hook.<span class="property">baseState</span> = initialState;</span><br><span class="line">  <span class="keyword">const</span> queue = (hook.<span class="property">queue</span> = &#123;</span><br><span class="line">    <span class="attr">pending</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">dispatch</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">lastRenderedReducer</span>: reducer,</span><br><span class="line">    <span class="attr">lastRenderedState</span>: (<span class="attr">initialState</span>: any),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;A&gt; = (queue.<span class="property">dispatch</span> = (dispatchAction.<span class="title function_">bind</span>(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    currentlyRenderingFiber,</span><br><span class="line">    queue</span><br><span class="line">  ): any));</span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="dispatchAction"   >
          <a href="#dispatchAction" class="heading-link"><i class="fas fa-link"></i></a><a href="#dispatchAction" class="headerlink" title="dispatchAction"></a>dispatchAction</h3>
      <p>上面的代码中，其他内容我们前面基本都有讲过，你们应该了解它们的作用，我们着重来看一下 dispatch，它是通过执行 dispatchAction 创建的。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> dispatchAction&lt;S, A&gt;(</span><br><span class="line"><span class="attr">fiber</span>: <span class="title class_">Fiber</span>,</span><br><span class="line"><span class="attr">queue</span>: <span class="title class_">UpdateQueue</span>&lt;S, A&gt;,</span><br><span class="line"><span class="attr">action</span>: A,</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 获取更新触发时间及优先级</span></span><br><span class="line"><span class="keyword">const</span> eventTime = <span class="title function_">requestEventTime</span>();</span><br><span class="line"><span class="keyword">const</span> lane = <span class="title function_">requestUpdateLane</span>(fiber);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 update</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">update</span>: <span class="title class_">Update</span>&lt;S, A&gt; = &#123;</span><br><span class="line">lane,</span><br><span class="line">action,</span><br><span class="line"><span class="attr">eagerReducer</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">eagerState</span>: <span class="literal">null</span>,</span><br><span class="line"><span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 update 链接到更新队列中</span></span><br><span class="line"><span class="keyword">const</span> pending = queue.<span class="property">pending</span>;</span><br><span class="line"><span class="keyword">if</span> (pending === <span class="literal">null</span>) &#123;</span><br><span class="line">update.<span class="property">next</span> = update;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">update.<span class="property">next</span> = pending.<span class="property">next</span>;</span><br><span class="line">pending.<span class="property">next</span> = update;</span><br><span class="line">&#125;</span><br><span class="line">queue.<span class="property">pending</span> = update;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> alternate = fiber.<span class="property">alternate</span>;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">fiber === currentlyRenderingFiber ||</span><br><span class="line">(alternate !== <span class="literal">null</span> &amp;&amp; alternate === currentlyRenderingFiber)</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">// currentlyRenderingFiber 存在，说明是在 render 过程发生的更新</span></span><br><span class="line">didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">fiber.<span class="property">lanes</span> === <span class="title class_">NoLanes</span> &amp;&amp;</span><br><span class="line">(alternate === <span class="literal">null</span> || alternate.<span class="property">lanes</span> === <span class="title class_">NoLanes</span>)</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">// fiber.lanes === NoLanes 说明是首次更新</span></span><br><span class="line"><span class="comment">// 如果值不同，则保存在 eagerState，下次 render 时可以直接使用，而无需再计算。</span></span><br><span class="line"><span class="keyword">const</span> lastRenderedReducer = queue.<span class="property">lastRenderedReducer</span>;</span><br><span class="line"><span class="keyword">if</span> (lastRenderedReducer !== <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">let</span> prevDispatcher;</span><br><span class="line"><span class="keyword">if</span> (**<span class="variable constant_">DEV</span>**) &#123;</span><br><span class="line">prevDispatcher = <span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span>;</span><br><span class="line"><span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = <span class="title class_">InvalidNestedHooksDispatcherOnUpdateInDEV</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">currentState</span>: S = (queue.<span class="property">lastRenderedState</span>: any);</span><br><span class="line"><span class="comment">// 我们可以根据当前 state 和 action 来计算新的 state 值</span></span><br><span class="line"><span class="keyword">const</span> eagerState = <span class="title function_">lastRenderedReducer</span>(currentState, action);</span><br><span class="line">update.<span class="property">eagerReducer</span> = lastRenderedReducer;</span><br><span class="line">update.<span class="property">eagerState</span> = eagerState;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">is</span>(eagerState, currentState)) &#123;</span><br><span class="line"><span class="comment">// 如果与当前值相同，则跳过更新</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果值不同，新一轮更新时渲染 eagerState</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line"><span class="comment">// Suppress the error. It will throw again in the render phase.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (**<span class="variable constant_">DEV</span>**) &#123;</span><br><span class="line"><span class="title class_">ReactCurrentDispatcher</span>.<span class="property">current</span> = prevDispatcher;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 开启调度，触发新的一轮更新，也就是走 beginWork, completeWork 那一套流程</span></span><br><span class="line"><span class="title function_">scheduleUpdateOnFiber</span>(fiber, lane, eventTime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enableSchedulingProfiler) &#123;</span><br><span class="line"><span class="title function_">markStateUpdateScheduled</span>(fiber, lane);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>首先，会创建一个初始的 update 对象，用来记录相关的 hook 信息，并将它添加到 queue 中，这里的 queue 的添加你可以发现它形成了一个循环链表，这样 pending 作为链表的一个尾结点，而 pending.next 就能够获取链表的头结点。这样做的目的是，在 setCount 时，我们需要将 update 添加到链表的尾部；而在下面的 updateReducer 中，我们需要获取链表的头结点来遍历链表，通过循环链表能够轻松实现我们的需求。<br>之后，会根据当前所处的阶段是否在 render 阶段发生：</p>
<p>如果是 render 阶段发生，那么会触发 re-render 过程，将 didScheduleRenderPhaseUpdateDuringThisPass 置为 true。前面 renderWithHooks 的代码中我们说了，didScheduleRenderPhaseUpdateDuringThisPass 为 true 时会代表 re-render，会重新执行 render 过程，直至其为 false。<br>如果不是在 render 阶段发生，那么会通过当前的 state 和 action 来判断下次渲染的 state 的值，并与当前 state 的值进行比较，如果两个值一致，则不需要更新，跳过更新过程；如果两个值不一致，调用 scheduleUpdateOnFiber 开始调度，触发新一轮更新。</p>

        <h3 id="updateReducer"   >
          <a href="#updateReducer" class="heading-link"><i class="fas fa-link"></i></a><a href="#updateReducer" class="headerlink" title="updateReducer"></a>updateReducer</h3>
      <p>update 时，useState 和 useReducer 就更没什么区别了，updateState 就是直接返回了 updateReducer 函数，所以我们直接看 updateReducer 的源码就可以。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateState&lt;S&gt;(</span><br><span class="line">  <span class="attr">initialState</span>: (<span class="function">() =&gt;</span> S) | S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;<span class="title class_">BasicStateAction</span>&lt;S&gt;&gt;] &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">updateReducer</span>(basicStateReducer, (<span class="attr">initialState</span>: any));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>updateReducer 中，用 pending 来指向本次要触发的 update，然后将本次 hook 要执行的 update 和 current fiber 中之前未完成的 update 全部链接到 baseQueue，也就是代表全局的 update。<br>在 render 阶段，会遍历 update 来计算 state 的值，若某个 update 的优先级低于当前 render 执行的任务的优先级，则跳过此次 update 及未遍历完的 update 的执行，先执行其他的 update。然后再下一次 render 时从跳过的 update 开始继续执行。<br>update 阶段 dispatch 会生成一个新的 update 链接到 hooks 中，并根据之前的 state 和本次 action 去计算新的 state。<br>updateReducer 的源码如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateReducer&lt;S, I, A&gt;(</span><br><span class="line">  <span class="attr">reducer</span>: <span class="function">(<span class="params">S, A</span>) =&gt;</span> S,</span><br><span class="line">  <span class="attr">initialArg</span>: I,</span><br><span class="line">  init?: <span class="function">(<span class="params">I</span>) =&gt;</span> S</span><br><span class="line">): [S, <span class="title class_">Dispatch</span>&lt;A&gt;] &#123;</span><br><span class="line">  <span class="comment">// 取出 hook 节点</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> queue = hook.<span class="property">queue</span>;</span><br><span class="line">  <span class="title function_">invariant</span>(</span><br><span class="line">    queue !== <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;Should have a queue. This is likely a bug in React. Please file an issue.&quot;</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  queue.<span class="property">lastRenderedReducer</span> = reducer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">current</span>: <span class="title class_">Hook</span> = (<span class="attr">currentHook</span>: any);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上次未完成的 update</span></span><br><span class="line">  <span class="keyword">let</span> baseQueue = current.<span class="property">baseQueue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取本次待执行的 update</span></span><br><span class="line">  <span class="keyword">const</span> pendingQueue = queue.<span class="property">pending</span>;</span><br><span class="line">  <span class="keyword">if</span> (pendingQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果 baseQueue 和 pendingQueue 都存在，将 pendingQueue 链接到 baseQueue 尾部</span></span><br><span class="line">      <span class="keyword">const</span> baseFirst = baseQueue.<span class="property">next</span>;</span><br><span class="line">      <span class="keyword">const</span> pendingFirst = pendingQueue.<span class="property">next</span>;</span><br><span class="line">      baseQueue.<span class="property">next</span> = pendingFirst;</span><br><span class="line">      pendingQueue.<span class="property">next</span> = baseFirst;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// react 的异步模型，可能发生一个更高优先级任务打断当前任务的执行</span></span><br><span class="line">    <span class="comment">// 所以要将 baseQueue 也赋值给 current fiber</span></span><br><span class="line">    current.<span class="property">baseQueue</span> = baseQueue = pendingQueue;</span><br><span class="line">    queue.<span class="property">pending</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (baseQueue !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> first = baseQueue.<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">let</span> newState = current.<span class="property">baseState</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newBaseState = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueFirst = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newBaseQueueLast = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> update = first;</span><br><span class="line">    <span class="comment">// 遍历 hooks 链表，计算 state</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> updateLane = update.<span class="property">lane</span>;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">isSubsetOfLanes</span>(renderLanes, updateLane)) &#123;</span><br><span class="line">        <span class="comment">// 如果当前的 update 优先级低于 render 优先级，下次 render 时再执行本次的 update</span></span><br><span class="line">        <span class="keyword">const</span> <span class="attr">clone</span>: <span class="title class_">Update</span>&lt;S, A&gt; = &#123;</span><br><span class="line">          <span class="attr">lane</span>: updateLane,</span><br><span class="line">          <span class="attr">action</span>: update.<span class="property">action</span>,</span><br><span class="line">          <span class="attr">eagerReducer</span>: update.<span class="property">eagerReducer</span>,</span><br><span class="line">          <span class="attr">eagerState</span>: update.<span class="property">eagerState</span>,</span><br><span class="line">          <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 把这个 update 添加到 newBaseQueue 中下次 render 执行</span></span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">          newBaseQueueFirst = newBaseQueueLast = clone;</span><br><span class="line">          newBaseState = newState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.<span class="property">next</span> = clone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新 queue 的优先级</span></span><br><span class="line">        currentlyRenderingFiber.<span class="property">lanes</span> = <span class="title function_">mergeLanes</span>(</span><br><span class="line">          currentlyRenderingFiber.<span class="property">lanes</span>,</span><br><span class="line">          updateLane</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 标记本次 update 跳过了</span></span><br><span class="line">        <span class="title function_">markSkippedUpdateLanes</span>(updateLane);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newBaseQueueLast !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// newBaseQueueLast 不为 null，说明此前有跳过的 update</span></span><br><span class="line">          <span class="comment">// update 之间可能存在依赖，将后续 update 都连接到 newBaseQueue 中留到下次 render 执行</span></span><br><span class="line">          <span class="keyword">const</span> <span class="attr">clone</span>: <span class="title class_">Update</span>&lt;S, A&gt; = &#123;</span><br><span class="line">            <span class="attr">lane</span>: <span class="title class_">NoLane</span>,</span><br><span class="line">            <span class="attr">action</span>: update.<span class="property">action</span>,</span><br><span class="line">            <span class="attr">eagerReducer</span>: update.<span class="property">eagerReducer</span>,</span><br><span class="line">            <span class="attr">eagerState</span>: update.<span class="property">eagerState</span>,</span><br><span class="line">            <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">          &#125;;</span><br><span class="line">          newBaseQueueLast = newBaseQueueLast.<span class="property">next</span> = clone;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行本次的 update，计算新的 state</span></span><br><span class="line">        <span class="keyword">if</span> (update.<span class="property">eagerReducer</span> === reducer) &#123;</span><br><span class="line">          <span class="comment">// update.eagerReducer 和 reducer 相等，说明 reducer 已经计算过，直接取结算过的 state</span></span><br><span class="line">          newState = ((update.<span class="property">eagerState</span>: any): S);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 根据 state 和 action 计算新的 state</span></span><br><span class="line">          <span class="keyword">const</span> action = update.<span class="property">action</span>;</span><br><span class="line">          newState = <span class="title function_">reducer</span>(newState, action);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      update = update.<span class="property">next</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (update !== <span class="literal">null</span> &amp;&amp; update !== first);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newBaseQueueLast === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// newBaseQueueLast 为 null，说明所有 update 处理完了，更新 baseState</span></span><br><span class="line">      newBaseState = newState;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 未处理完留到下次执行</span></span><br><span class="line">      newBaseQueueLast.<span class="property">next</span> = (<span class="attr">newBaseQueueFirst</span>: any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的 state 和之前的 state 不相等，标记需要更新</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">is</span>(newState, hook.<span class="property">memoizedState</span>)) &#123;</span><br><span class="line">      <span class="title function_">markWorkInProgressReceivedUpdate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的 state 和 baseQueue 保存到 hook 中</span></span><br><span class="line">    hook.<span class="property">memoizedState</span> = newState;</span><br><span class="line">    hook.<span class="property">baseState</span> = newBaseState;</span><br><span class="line">    hook.<span class="property">baseQueue</span> = newBaseQueueLast;</span><br><span class="line"></span><br><span class="line">    queue.<span class="property">lastRenderedState</span> = newState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">dispatch</span>: <span class="title class_">Dispatch</span>&lt;A&gt; = (queue.<span class="property">dispatch</span>: any);</span><br><span class="line">  <span class="keyword">return</span> [hook.<span class="property">memoizedState</span>, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结-1"   >
          <a href="#总结-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3>
      <p>总结一下 useState 和 useReducer 的执行过程如下图：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/f6dd618d1c1642a6bbec25ed82c0a408_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>

        <h2 id="useEffect"   >
          <a href="#useEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2>
      <p>同样，我们也分为 mount 和 update 两种情况来看 useEffect。</p>

        <h3 id="用法-1"   >
          <a href="#用法-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#用法-1" class="headerlink" title="用法"></a>用法</h3>
      <p>useEffect 的使用大家应该都了解，在这里就不赘述了，我们本次的用例如下：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;unmount&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, [count]);</span><br></pre></td></tr></table></div></figure>


        <h3 id="mountEffect"   >
          <a href="#mountEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#mountEffect" class="headerlink" title="mountEffect"></a>mountEffect</h3>
      <p>mount 阶段 useEffect 实际上是调用了 mountEffect 方法，进一步通过传递参数调用了 mountEffectImpl 这个函数：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  create: () =&gt; (() =&gt; <span class="keyword">void</span>) | <span class="keyword">void</span>, <span class="comment">// 执行的回调函数</span></span></span><br><span class="line"><span class="params">  deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span> <span class="comment">// 依赖项</span></span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">mountEffectImpl</span>(</span><br><span class="line">    <span class="title class_">UpdateEffect</span> | <span class="title class_">PassiveEffect</span>,</span><br><span class="line">    <span class="title class_">HookPassive</span>,</span><br><span class="line">    create,</span><br><span class="line">    deps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>和 mountState 中所做的事情类似，mountEffectImpl 中首先通过 mountWorkInProgressHook 创建了 hook 链接到 hooks 链表中，前面提到过 useEffect 的 hook 是一个 Effect 类型的对象。然后通过 pushEffect 方法创建一个 effect 添加到 hook 的 memoizedState 属性：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mountEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 创建 hook 并链接到 hooks 链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  currentlyRenderingFiber.<span class="property">flags</span> |= fiberFlags;</span><br><span class="line">  <span class="comment">// 创建一个 effect 对象并添加到 hook 的 memoizedState 中</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(</span><br><span class="line">    <span class="title class_">HookHasEffect</span> | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    <span class="literal">undefined</span>,</span><br><span class="line">    nextDeps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="pushEffect"   >
          <a href="#pushEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#pushEffect" class="headerlink" title="pushEffect"></a>pushEffect</h3>
      <p><strong>pushEffect</strong>函数中主要做了两件事，创建 effect 对象，然后将其添加到 fiber 的 updateQueue 链表上：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pushEffect</span>(<span class="params">tag, create, destroy, deps</span>) &#123;</span><br><span class="line">  <span class="comment">// 创建 effect</span></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">effect</span>: <span class="title class_">Effect</span> = &#123;</span><br><span class="line">    tag,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    deps,</span><br><span class="line">    <span class="comment">// Circular</span></span><br><span class="line">    <span class="attr">next</span>: (<span class="attr">null</span>: any),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">componentUpdateQueue</span>: <span class="literal">null</span> | <span class="title class_">FunctionComponentUpdateQueue</span> =</span><br><span class="line">    (currentlyRenderingFiber.<span class="property">updateQueue</span>: any);</span><br><span class="line">  <span class="keyword">if</span> (componentUpdateQueue === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// componentUpdateQueue 为 null，将 effect 添加到 componentUpdateQueue 头结点</span></span><br><span class="line">    componentUpdateQueue = <span class="title function_">createFunctionComponentUpdateQueue</span>();</span><br><span class="line">    currentlyRenderingFiber.<span class="property">updateQueue</span> = (<span class="attr">componentUpdateQueue</span>: any);</span><br><span class="line">    componentUpdateQueue.<span class="property">lastEffect</span> = effect.<span class="property">next</span> = effect;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 链接到当前 fiber 节点的 updateQueue 的 lastEffect 中</span></span><br><span class="line">    <span class="keyword">const</span> lastEffect = componentUpdateQueue.<span class="property">lastEffect</span>;</span><br><span class="line">    <span class="comment">// 构成循环链表结构</span></span><br><span class="line">    <span class="keyword">if</span> (lastEffect === <span class="literal">null</span>) &#123;</span><br><span class="line">      componentUpdateQueue.<span class="property">lastEffect</span> = effect.<span class="property">next</span> = effect;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> firstEffect = lastEffect.<span class="property">next</span>;</span><br><span class="line">      lastEffect.<span class="property">next</span> = effect;</span><br><span class="line">      effect.<span class="property">next</span> = firstEffect;</span><br><span class="line">      componentUpdateQueue.<span class="property">lastEffect</span> = effect;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="updateEffect"   >
          <a href="#updateEffect" class="heading-link"><i class="fas fa-link"></i></a><a href="#updateEffect" class="headerlink" title="updateEffect"></a>updateEffect</h3>
      <p>update 阶段，<strong>useEffect</strong>实际上是调用了<strong>updateEffect</strong>函数，同样是进一步调用了<strong>updateEffectImpl</strong>函数：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateEffect</span>(<span class="params"></span></span><br><span class="line"><span class="params">  create: () =&gt; (() =&gt; <span class="keyword">void</span>) | <span class="keyword">void</span>,</span></span><br><span class="line"><span class="params">  deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span></span><br><span class="line"><span class="params"></span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">updateEffectImpl</span>(</span><br><span class="line">    <span class="title class_">UpdateEffect</span> | <span class="title class_">PassiveEffect</span>,</span><br><span class="line">    <span class="title class_">HookPassive</span>,</span><br><span class="line">    create,</span><br><span class="line">    deps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>所以我们接着往下看<strong>updateEffectImpl</strong>函数做了什么，它从 <strong>updateWorkInProgressHook</strong>取出对应的 hook，然后看上一轮 render 中是否有 hook 存在，若存在且上一轮 render 和本轮的依赖项没发生变化，说明副作用不需要执行，创建一个 effect 对象添加到 updateQueue 链表后直接返回；若两次的依赖项发生了变化，向 fiber 添加 flags 副作用标签，待 commit 时更新，然后再创建一个 effect 对象添加到 updateQueue 链表：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateEffectImpl</span>(<span class="params">fiberFlags, hookFlags, create, deps</span>): <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="comment">// 从 hooks 链表中取出对应 hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">let</span> destroy = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentHook !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 若上一轮 render 对应 hook 存在</span></span><br><span class="line">    <span class="keyword">const</span> prevEffect = currentHook.<span class="property">memoizedState</span>;</span><br><span class="line">    destroy = prevEffect.<span class="property">destroy</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps = prevEffect.<span class="property">deps</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="comment">// 若上一轮和本次的依赖项未发生变化，说明没有副作用</span></span><br><span class="line">        <span class="comment">// 创建一个 effect 对象添加到 updateQueue 链表中，然后返回</span></span><br><span class="line">        <span class="title function_">pushEffect</span>(hookFlags, create, destroy, nextDeps);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行到这里说明上一轮和本轮依赖项发生变化</span></span><br><span class="line">  <span class="comment">// 向 fiber 添加 flags 副作用标签，待 commit 时更新</span></span><br><span class="line">  currentlyRenderingFiber.<span class="property">flags</span> |= fiberFlags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个 effect 对象添加到 updateQueue 链表中</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = <span class="title function_">pushEffect</span>(</span><br><span class="line">    <span class="title class_">HookHasEffect</span> | hookFlags,</span><br><span class="line">    create,</span><br><span class="line">    destroy,</span><br><span class="line">    nextDeps</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="总结-2"   >
          <a href="#总结-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3>
      <p>总结一下 useEffect 的大体流程如下：</p>
<p><img src="https://raw.githubusercontent.com/niki571/MyImageHost/main/22a64ff368474815b9cbc58fefd755a8_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp"></p>

        <h2 id="useRef"   >
          <a href="#useRef" class="heading-link"><i class="fas fa-link"></i></a><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2>
      <p><strong>useRef</strong>的代码十分的简单了，我们直接将 mount 阶段和 update 阶段的放到一起来看：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountRef&lt;T&gt;(<span class="attr">initialValue</span>: T): &#123;| <span class="attr">current</span>: T |&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> ref = &#123; <span class="attr">current</span>: initialValue &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = ref;</span><br><span class="line">  <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateRef&lt;T&gt;(<span class="attr">initialValue</span>: T): &#123;| <span class="attr">current</span>: T |&#125; &#123;</span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">return</span> hook.<span class="property">memoizedState</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>mount 阶段，调用<strong>mountRef</strong>函数，通过 <strong>mountWorkInProgressHook</strong>创建一个 hook 并添加到 hooks 链表上，<strong>hook.memoizedState</strong>上存储的是{current: initialValue}这个 ref 对象。<br>update 阶段，调用<strong>updateRef</strong>函数，通过<strong>updateWorkInProgressHook</strong>方法直接取出<strong>hook.memoizedState</strong>。<br>可以看到<strong>hook.memoizedState</strong>指向的是一个对象的引用，这就解释了我们可以直接通过 <strong>ref.current</strong>去改变和获取最新的值，不必进行任何依赖注入。</p>

        <h2 id="useCallback-amp-useMemo"   >
          <a href="#useCallback-amp-useMemo" class="heading-link"><i class="fas fa-link"></i></a><a href="#useCallback-amp-useMemo" class="headerlink" title="useCallback &amp; useMemo"></a>useCallback &amp; useMemo</h2>
      <p><strong>useCallback</strong>和<strong>useMemo</strong>也是一样，源码结构上十分相似，所以也放在一起来讲。</p>

        <h3 id="用法-2"   >
          <a href="#用法-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#用法-2" class="headerlink" title="用法"></a>用法</h3>
      <p>基础用法如下：<br>&#x2F;&#x2F; 第一个参数是 “创建” 函数，第二个参数是依赖项数组<br>&#x2F;&#x2F; “创建” 函数会根据依赖项数组返回一个值，并且仅会在某个依赖项改变时才重新计算</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">add</span>(a, b), [a, b]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是回调函数，第二个参数是依赖项数组</span></span><br><span class="line"><span class="comment">// 依赖项改变时回调函数会进行更新</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">add</span>(a, b);</span><br><span class="line">&#125;, [a, b]);</span><br></pre></td></tr></table></div></figure>


        <h3 id="mount-阶段"   >
          <a href="#mount-阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#mount-阶段" class="headerlink" title="mount 阶段"></a>mount 阶段</h3>
      <p>mount 时，分别调用了<strong>mountCallback</strong>和<strong>mountMemo</strong>函数，两者都通过 <strong>mountWorkInProgressHook</strong>方法创建 hook 添加到了 hooks 链表中。不同的是，<strong>mountCallback</strong>的 memoizedState 是[callback, nextDeps]，并且返回的是其第一个参数；<strong>mountMemo</strong>的 memoizedState 是 [nextValue, nextDeps]，返回的也是 nextValue 也就是其第一个参数的执行结果。<br>所以看上去<strong>useMemo</strong>就是比<strong>useCallback</strong>多了一步第一个参数的执行过程。</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="comment">// 创建 hook 添加到链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> mountMemo&lt;T&gt;(</span><br><span class="line">  <span class="attr">nextCreate</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span><br><span class="line">): T &#123;</span><br><span class="line">  <span class="comment">// 创建 hook 添加到链表中</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">mountWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>();</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="update-阶段"   >
          <a href="#update-阶段" class="heading-link"><i class="fas fa-link"></i></a><a href="#update-阶段" class="headerlink" title="update 阶段"></a>update 阶段</h3>
      <p>update 时，分别调用了<strong>updateCallback</strong>和<strong>updateMemo</strong> 函数，它们都通过 <strong>updateWorkInProgressHook</strong>取出对应的 hook，若依赖项未发生改变，则取上一轮的 callback 或者 value 返回；若依赖项发生改变，则重新赋值 hook.memoizedState 并返回新的 callback 或新计算的 value：</p>
<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/react-reconciler/src/ReactFiberHooks.old.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateCallback&lt;T&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span>): T &#123;</span><br><span class="line">  <span class="comment">// 获取对应 hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">prevDeps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 依赖项未发生改变，取上一轮的 callback 并返回</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖项改变了，重新赋值 hook.memoizedState，返回新的 callback</span></span><br><span class="line">  hook.<span class="property">memoizedState</span> = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> updateMemo&lt;T&gt;(</span><br><span class="line">  <span class="attr">nextCreate</span>: <span class="function">() =&gt;</span> T,</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span><br><span class="line">): T &#123;</span><br><span class="line">  <span class="comment">// 获取对应 hook</span></span><br><span class="line">  <span class="keyword">const</span> hook = <span class="title function_">updateWorkInProgressHook</span>();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.<span class="property">memoizedState</span>;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">prevDeps</span>: <span class="title class_">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="comment">// 依赖项未发生改变，取上一轮的值并返回</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">areHookInputsEqual</span>(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖项改变了，计算新的值，重新赋值 hook.memoizedState 并返回新的值</span></span><br><span class="line">  <span class="keyword">const</span> nextValue = <span class="title function_">nextCreate</span>();</span><br><span class="line">  hook.<span class="property">memoizedState</span> = [nextValue, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> nextValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="结语"   >
          <a href="#结语" class="heading-link"><i class="fas fa-link"></i></a><a href="#结语" class="headerlink" title="结语"></a>结语</h1>
      <p>本章讲解了 react hooks 的源码，理解了 hooks 的设计思想和工作过程。其他 hook 平时用的比较少，就不在这里展开讲了，但通过上面几个 hook 的源码讲解，其他 hook 看源码你应该也能看得懂。</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/stun-logo.svg" alt="avatar"></div><p class="sidebar-ov-author__text">Keep studying, Keep Creating</p></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>WuQianying</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v6.3.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/npm/ribbon.js@latest/dist/ribbon.min.js" size="120" alpha="0.6" zIndex="-1"></script><script src="https://cdn.jsdelivr.net/npm/pjax@latest/pjax.min.js"></script><script>window.addEventListener('DOMContentLoaded', function () {
  var pjax = new Pjax({"selectors":["head title","#main",".pjax-reload",".header-banner"],"history":true,"scrollTo":false,"scrollRestoration":false,"cacheBust":false,"debug":false,"currentUrlFullReload":false,"timeout":0});
  // 加载进度条的计时器
  var loadingTimer = null;

  // 重置页面 Y 方向上的滚动偏移量
  document.addEventListener('pjax:send', function () {
    $('.header-nav-menu').removeClass('show');
    if (CONFIG.pjax && CONFIG.pjax.avoidBanner) {
      $('html').velocity('scroll', {
        duration: 500,
        offset: $('#header').height(),
        easing: 'easeInOutCubic'
      });
    }

    var loadingBarWidth = 20;
    var MAX_LOADING_WIDTH = 95;

    $('.loading-bar').addClass('loading');
    $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    clearInterval(loadingTimer);
    loadingTimer = setInterval(function () {
      loadingBarWidth += 3;
      if (loadingBarWidth > MAX_LOADING_WIDTH) {
        loadingBarWidth = MAX_LOADING_WIDTH;
      }
      $('.loading-bar__progress').css('width', loadingBarWidth + '%');
    }, 500);
  }, false);

  window.addEventListener('pjax:complete', function () {
    clearInterval(loadingTimer);
    $('.loading-bar__progress').css('width', '100%');
    $('.loading-bar').removeClass('loading');
    setTimeout(function () {
      $('.loading-bar__progress').css('width', '0');
    }, 400);
    $('link[rel=prefetch], script[data-pjax-rm]').each(function () {
      $(this).remove();
    });
    $('script[data-pjax], #pjax-reload script').each(function () {
      $(this).parent().append($(this).remove());
    });

    if (Stun.utils.pjaxReloadBoot) {
      Stun.utils.pjaxReloadBoot();
    }
    if (Stun.utils.pjaxReloadScroll) {
      Stun.utils.pjaxReloadScroll();
    }
    if (Stun.utils.pjaxReloadSidebar) {
      Stun.utils.pjaxReloadSidebar();
    }
    if (false) {
      if (Stun.utils.pjaxReloadHeader) {
        Stun.utils.pjaxReloadHeader();
      }
      if (Stun.utils.pjaxReloadScrollIcon) {
        Stun.utils.pjaxReloadScrollIcon();
      }
      if (Stun.utils.pjaxReloadLocalSearch) {
        Stun.utils.pjaxReloadLocalSearch();
      }
    }
  }, false);
}, false);</script><div id="pjax-reload"></div><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script></body></html>